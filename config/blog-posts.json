[
  {
    "meta": {
      "title": "Governance for Asynchronous APIs: Announcing AsyncAPI & Spectral – Together!",
      "date": "2022-05-25T14:00:00.000Z",
      "type": "Community",
      "tags": [
        "API Governance"
      ],
      "cover": "/img/posts/creating-consistency-announcing-asyncapi-spectral-together/cover.webp",
      "authors": [
        {
          "name": "Jakub Rozek",
          "photo": "/img/avatars/jrozek.webp",
          "link": "https://rozek.tech/",
          "byline": "Senior Software Engineer at Stoplight"
        }
      ],
      "excerpt": "The collaboration between Stoplight’s open-source linting tool, Spectral, and AsyncAPI will be a game-changer for creating more consistency in your API program. Check out what comes with the release of the AsyncAPI ruleset!\n",
      "featured": true,
      "readingTime": 6
    },
    "content": "\nThe collaboration between Stoplight’s open-source linting tool, Spectral, and AsyncAPI is going to be a game changer for creating more consistency in your API program. Check out what comes with the release of the AsyncAPI ruleset!\n\nConsistency is a top concern for companies across the globe.\n\nAt Stoplight, we’re seeking to help your organization achieve consistency. We believe that API descriptions should be\ntreated the same way as code. APIs should have style guides with rules, and be reviewed to ensure they are descriptive,\nreadable, and concise for the developers who use them. Developer experience is, after all, another top concern for\ncompanies.\n\nSo, we created our open-source JSON linting tool Spectral. It promotes standards with the flexibility for custom rule\ncreation to validate and lint any JSON.\n\nFor example, while an AsyncAPI or OpenAPI document might be entirely valid, it could be missing important fields like\ndescriptions for parameters or have other problematic design issues. Spectral can warn about possible improvements to\nensure API definitions can reach their full potential, without needing to have special code owners review every change\nto the documents.\n\nAlthough Spectral is mostly referenced in the context of OpenAPI, AsyncAPI has been an integral\npart of Spectral for quite some time now. In fact, last month our Spectral AsyncAPI ruleset celebrated its\nsecond anniversary.\n\n## Why AsyncAPI?\n\nWhile OpenAPI remains one of the top specifications, AsyncAPI is growing. And each has their own [unique benefits and\nchallenges](https://www.asyncapi.com/blog/openapi-vs-asyncapi-burning-questions). The ability to have options gives Spectral users more flexibility for their APIs.\n\nSpectral had primarily been an OpenAPI linter that was simply capable of working with other JSON documents. Now, by\nenabling AsyncAPI rulesets, organizations can achieve the consistency they’re looking for with more flexibility.\n\n## Introducing AsyncAPI & Spectral - Together!\n\nThe release of [AsyncAPI ruleset](https://meta.stoplight.io/docs/spectral/ZG9jOjUzNDg-async-api-rules) was more than just another feature added; it was considered a milestone. Previously,\nSpectral lacked meaningful rulesets for other formats, and the number of learning resources was somewhat limited, making\nthe adaption of Spectral outside of OpenAPI rather minimal.\n\nOur collaboration with AsyncAPI means that we’ve given the respective AsyncAPI maintainers write access to the Spectral\nrepo AsyncAPI rulesets, though here at Stoplight we will still continue to operate with PRs, and ensure these get\npriority.\n\n### The Game Changer\n\nThe introduction of support for another major API definition helped us further assess its level of importance as well as\ninitiated a notable shift in the way we perceived Spectral internally. Treating AsyncAPI ruleset as a first-class\ncitizen pushed us to entirely decouple our codebase from OpenAPI. The core purpose of Spectral (linting API definitions)\nremained unchanged and still holds true, but from an engineering standpoint, it meant a shift in focus to the other\nspecs and a renewed attention on writing code that can be applicable everywhere.\n\nBack in 2018 or 2019, plenty of code was oriented around OpenAPI, tests, and naming. All were focused solely on OpenAPI,\nmeaning rulesets themselves couldn’t be applied easily to other formats (Spectral didn’t support them previously).\n\nWith the release of [Spectral 6](https://blog.stoplight.io/api-linting-with-spectral-keeps-getting-better), that transition period wrapped up and Spectral is now more flexible than it’s ever been.\n\n## Steps to Utilizing AsyncAPI & Spectral\n\nLinting AsyncAPI documents is quite similar to linting OpenAPI documents, meaning\nmost of the information about Spectral you’ll find on the internet will apply to AsyncAPI. Together with AsyncAPI\ninitiative, we [maintain a Spectral ruleset](https://meta.stoplight.io/docs/spectral/ZG9jOjUzNDg-async-api-rules) containing a number of useful rules you can leverage in your workflow to help\nyou get started.\n\n**Step One:**\n\nTo get started, you need to [install Spectral first](https://meta.stoplight.io/docs/spectral/docs/getting-started/2-installation.md). Note that you need to have [npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) or\n[Yarn](https://yarnpkg.com/getting-started/install) installed, running `npm install -g @stoplight/spectral-cli` or `yarn global add @stoplight/spectral-cli` is sufficient\nto get Spectral. \n\nThe CLI package bundles [@stoplight/spectral-rulesets](https://www.npmjs.com/package/@stoplight/spectral-rulesets) which\ncontains the actual ruleset we’ll use.\nIf you intend to use an older version of the AsyncAPI ruleset, you could additionally install a different version of @stoplight/spectral-rulesets.\nHowever, it’s an optional step, and it's generally recommended to stick with the latest versions if possible.\n\n**Step Two:**\n\nOnce you’ve got all the required dependencies installed, you can start by creating a simple ruleset. To do so,\ncreate a file called `.spectral.json`. The following template can be used as a decent baseline:\n\n```json\n{\n  // This makes sure our rules apply only to AsyncAPI documents. \n  // It might be handy in case you have other specs in the directory you intend to lint.\n  \"formats\": [\"asyncapi2\"],\n  // this includes the ruleset linked below\n  // https://meta.stoplight.io/docs/spectral/ZG9jOjUzNDg-async-api-rules\n  // Note that by default, only recommended rules are enabled. \n  // Some rules listed in the article above may not be a fit for you,\n  // therefore we don’t enable them by default.\n  \"extends\": \"spectral:asyncapi\",\n  \"rules\": {\n    // we can add our own rules here\n  }\n}\n```\n\n**Step Three:**\n\nTo better facilitate the actual demands, Spectral allows you to create your own rules. These rules will fill the gaps\nand cover use cases unique to your workflow, or style guide. While a more thorough [reference regarding custom rules is\navailable here](https://meta.stoplight.io/docs/spectral/ZG9jOjI1MTg5-custom-rulesets#adding-rules), a basic rule could look as follows. The rule we’re about to implement will assert the presence and correctness of the version inside of the `Info` object.\n\n```json\n{\n  \"message\": \"Version must match 1.x.x\",\n  // one can also define description property here, \n  // which is supposed to be a markdown string\n  // containing a more detailed explanation about the rule\n  \"severity\": \"error\", // or warn, or info, or hint\n  // any JSONPath-compliant expression\n  // https://goessner.net/articles/JsonPath/\n  \"given\": \"$.info\",\n  \"then\": [\n    {\n      \"field\": \"version\",\n      \"function\": \"defined\"\n    },\n    {\n      \"field\": \"version\",\n      \"function\": \"pattern\",\n      \"functionOptions\": {\n        \"match\": \"^1(\\\\.[0-9]+){2}$\"\n      }\n    }\n  ]\n}\n```\n\n**Step four:**\n\nNow that we have a basic rule, we can insert it into the ruleset we previously created:\n\n```json\n{\n  \"formats\": [\n    \"asyncapi2\"\n  ],\n  \"extends\": \"spectral:asyncapi\",\n  \"rules\": {\n    \"valid-document-version\": {\n      \"message\": \"Version must match 1.x.x\",\n      \"severity\": \"error\",\n      \"given\": \"$.info\",\n      \"then\": [\n        {\n          \"field\": \"version\",\n          \"function\": \"defined\"\n        },\n        {\n          \"field\": \"version\",\n          \"function\": \"pattern\",\n          \"functionOptions\": {\n            \"match\": \"^1(\\\\.[0-9]+){2}$\"\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n**Step five:**\n\nNow that we have all the pieces together, we can run Spectral. We’ll take the [`Hello World` example from the AsyncAPI documentation](https://www.asyncapi.com/docs/getting-started/hello-world).\n\n```yaml\n# hello-world.yaml\nasyncapi: 2.2.0\ninfo:\n  title: Hello world application\n  version: '0.1.0'\nchannels:\n  hello:\n    publish:\n      message:\n        payload:\n          type: string\n          pattern: '^hello .+$'\n```\n\nTo lint, execute the following command:\n\n`spectral lint hello-world.yaml`\n\n![Spectral Lint Results](/img/posts/creating-consistency-announcing-asyncapi-spectral-together/lint-results.webp)\n\nThanks to the built-in AsyncAPI ruleset, we receive more feedback than just the information about invalid document versions. The default configuration is usually reasonable for most, but should you want to tweak the version, please visit our [documentation](https://meta.stoplight.io/docs/spectral/ZG9jOjI1MTg5-custom-rulesets#modifying-rules) that explains everything in greater detail.\n\nTada! :tada:\n\nWe are looking forward to the continued collaboration with AsyncAPI and the exciting things to come. Let us know your\nthoughts about what you would like to see next or visit the [API design blog](https://blog.stoplight.io/) for more insights.\n",
    "toc": [
      {
        "content": "Why AsyncAPI?",
        "slug": "why-asyncapi",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Introducing AsyncAPI & Spectral - Together!",
        "slug": "introducing-asyncapi--spectral---together",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "The Game Changer",
        "slug": "the-game-changer",
        "lvl": 3,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Steps to Utilizing AsyncAPI & Spectral",
        "slug": "steps-to-utilizing-asyncapi--spectral",
        "lvl": 2,
        "i": 3,
        "seen": 0
      }
    ],
    "slug": "/blog/creating-consistency-announcing-asyncapi-spectral-together",
    "filePath": "pages/blog/creating-consistency-announcing-asyncapi-spectral-together.md"
  },
  {
    "meta": {
      "title": "Summary of things that happened at AsyncAPI Initiative from January to April, 2022",
      "date": "2022-04-29T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/2022Q1-summary/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Gardener"
        }
      ],
      "excerpt": "New AsyncAPI brand. AsyncAPI 2.4 and work on the 3.0 spec release. Meetings organization change. 2022 conference organization. AND SO MUCH MORE!",
      "featured": true,
      "readingTime": 9
    },
    "content": "\n<iframe src=\"https://anchor.fm/asyncapi/embed/episodes/Summary-of-things-that-happened-at-AsyncAPI-Initiative-from-January-to-April--2022-e1hqbi1\" height=\"102px\" width=\"100%\" frameborder=\"0\" scrolling=\"no\"></iframe>\n\nWelcome to another update from the AsyncAPI Initiative. In this article, I want to highlight the most important items contributed to AsyncAPI during the first few months of 2022.\n\nI usually ask the community if folks have anything important that I should put in my updates. Still, this is a pretty subjective article because it's based mainly on things I see in my personal bubble. :smiley:\n\n## Brand Refresh\n\nThis one is pretty easy to spot, especially if you have been with AsyncAPI Initiative for some time. :smiley:\n\nOn March 10, we announced a change to the AsyncAPI brand. Change that was needed. A refresh of this faded green that I personally never liked. :joy:\n\n<TwitterTweetEmbed\n  tweetId='1501977719915098120'\n  options={{\n    cards: 'hidden',\n    width: 200,\n    maxWidth: 400\n  }}\n/>\n\nIt was a massive effort led by [Missy Turco](https://twitter.com/missyturco). Months of work, research, and discussions with the community.\n\nIt is not all. More work in the area is needed:\n- Design System :muscle: - Get involved in the [related design system repository](https://github.com/asyncapi/design-system) if you are interested in helping out. \n- AsyncAPI Mascots refresh - We need to refresh our existing Eve and Chan mascots to match the new brand. Any help would be appreciated.\n\nFor more regular news and updates on topics around brand and design in AsyncAPI Initiative, I definitely recommend you follow [Missy Turco](https://twitter.com/missyturco) and read her [regular design updates](https://missyturco.notion.site/03556522990e4067ae877fd236c37268?v=d60154483de849cd8125f8333cfe1d36).\n\n## AsyncAPI Conference\n\nWe want to organize our first hybrid conference, one you can watch online and participate in person. May is right behind the corner, so not much time is left. We need to start working actively on the event now.\n\nWe discuss all aspects of our upcoming conference in our [Community Discussion for 2022 Conference Organization](https://github.com/asyncapi/community/discussions/categories/asyncapi-conf-2022-organization) openly. Please join and actively support the effort. We need lots of volunteers to make this happen. \n\nWe need to have a special task force that will focus on the subject. Please join the [discussion on hosting a conference-dedicated weekly meeting](https://github.com/asyncapi/community/discussions/322).\n\n## Meetings scheduling automation and related changes\n\nBecause of the community's growth and the growing number of topic-specific meetings, we had to spend some time improving things and automating as much as possible. After some initial discussions, such as [this discussion about Google-services](https://github.com/asyncapi/community/discussions/236), some initial requirements were defined, called [Meeting as a Service](https://github.com/asyncapi/community/issues/245).\n\n- A week ago, we stopped using our `asyncapi-users` Google Group. We removed it, and all the members were migrated as subscribers to the AsyncAPI Newsletter. This newsletter is the new place where we'll send email notifications every Monday morning with a list of upcoming meetings.\n- We switched to the new Google Calendar instance managed by the official AsyncAPI Google account. You should remove/unsubscribe from the old calendar and [subscribe to the new calendar](https://calendar.google.com/calendar/u/3?cid=Y19xOXRzZWlnbG9tZHNqNm5qdWh2YnB0czExY0Bncm91cC5jYWxlbmRhci5nb29nbGUuY29t),\n- [Our Technical Steering Committee (TSC)](https://github.com/asyncapi/community/discussions/295) approved to sponsor 8 Zoom licenses to host official AsyncAPI meetings. So far, only 3 licenses have been assigned. We have lots of room for more meetings and hosts, if there is a need.\n\nHuge thanks to [Krishna Kumar](https://github.com/Krishks369) and [Shreyansh Jain](https://github.com/sudoshreyansh), who helped research the implementation. :heart:\n\nIf you want to learn more about becoming a meeting host, or something else related to meetings, get familiar with our [dedicated meetings FAQ](https://github.com/asyncapi/community/blob/master/MEETINGS_ORGANIZATION.md).\n\nOh, and I almost forgot, look at this. :point_down: :star: \nAll [info about AsyncAPI-related meetings](https://www.asyncapi.com/community/meetings) is in one beautiful place! :heart:\n\n<Figure\n  src=\"/img/posts/2022Q1-summary/meetings.webp\"\n  className=\"text-center\"\n  caption=\"View of dedicated community/meetings page on the AsyncAPI website.\"\n/>\n\n## Upcoming 2.4 and 3.0 releases of the spec\n\nWe released a [new 2.4.0 version of AsyncAPI Specification](https://github.com/asyncapi/spec/releases/tag/v2.4.0). There are many good features, like the possibility to provide a unique Message `id` for the entire AsyncAPI file or the ability to specify that security is valid only for a given operation. You definitely need to read the[release notes](https://www.asyncapi.com/blog/release-notes-2.4.0).\n\nHuge shout out to [Sergio Moya](https://twitter.com/smoyac), who was a release coordinator for the 2.4.0 release and pushed all the doors to make sure the release could go out.\n\n2.4.0 was released, but this doesn't block us from working on something much bigger, 3.0.0 version of the specification! :rocket:\n\nIf you haven't heard about 3.0.0 yet, I highly recommend you have a look at the [3.0.0 release article](https://www.asyncapi.com/blog/async-api-spec-3.0-release) written by [Harsh Mishra](https://www.linkedin.com/in/harshcasper/).\n\nPlease join these efforts, as there is much work ahead of us, but not many hands doing actual work. We meet every two weeks to sync the work efforts and discuss important topics. Feel free to join :pray:\n\nI also recommend following [Sergio Moya](https://twitter.com/smoyac) and reaching for his [regular updates on specification-related efforts](https://gist.github.com/smoya)\n\n## Contributors onboarding initiatives\n\nOne of the [goals for our 2022 community-building efforts](https://github.com/asyncapi/community/discussions/193) was to involve AsyncAPI Initiative as a mentoring organization in as many coding (but not only) events as possible. We have many maintainers here who like to help first-time contributors land their first pull requests in an open and relaxed environment.\n\n### Google Summer of Code\n\nWe did not start well. We were not accepted for [Google Summer of Code](https://summerofcode.withgoogle.com). Don't ask me why. I really do not know. I wish I could have a clear answer from them about what failed on my end, where I made mistakes in our application. :cry: \n\nWe never give up here at AsyncAPI, though. :smiley:\n\n### OpenForce\n\nMarch was a month where we joined [OpenForce](https://www.asyncapi.com/blog/openforce-2022) thanks to amazing support from [Hargun Kaur](https://www.linkedin.com/in/hkaur008/). As a result, we managed to onboard a few new folks and gained important contributions in exchange. There are  a few PRs still open, but here are some of the completed PRs:\n- [Namya LG](https://github.com/Namyalg) introduced a great improvement to our CI by creating dedicated [CI workflows that search for broken links](https://github.com/asyncapi/.github/issues/92) in our documentation across all repositories.\n- [Harsh Mishra](https://www.linkedin.com/in/harshcasper/) introduced a [CI workflow that validates docker images](https://github.com/asyncapi/server-api/issues/50) in projects where we publish them.\n- [Abhijeet Jejurkar](https://github.com/abhijeetjejurkar) [improved the Kubernetes deployment for our `server-api` service](https://github.com/asyncapi/server-api/issues/57).\n- [Samriddhi](https://github.com/Samridhi-98) contributed a [new `/bundle` endpoint to our `server-api` service](https://github.com/asyncapi/server-api/issues/55).\n- [Ritik Rawal](https://github.com/ritik307) contributed a [new `/diff` endpoint to our `server-api` service](https://github.com/asyncapi/server-api/issues/56).\n- [Everly Precia Suresh](https://github.com/everly-gif) added a possibility to [host API reference docs for our `server-api` service](https://github.com/asyncapi/server-api/issues/43) through a dedicated endpoint.\n\nIt is also super important to mention [Abir Pal](https://twitter.com/imabptweets), who helped to coordinate efforts and was the first point of contact for the community coming from OpenForce channels.\n\n### Google Season of Docs\n\nSuccess with OpenForce was followed by the unexpected announcement that AsyncAPI was accepted as an organization for Google Season of Docs (GSoD) 2022, with a $10k budget. :muscle:\n\n<TwitterTweetEmbed\n  tweetId='1514670329246801926'\n  options={{\n    cards: 'hidden',\n    width: 200,\n    maxWidth: 400\n  }}\n/>\n\nAn amazing success for [Alejandra Quetzalli](https://twitter.com/QuetzalliAle) and an excellent opportunity for the AsyncAPI Initiative to improve its documentation big time!\nOn May 16, we will announce the names of six interns we want to hire to work on two different projects to have better docs. Alejandra leads a super challenging task to interview as many candidates as possible (around 150!). Keep your fingers crossed.\n\nAlejandra and I will be mentors for our GSoD interns in the following months. Stay tuned to watch the progress.\n\n### AsyncAPI Mentorship\n\nWe did not want to give up even though the Google Summer of Code (GSoC) 2022 application was declined. We knew many community members joined and started contributing because they counted on AsyncAPI being part of GSoC. \n\nWell tl;dr, our TSC just accepted an idea to start our own [AsyncAPI Mentorship](https://github.com/asyncapi/community/discussions/284) program! :rocket:\n\nNow we have until May 15 to discuss with mentors your [mentorship ideas](https://github.com/issues?q=is%3Aopen+org%3Aasyncapi+label%3Agsoc), understand the scope of each idea, and state clearly for which idea you are a candidate. Then we will ask TSC to vote and select 10 ideas that the AsyncAPI Initiative should sponsor this year.\n\n## AsyncAPI Training\n\nICYMI, we run an effort to create official AsyncAPI training videos. [Barbaño González](https://www.linkedin.com/in/barbano-gonzalez-moreno/) leads this topic and almost finished [training scripts and storyboards](https://github.com/asyncapi/training/pulls) for the first set of videos.\n\nI do not think it is a secret to say that great content is created only with great input, feedback, and review from people waiting for it. Please join Barbaño's efforts with any help you can, as she is not doing it for herself but the community.\n\nI recommend you [follow Barbaño's monthly updates](https://gist.github.com/Barbanio), especially if you want to participate.\n\n## Docs Feedback Form\n\nOne of our missions is to have kick-ass documentation. Easy, right? \n\nWriting docs is easy, just like writing code (at least in my opinion :stuck_out_tongue_winking_eye:). Well, we all know the devil is hidden in details. Details like gathering requirements, figuring out architecture, and making sure you have a well-motivated group of people working on it. And last but not least, make sure the community can easily share feedback on your work transparently.\n\nI wrote already about [Alejandra Quetzalli](https://twitter.com/QuetzalliAle) and the efforts to get AsyncAPI into GSoD. Getting a well-motivated group of people to work on docs, checked. :white_check_mark:\n\nOur [new docs information architecture is almost here too](https://github.com/asyncapi/website/pull/601). I think we can say \"checked\" :white_check_mark: to this one too.\n\nSince this week, we can also say \"checked\" :white_check_mark: to the idea of **getting docs feedback** from the community.\n\n<TwitterTweetEmbed\n  tweetId='1518596333749391363'\n  options={{\n    width: 200,\n    maxWidth: 400\n  }}\n/>\n\nEach documentation page has a dedicated feedback form that one can fill in anonymously. The form injects the feedback into a [docs-related GitHub Discussion like this example](https://github.com/asyncapi/community/discussions/340).\n\nHuge applause to:\n- [Alejandra Quetzalli](https://twitter.com/QuetzalliAle) for leading the change\n- [Missy Turco](https://twitter.com/missyturco) for amazing support with design\n- [Maciej Urbanczyk](https://github.com/magicmatatjahu) for detailed review\n- [Akshat Nema](https://twitter.com/AksNema) for implementation. Akshat demonstrated a lot of patience here. As an individual contributor, he waited for the merge for quite some time. There was a long discussion, many parties involved. Many contributors lost interest in such long-running PRs. Not Akshat! :muscle:\n\nAnyway, I recommend you follow [Alejandra](https://twitter.com/QuetzalliAle) and her [regular docs-related updates](https://gist.github.com/alequetzalli).\n\n> Photo by <a href=\"https://unsplash.com/@mitchel3uo\">Mitchell Luo</a> on <a href=\"https://unsplash.com/photos/H3htK85wwnU\">Unsplash</a>\n",
    "toc": [
      {
        "content": "Brand Refresh",
        "slug": "brand-refresh",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "AsyncAPI Conference",
        "slug": "asyncapi-conference",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Meetings scheduling automation and related changes",
        "slug": "meetings-scheduling-automation-and-related-changes",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Upcoming 2.4 and 3.0 releases of the spec",
        "slug": "upcoming-24-and-30-releases-of-the-spec",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Contributors onboarding initiatives",
        "slug": "contributors-onboarding-initiatives",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Google Summer of Code",
        "slug": "google-summer-of-code",
        "lvl": 3,
        "i": 5,
        "seen": 0
      },
      {
        "content": "OpenForce",
        "slug": "openforce",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Google Season of Docs",
        "slug": "google-season-of-docs",
        "lvl": 3,
        "i": 7,
        "seen": 0
      },
      {
        "content": "AsyncAPI Mentorship",
        "slug": "asyncapi-mentorship",
        "lvl": 3,
        "i": 8,
        "seen": 0
      },
      {
        "content": "AsyncAPI Training",
        "slug": "asyncapi-training",
        "lvl": 2,
        "i": 9,
        "seen": 0
      },
      {
        "content": "Docs Feedback Form",
        "slug": "docs-feedback-form",
        "lvl": 2,
        "i": 10,
        "seen": 0
      }
    ],
    "slug": "/blog/2022Q1-summary",
    "filePath": "pages/blog/2022Q1-summary.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Spec 2.4.0 Release Notes",
      "date": "2022-04-28T08:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Specification",
        "Release Notes"
      ],
      "cover": "/img/posts/release-notes-2.4.0/cover.webp",
      "authors": [
        {
          "name": "Sergio Moya",
          "photo": "/img/avatars/smoya.webp",
          "link": "https://twitter.com/smoyac",
          "byline": "Pilot at AsyncAPI Airlines"
        }
      ],
      "excerpt": "AsyncAPI 2.4 is now released. This brings really helpful additions, such as the new `messageId` field, Server Variables reusability, and security at Operation level",
      "featured": true,
      "readingTime": 4
    },
    "content": "\nThe new version of the AsyncAPI specification - 2.4.0 - is now available.\n\n> This is a minor release, and it doesn't bring any breaking changes. You can switch to it by modifying the following value in your AsyncAPI file `asyncapi: '2.3.0'` into `asyncapi: '2.4.0'`\n\n## Message uniqueness thanks to the new messageId field\n\nAs operations have `OperationId`, AsyncAPI messages can now define `messageId`. This new field is used to identify a message across a whole AsyncAPI document uniquely.\nThis new field will be helpful in tools that ask the user to select a message as input, such as validating their schema or filtering code to be generated.\n\nFor example:\n\n```yaml\nasyncapi: 2.4.0\ncomponents:\n  messages:\n    SomeMessage:\n      messageId: SomeMessage\n      payload:\n        type: object\n        properties:\n          name:\n            type: string\n```\n\nThis new feature was contributed by [Waleed Ashraf](https://github.com/WaleedAshraf).\nFor more detail, see [Waleed's `/spec #751`pull request](https://github.com/asyncapi/spec/pull/751) and the [Github issue where Waleed's `MessageId` feature addition was discussed](https://github.com/asyncapi/spec/issues/458).\n\n## Server Variables can be now referenced from components\n\nTo allow for more flexibility in how AsyncAPI documents are structured and enable content to be reused, `serverVariables` can now be defined as reusable components.\n\nFor example:\n\n```yaml\nasyncapi: 2.4.0\nservers:\n  development:\n    $ref: '#/components/servers/myserver'\n  production:\n    $ref: '#/components/servers/myserver'\ncomponents:\n  servers:\n    myserver:\n      url: \"{stage}.my-server.com:{port}\"\n      protocol: ws\n      variables:\n        stage:\n          $ref: \"#/components/serverVariables/stage\"\n        port:\n          $ref: \"#/components/serverVariables/port\"\n  serverVariables:\n    stage:\n      default: dev\n    port:\n      enum: [5000, 6000]\n      default: 5000\n```\n\nThese are added to the many other aspects of the AsyncAPI specification which can be declared as reusable components. You can see the full list in the [Components Object section of the AsyncAPI specification](https://www.asyncapi.com/docs/specifications/v2.4.0#componentsObject).\n\nThis new feature was contributed by [Daniel Kocot](https://github.com/danielkocot). For more detail, see [Daniel's `/spec #717` pull request](https://github.com/asyncapi/spec/pull/717) and the [Github issue where Daniel's change to `serverVariables ` was discussed](https://github.com/asyncapi/spec/issues/707).\n\n## Security can now be defined at Operation level\n\nUntil today, Security requirements were defined at Server level. That restricted the security requirements to be the same for all channels linked with a Server, and for all operations of those channels.\nIn fact, when setting Security in both the Server and the Operation, both should be satisfied.\n\nFor example:\n\n```yaml\nasyncapi: 2.4.0\nservers:\n  production:\n    url: \"mykafkacluster.org:8092\"\n    protocol: kafka-secure\n    security:\n      - service_auth:\n         - auth:write\n         - auth:read\nchannels:\n  some/events:\n    servers:\n      - production\n    subscribe:\n      # This operation level security implies the ability to subscribe to messages from\n      # `some/events` channel with Authorization headers \n      # that have `auth:read` scope. Note that an operation level security must still satisfy \n      # security requirements specified at the server level.\n      security:\n        - service_auth:\n          - auth:read  \n```\n\nThanks to [Sekharbans](https://github.com/sekharbans-ebay), is now possible to increase security granularity by defining a set of security requirements at Operation level. For more detail, see [Sekharban's `/spec #584` pull request](https://github.com/asyncapi/spec/pull/584) and the [Github issue where Sekharban's suggested feature was discussed](https://github.com/asyncapi/spec/issues/584).\n\n## Reusability of Servers defined in Components is clarified in the specification\n\nReusability of Servers was introduced in [AsyncAPI 2.3.0](https://www.asyncapi.com/blog/release-notes-2.3.0#servers-and-channels-can-now-be-defined-as-reusable-components). However, the change was not fully clarified in the specification, leading to confusion.\n\nThanks to [Vladimir Gorej](https://github.com/char0n), this is now clarified by mentioning that elements for the Servers Object can be either Server Object or a Reference Object.\nFor more detail, see [Vladimir's `/spec #706`pull request](https://github.com/asyncapi/spec/pull/706) and the [Github issue where Vladimir's Servers Object change was discussed](https://github.com/asyncapi/spec/issues/705).\n\n## Tooling support\n\nThe following official AsyncAPI tools are already updated to support 2.4.0 version of the specification:\n- JSON Schema that supports validation of AsyncAPI documents is updated in [this](https://github.com/asyncapi/spec-json-schemas) repository. Also **@asyncapi/specs** package has been updated on NPM to version `2.14.0`, and it contains the 2.4.0 JSON Schema.\n- [JavaScript Parser](https://github.com/asyncapi/parser-js/) uses latest **@asyncapi/specs** package and can be used to parse and validate 2.4.0 documents. Upgrade to `1.15.0` version.\n- [HTML template](https://github.com/asyncapi/html-template) uses the latest **@asyncapi/react-component** package. Upgrade to `0.24.9` version.\n- [JavaScript Converter](https://github.com/asyncapi/converter-js/) enables conversion from any AsyncAPI version into the 2.4.0 version of the spec. Upgrade to `0.11.0` version.\n- [Generator](https://github.com/asyncapi/generator/) uses the latest @asyncapi/parser package, so while generating output, it can validate 2.4.0 documents. Upgrade to `1.9.3` version.\n\nLast but not least is the AsyncAPI Studio. [Check out the Studio with this example](https://studio.asyncapi.com/?url=https://raw.githubusercontent.com/asyncapi/spec/v2.4.0/examples/websocket-gemini.yml).\n\n## Look ahead\n\nWe aim to have a regular cadence of releases of the AsyncAPI specification, four times a year. For more information about when to expect future releases, you can see our [release process document](https://github.com/asyncapi/spec/blob/master/RELEASE_PROCESS.md#release-cadence).\n\nWe're also working on the next major release of the AsyncAPI specification: 3.0.0. If you'd like to contribute, or just follow the discussions, you can see [Work on 3.0 release issue](https://github.com/asyncapi/spec/issues/691).\n\n> Photo by <a href=\"https://unsplash.com/@andurache?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Alexandru Tudorache</a> on <a href=\"https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "Message uniqueness thanks to the new messageId field",
        "slug": "message-uniqueness-thanks-to-the-new-messageid-field",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Server Variables can be now referenced from components",
        "slug": "server-variables-can-be-now-referenced-from-components",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Security can now be defined at Operation level",
        "slug": "security-can-now-be-defined-at-operation-level",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Reusability of Servers defined in Components is clarified in the specification",
        "slug": "reusability-of-servers-defined-in-components-is-clarified-in-the-specification",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Tooling support",
        "slug": "tooling-support",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Look ahead",
        "slug": "look-ahead",
        "lvl": 2,
        "i": 5,
        "seen": 0
      }
    ],
    "slug": "/blog/release-notes-2.4.0",
    "filePath": "pages/blog/release-notes-2.4.0.md"
  },
  {
    "meta": {
      "title": "📑 Google Season of Docs 2022 at AsyncAPI",
      "date": "2022-03-25T05:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "Documentation",
        "Announcement"
      ],
      "cover": "/img/posts/gsod-2022/SeasonofDocs_Logo.webp",
      "authors": [
        {
          "name": "Alejandra Quetzalli",
          "photo": "/img/avatars/canela-ale.webp",
          "link": "https://www.linkedin.com/in/alejandra-quetzalli/",
          "byline": "Our proposal? Update Docs Information Architecture"
        }
      ],
      "excerpt": "Check out the Docs project proposal we're submitting to GSoD 2022! You won't want to miss out.",
      "featured": true,
      "readingTime": 9
    },
    "content": "\n## ¡Hola, AsyncAPI community! \nFor today's blog post about AsyncAPI Docs 📑, I wanted to share with all technical writers about our organization’s plan for participation in `Google Season of Docs 2022 (GSoD)`. Any and all technical writers are welcome to come participate with us for GSoD 2022 season, regardless of tech background or years of experience! At AsyncAPI, we love mentoring folks who want to get involved in OSS, tech, and Docs. ❤️\n\nAs some of you may remember from my [Gist Docs update for 31 Jan - 11 Feb 2022](https://gist.github.com/alequetzalli/94ca1ffb5d123b450501e40a4a3b56e2), I noted that GSoD 2022 was coming up and that AsyncAPI wanted to participate in the application process once it opened on February 23, 2022.  \n\nIn anticipation of this, I also created a new AsyncAPI Slack channel named `#temp-gsod-2022` that anyone can join! First, [join our Slack workspace](https://www.asyncapi.com/slack-invite) ☎️  and please respect [our slack etiquette](https://github.com/asyncapi/.github/blob/master/slack-etiquette.md).🙂 Then join the `temp-gsod-2022` channel, our temporary channel to coordinate GSoC 2022 setup. I'll publish regular updates on where we are in the application process, so stay tuned as the process continues. 😄\n\nJoin the `#temp-gsod-2022` slack channel for:\n- mentees identification\n- mentors identification\n- ideas identification\n- mentees and ideas and mentors matching\n\n\nBelow is the **project proposal** we're submitting to `GSoD 2022` and then we close with a reminder of how to get started as an AsyncAPI Docs contributor:\n\n\n___ \n\n# Update Docs Information Architecture - AsyncAPI Initiative \n\n## About AsyncAPI\nAsyncAPI (currently version 2.3.0, first released in 2016) is an Apache License 2.0 library [under the Linux Foundation](https://www.linuxfoundation.org/press-release/linux-foundation-will-host-asyncapi-to-support-growth-and-collaboration-for-industrys-fastest-growing-api-spec/) that seeks to improve the current state of Event-Driven Architectures (EDA). The AsyncAPI Initiative is a specification and growing set of open-source tools to help developers define asynchronous APIs, and build and maintain event-driven architectures. Developers familiar with OpenAPI (aka Swagger) for RESTful APIs will see strong similarities when using AsyncAPI. One common use case is generating documentation (HTML or Markdown) of an asynchronous API. The specification is both platform and language agnostic. Current tooling includes support for common message brokers such as Apache Kafka and RabbitMQ, and languages including Python, Java, and Nodejs. Our long-term goal is to make working with EDAs as easy as working with REST APIs. That goes from documentation to code generation, from discovery to event management, and beyond. Our 150+ Open-Source (OSS) contributors are EDA enthusiasts from all around the world. \n\n\n## About our Docs project\n\n### Our current Docs problem\nOur current Docs and their Information Architecture (IA) needs a major makeover. The current content buckets are far from ideal and much basic content is missing to help onboard new contributors. Users new to our API spec need `/Conceptual` docs that explain our spec terminology in more detail with engineering diagrams: people often learn visually! We also have to move our CLI docs under the Docs upcoming new `Reference` content bucket; currently, we have a README version of CLI docs only. Similarly, we're adding a new and broader `/Tools` section of documentation for our tools in individual tools' GitHub repositories, under a `/docs` directory. Those should still remain there and continue to be maintained, but they also need to be documented in our Docs in a less informal way than what you see in a README. In time, we also need to add many more tutorials (i.e. Websocket, Kafka, etc) and Use Cases and Troubleshooting Guides, under a new `How-To` section.\n\nWe also need to re-structure the [Generator tool](https://github.com/asyncapi/template-for-generator-templates) docs. Because this is one of our main tools, it's big enough to be it's own independent project for 2022 GSoD. Currently, our Generator docs need a major update, to better explain every single functionality of the Generator. \n\n\n### Our Docs project’s scope\nWe're already invested in utilizing the [Diátaxis methodology](https://diataxis.fr/) for determining our **content buckets** _(Concepts, Tutorials, Tools, How-To Guides, Reference)_. Along with this change, it makes sense to add new landing pages that introduce each content bucket. Each content bucket landing page could include cards featuring requested content from the community that still needs contributions. Then each card will read, \"Contributors Needed.\" \n\nAsyncAPI has several CLI and Tools markdown README documentation in miscellaneous GitHub repositories that we plan to migrate over to the main Docs site. This task is part of our goal for finalizing our 2022 AsyncAPI Docs Information Architecture makeover. We explain this in more detail in our previous OSS blog post titled [\"Change is coming to our AsyncAPI Developer Documentation\"](https://www.asyncapi.com/blog/changes-coming-docs). It's also extensively documented in our [AsyncAPI Docs GitHub Project Board](https://github.com/orgs/asyncapi/projects/8). \n\nIn addition, we want to also target improving the [Generator tool](https://github.com/asyncapi/template-for-generator-templates) docs that are only READMEs in a repo right now. The Docs for this one tool are a big enough job to merit being our 2nd proposed project for 2022 GSoD.\n\nWe're also writing voluntary OSS bi-weekly updates via GitHub Gists to speak about the latest updates made in the AsyncAPI Docs Ecosystem. Due to our commitment to investing time in gaining interest in our community and getting Google excited about us, we've made sure to maintain updates about our `Google Season of Docs 2022` application too! In fact, you can take a look at the latest three where we made said mentions here in [AsyncAPI Docs update (31 Jan - 11 Feb 2022)](https://gist.github.com/alequetzalli/94ca1ffb5d123b450501e40a4a3b56e2), [AsyncAPI Docs update (14 Feb - 25 Feb 2022)](https://gist.github.com/alequetzalli/d34e3aececa49d10d0ddb2dc9938b477), and [AsyncAPI Docs update (28 Feb - 11 March 2022)](https://gist.github.com/alequetzalli/8f449f731b919193f4101098a69da14d).\n\n### Measuring our Docs project’s success\nWe will partially measure success in the Docs project by capturing specific feedback about the IA changes via our soon-to-come new [Docs Feedback card](https://github.com/asyncapi/website/issues/453). We need this specific and granular feedback to make sure we listen and make changes according to what the community requests from Docs. In previous AsyncAPI Docs Gist updates, we've mentioned that Design contributors were teaming with Docs on `/website`issue [#453](https://github.com/asyncapi/website/issues/453) for the ideation and development of our new **feedback card** that will be added at the bottom of each Docs page. What the community decided over the last 2 weeks was that the `Submit feedback` button in the card will publish the feedback anonymously via the AsyncAPI bot and create a new **GitHub Discussion** with said feedback:\n\n![A screenshot displaying the design of our new feedback card for receiving feedback on AsyncAPI Docs](/img/posts/gsod-2022/feedback-card.webp)\n\n![A screenshot of AsyncAPI GitHub Discussions for the Docs category](/img/posts/gsod-2022/docs-community-discussions.webp)  \n\nThe other way we would consider the project successful is the number of our contributors and Docs PRs increased from 3 to 6 community members. Currently, a majority of our OSS contributor community focuses only on contributing code, but we would like to instill a greater interest in contributing to documentation that provides value for everyone.\n\n\n### Timeline\nThe project itself will take approximately 4-6 months to complete, depending on the different levels of knowledge from diverse technical writers (TW) that might get involved. (At AsyncAPI, we want to work with any TW, regardless of their years of experience. We have a passion for mentorship, and we do not wish to have a bar that would prevent any TW from contributing to our OSS Initiative. In fact, we look forward to potentially mentoring TW(s) who are completely new to tech and making them feel welcome!)\n\nFor our 2 projects, we would like to request a minimum of 2 TWs, so that we can work on both the CLI/Tools and Generator Docs. \n\nThe timeline would look as follows:\n- **May:** Orientation on how to contribute to AsyncAPI Inititiave, how Docs issues are organized, detail how we're migrating our CLI and Tools Docs, and assign good `first-time-tickets` to get each new TW contributor started. \n- **June - August:**\tEach TW goes through designated issues marked for both first time contributors and work set aside for `GSoD 2022`. Each TW starts creating documentation for their individual issues assigned/selected. \n- **September - October:** We determine if we're going to be able to complete both CLI and Tools Docs plus the Generator Docs, depending on how many TWs are in our group and how much they've been able to complete so far. We re-align priorities as needed and asses what is missing to reach our 2022 IA change goals for AsyncAPI Docs.\n- **November:**\tProject completion and all contributors receive some swag! \n\n\n### Project budget\nWe have set aside 2 mentors for now, for our 2 projects: improving our IA and re-structuring our Generator Docs. Should we be selected, AsyncAPI would like to request from Google a US $5000 budget for each project. For both projects, the request then totals for a $10,000 budget.  \n\n| **Budget item**                                                                                      | **Total Amount** |\n|------------------------------------------------------------------------------------------------------|------------------|\n| Technical writer updates, reviews, edits, and publishing new documentation for the IA improvements.  | $5000            |\n| Technical writer updates, reviews, migration, and publishing improved Generator tool documentation.  | $5000            |\n\n___ \n\n## Get started contributing to AsyncAPI Docs Today\nLast but not least, don't forget that code isn't the only way to contribute to OSS; Dev Docs are a **huge** help that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution. ❤️\n\nTo get started as a Docs contributor:\n1. Familiarize yourself with our [project's Contribution Guide](https://github.com/asyncapi/community/blob/master/CONTRIBUTING.md) and our [Code of Conduct](https://github.com/asyncapi/.github/blob/master/CODE_OF_CONDUCT.md).\n2. Head over to our Docs GH Board [here](https://github.com/orgs/asyncapi/projects/8).\n3. Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started. \n4. If there is no work done in that Docs issue yet, feel free to open a PR and get started!\n\n### Tag me in your AsyncAPI Doc PRs\nDo you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear!\n\nTag me in your AsyncAPI Doc PRs or [GitHub Discussions](https://github.com/asyncapi/community/discussions/categories/docs) via my GitHub handle, [`alequetzalli`](https://github.com/alequetzalli) 🐙.\n\n\n_-A.Q. 👩🏻‍💻 and Canela 🐕‍🦺_",
    "toc": [
      {
        "content": "¡Hola, AsyncAPI community!",
        "slug": "¡hola-asyncapi-community",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Update Docs Information Architecture - AsyncAPI Initiative",
        "slug": "update-docs-information-architecture---asyncapi-initiative",
        "lvl": 1,
        "i": 1,
        "seen": 0
      },
      {
        "content": "About AsyncAPI",
        "slug": "about-asyncapi",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "About our Docs project",
        "slug": "about-our-docs-project",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Our current Docs problem",
        "slug": "our-current-docs-problem",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Our Docs project’s scope",
        "slug": "our-docs-projects-scope",
        "lvl": 3,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Measuring our Docs project’s success",
        "slug": "measuring-our-docs-projects-success",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Timeline",
        "slug": "timeline",
        "lvl": 3,
        "i": 7,
        "seen": 0
      },
      {
        "content": "Project budget",
        "slug": "project-budget",
        "lvl": 3,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Get started contributing to AsyncAPI Docs Today",
        "slug": "get-started-contributing-to-asyncapi-docs-today",
        "lvl": 2,
        "i": 9,
        "seen": 0
      },
      {
        "content": "Tag me in your AsyncAPI Doc PRs",
        "slug": "tag-me-in-your-asyncapi-doc-prs",
        "lvl": 3,
        "i": 10,
        "seen": 0
      }
    ],
    "slug": "/blog/google-season-of-docs-2022",
    "filePath": "pages/blog/google-season-of-docs-2022.md"
  },
  {
    "meta": {
      "title": "Radical Transparency",
      "date": "2022-02-02T23:00:00.000Z",
      "type": "Community",
      "tags": [
        "Transparency",
        "Open",
        "Governance"
      ],
      "cover": "/img/posts/radical-transparency.webp",
      "authors": [
        {
          "name": "Fran Méndez",
          "photo": "/img/avatars/fmvilas.webp",
          "link": "https://twitter.com/fmvilas",
          "byline": "Executive Director at AsyncAPI Initiative"
        }
      ],
      "excerpt": "There are multiple ways to manage an open-source project. At AsyncAPI, we chose the Open Governance model for many good reasons that Lukasz explained in his article Finding a Good Open Governance Mode",
      "featured": true,
      "readingTime": 4
    },
    "content": "\nThere are multiple ways to manage an open-source project. At AsyncAPI, we chose the Open Governance model for many good reasons that Lukasz explained in his article [Finding a Good Open Governance Model for AsyncAPI](/blog/governance-motivation).\n\nHowever, there's more than _\"just\"_ doing Open Governance. **If something can't easily be found, then it's not really transparent and, therefore, not truly open.** We not only chose Open Governance but _Radical Transparency_.\n\n## What is Radical Transparency?\n\n> **radical**\n> /ˈradɪk(ə)l/\n>\n> (especially of change or action) relating to or affecting the fundamental nature of something; far-reaching or thorough. **Forming an inherent or fundamental part of the nature of someone or something.**\n\n> **transparency**\n> /tranˈsparənsi,trɑːnˈsparənsi/\n>\n> (of an organization or its activities) the condition of being **open to public scrutiny**.\n\nRadical transparency is about doing every single thing in public. It's about empowering the community with the necessary tools and information to scrutinize everything we do.\n\n## What does it mean for me as the Executive Director?\n\nBelieve it or not, it's relieving. Most people —including myself in the past— would have been scared of letting so much power go and opt for radical transparency.\n\nI often get a lot of pressure from different companies to do something for them. Here are some examples:\n\n* Invite someone to the TSC in exchange for a [Platinum Sponsorship](https://opencollective.com/asyncapi/contribute/platinum-sponsors-8119).\n* Exchange logos on our websites. Oh my! It just happened as I'm writing these lines :joy:\n* Donate some money only if they get \"something\" in return. These people don't get open-source, do they? :smile:\n\nSo Radical Transparency is actually making things easier for me. I just have to say something like this:\n\n> I'm sorry, but I can't do what you're suggesting. If you're still interested in a similar deal, please head over to https://www.github.com/asyncapi/community and open an issue with your proposal. We can happily discuss it there.\n\nAll of a sudden, it's not just my responsibility. It's [the TSC](https://www.asyncapi.com/community/tsc) who gets to decide if their proposal moves forward or doesn't. This makes the TSC (including myself) accountable for the decision. And most important, it's all registered and accessible to anyone in the community to scrutinize.\n\nRadical Transparency is removing all these trouble-makers for me. Whoever is truly interested in making an honest proposal, will also suggest it publicly. This system allows me to get rid of those whose interest is not making the project better and are only seeking profit. And, so far, these people stand for 100% of the cases.\n\nOf course, I'm still happy to take private calls and emails when they make sense. E.g. they contain sensitive information, you don't speak English, you're shy to propose things in public, they're not related to AsyncAPI, etc.\n\n## What does it mean for the community?\n\nWhether you are a user, a contributor, or a code owner, everyone must make decisions in public. For code, we use pull requests. Use issues or discussions on the related repo when it's something else. And, if there's no related repo, use [the community one](https://www.github.com/asyncapi/community).  \n\nWhatever we do, needs to have its associated public record. That doesn't mean we don't do video calls to discuss complex topics. We actually encourage them when the writing form is not enough or too difficult. We never take decisions on meetings because that would be leaving many people out. E.g., those in other time zones, having other meetings at the same time, those on holidays or sick, etc. In any case, whatever is discussed in the meetings should be reflected in its correspondent issue or discussion on Github.\n\nOf course, the \"downside\" of this is that the whole process becomes slower and more bureaucratic, but I don't think it's really a downside but a feature. By doing this, we make sure to behave as a community, as a group, as a huge team. And you don't want to leave any teammate out, right? It's a matter of respect, after all.\n\n## Challenge us!\n\nThat said, we're always looking for ways to improve. We're already radically transparent, but I'm sure we can improve some things. So here's a challenge for you, find something we're not doing transparently enough and let us know. Or, even better, join us to improve it!\n\nThanks for reading!\n\n_(Cover picture by [Anh Tuan To](https://unsplash.com/@tuan1561?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/transparency?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText))_\n",
    "toc": [
      {
        "content": "What is Radical Transparency?",
        "slug": "what-is-radical-transparency",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "What does it mean for me as the Executive Director?",
        "slug": "what-does-it-mean-for-me-as-the-executive-director",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "What does it mean for the community?",
        "slug": "what-does-it-mean-for-the-community",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Challenge us!",
        "slug": "challenge-us",
        "lvl": 2,
        "i": 3,
        "seen": 0
      }
    ],
    "slug": "/blog/radical-transparency",
    "filePath": "pages/blog/radical-transparency.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Spec 3.0 is coming!",
      "date": "2022-03-10T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Specification",
        "Announcement",
        "Release"
      ],
      "cover": "/img/posts/async-api-spec3.0-release/cover.webp",
      "authors": [
        {
          "name": "Harsh Mishra",
          "photo": "/img/avatars/harsh.webp",
          "link": "https://www.linkedin.com/in/harshcasper/"
        }
      ],
      "excerpt": "Announcing the start of work on AsyncAPI Spec 3.0. Check out all the potential new features coming to AsyncAPI 3.0 and how you can get involved!",
      "featured": false,
      "readingTime": 3
    },
    "content": "\nAsyncAPI is a specification for describing your event-driven architecture. Our specification allows you to describe and document your message-driven APIs into a human-readable format. The AsyncAPI community is currently inching towards a 3.0 release that will bring together multiple features, enhancements, and breaking changes. We follow [release cadence](https://github.com/asyncapi/spec/blob/master/RELEASE_PROCESS.md#release-cadence) and we will continue to release the Spec to the community as we continue to build on it.\n\n## Potential Changes\n\nMany new features for AsyncAPI Spec 3.0 are being planned, written, and discussed. Among them are:\n\n-   [Introduce Schema Versioning](https://github.com/asyncapi/spec/issues/697)\n-   [Introducing Data Format bindings](https://github.com/asyncapi/spec/issues/694)\n-   [Making servers aware of their service name](https://github.com/asyncapi/spec/issues/654)\n-   [Solving publish/subscribe confusion](https://github.com/asyncapi/spec/issues/618) \n-   [What does an AsyncAPI file mean](https://github.com/asyncapi/spec/issues/628)\n-   [Fixing schema inconsistencies](https://github.com/asyncapi/spec/issues/583)\n-   [Defining a schema format other than the default one](https://github.com/asyncapi/spec/issues/622)\n-   [Remove `$ref` field from `Channel Item Object`](https://github.com/asyncapi/spec/issues/699) \n-   [Application of message traits (intentionally) replacing existing attributes](https://github.com/asyncapi/spec/issues/505)\n-   [Address perspective and channel reuse issues through introducing 'endpoint' concept](https://github.com/asyncapi/spec/issues/599)\n\nThe tooling issues and pull requests which are tied up with the Spec 3.0 release are:\n\n-   [Implement intent-driven Parser API](https://github.com/asyncapi/parser-js/issues/401)\n-   [Splitting out definitions into separate files](https://github.com/asyncapi/spec-json-schemas/issues/127)\n-   [Move binding JSON schema files to main JSON schema repository](https://github.com/asyncapi/bindings/issues/113)\n\nWe are using [this GitHub milestone](https://github.com/asyncapi/spec/milestone/18) to track down all the issues related to Spec 3.0 release. If you are willing to take up an issue, filter the issues with `needs champion` label and drive the initiative forward. We also have a [release journal](https://github.com/asyncapi/community/issues/163) for the upcoming Spec 3.0 release to keep note of all the references, build the right documentation, and track the progress for the upcoming release.\n\n## Contributing to the release\n\nAsyncAPI is a community-driven project and we welcome all kinds of contributions! To get started, join our [Slack workspace](http://asyncapi.com/slack-invite). After joining, reach out to us on the `#03_specification` channel and participate in the conversations.\n\nTo better understand AsyncAPI and how the Spec 3.0 release will play out, we recommend watching our [past meeting recordings](https://www.youtube.com/watch?v=CLNgLB4-UnA&list=PLbi1gRlP7pihClJY-kXuTRRJ8n1awb0VV). To know how you can contribute, we recommend checking out our [contributing guidelines](https://github.com/asyncapi/spec/blob/master/CONTRIBUTING.md). If you wish to keep track of all the work that is happening on the Spec 3.0 release, we recommend checking out our [GitHub issue](https://github.com/asyncapi/spec/issues/691).\n\nBefore landing in your contributions, make sure you follow our [Code of Conduct](https://github.com/asyncapi/.github/blob/master/CODE_OF_CONDUCT.md) and the pull request you raised is [described properly](https://github.com/asyncapi/.github/blob/master/CONTRIBUTING.md#conventional-commits). To know how we collaborate using Git & GitHub, follow the [Git workflow](https://github.com/asyncapi/.github/blob/master/git-workflow.md) that we have developed for contributors.\n\n## When will the release happen?\n\nWe are yet to arrive at a date but the community is working towards releasing this by the end of 2022. Currently, we meet every two weeks to discuss the upcoming Spec 3.0 release and share updates and you are welcome to join it! We are going to have our next meeting on [UTC 16:00 on March 16, 2022](https://github.com/asyncapi/community/issues/270). You can access the [AsyncAPI Calendar](https://calendar.google.com/calendar/u/0/embed?src=tbrbfq4de5bcngt8okvev4lstk@group.calendar.google.com) and explore our upcoming meetings.\n\nThe release will happen gradually, where the new specification and tooling will live in coexistence until there is a collective consensus that everything is ready. This gives everyone an easy way to test out the new changes and provide feedback before the release. Finally, after rigorous testing, we will make an official announcement about our release!\n\nJoin us and help make the upcoming release a successful one!\n\n(Cover picture by [Andrew Coelho](https://unsplash.com/@andrewcoelho) on [Unsplash](https://unsplash.com/))\n",
    "toc": [
      {
        "content": "Potential Changes",
        "slug": "potential-changes",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Contributing to the release",
        "slug": "contributing-to-the-release",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "When will the release happen?",
        "slug": "when-will-the-release-happen",
        "lvl": 2,
        "i": 2,
        "seen": 0
      }
    ],
    "slug": "/blog/async-api-spec-3.0-release",
    "filePath": "pages/blog/async-api-spec-3.0-release.md"
  },
  {
    "meta": {
      "title": "AsyncAPI at OpenForce",
      "date": "2022-03-01T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Open Source",
        "Contribute"
      ],
      "cover": "/img/posts/openforce-2022/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "readingTime": 3,
      "excerpt": "Two years ago, the AsyncAPI Initiative participated in Hacktoberfest to help folks start their journey in open source. Hacktoberfest was a very successful event. We got feedback that the level of comm"
    },
    "content": "\nTwo years ago, the AsyncAPI Initiative participated in Hacktoberfest to help folks start their journey in open source. Hacktoberfest was a very successful event. We got feedback that the level of commitment that we presented makes us perfect candidates for Google Summer of Code. \n\nLast year, we participated in Google Summer of Code and again in Hacktoberfest. It went great! We onboarded many new, super enthusiastic contributors that stayed with us longer. \n\nThis year won't be different. We want to do it again and yet again, on a larger scale. Thus, active participation in initiatives focused on introducing new folks into open source became [one of our main goals for 2022](https://github.com/asyncapi/community/discussions/193).\n\nThanks to one of our contributors, [Hargun Kaur](https://www.linkedin.com/in/hkaur008/), we learned about [OpenForce](https://www.openforce.tech/) and decided to join it in March 2022.\n\n## What we offer\n\nAsyncAPI maintainers prepared some GitHub issues that are easy enough to be completed in one month. We offer full support in discussing possible solutions and on-time review in pull requests.\n\nThe AsyncAPI community is a safe place for your first open source contribution. Many folks are open to supporting your first steps in this great world.\n\nIn exchange, every person that completes these tasks will get an AsyncAPI t-shirt!\n\n## How to connect\n\nJoin [our Slack workspace](https://www.asyncapi.com/slack-invite). Just make sure to follow our [Slack etiquette](https://github.com/asyncapi/.github/blob/master/slack-etiquette.md) and [the code of conduct](https://github.com/asyncapi/.github/blob/master/CODE_OF_CONDUCT.md).\n\nWe will also have [Abir Pal](https://twitter.com/imabptweets) present in the OpenForce Discord channel, in case you need help on your way to AsyncAPI.\n\n## List of issues you can work on [TODO]\n\n### CI/CD\n\n- [Workflow that updates every PR with clear info about conventional commits](https://github.com/asyncapi/.github/issues/70)\n- [Readme links check](https://github.com/asyncapi/.github/issues/92)\n- [CI on PR's should build the Docker image](https://github.com/asyncapi/server-api/issues/50)\n\n### K8S/Helm\n\n- [Automate Helm chart release version bump](https://github.com/asyncapi/event-gateway/issues/86)\n- [Create better Kubernetes liveness, readiness and startup Probes](https://github.com/asyncapi/event-gateway/issues/77)\n- [Add livenessProbe and readinessProbe to K8s Deployment](https://github.com/asyncapi/server-api/issues/57)\n\n### TypeScript\n\n- [Add asyncapi bundle command in AsyncAPI CLI](https://github.com/asyncapi/cli/issues/219)\n- [Add asyncapi optimize command in AsyncAPI CLI](https://github.com/asyncapi/cli/issues/218)\n- [Remove usage of Parser, validation and update docs from AsyncAPI bundler](https://github.com/asyncapi/bundler/issues/26)\n- [Add support for Markdown output in AsyncAPI Diff](https://github.com/asyncapi/diff/issues/84)\n- [Add support for HTML output in AsyncAPI Diff](https://github.com/asyncapi/diff/issues/85)\n- [Add implementation for /bundle path](https://github.com/asyncapi/server-api/issues/55)\n- [Add implementation for /diff path](https://github.com/asyncapi/server-api/issues/56)\n- [Serve openapi.yaml file as documentation page](https://github.com/asyncapi/server-api/issues/43)\n- [Enable validation of an example payload](https://github.com/asyncapi/studio/issues/200)\n- [Show how to integrate Modelina in an AsyncAPI generator template](https://github.com/asyncapi/modelina/issues/641)\n- [Show how to integrate Modelina in a website](https://github.com/asyncapi/modelina/issues/642)\n- [Add support for WebSocket clients](https://github.com/asyncapi/glee/issues/259) \n\n### JavaScript\n\n- [Switch for rendering whole channels by template parameter](https://github.com/asyncapi/markdown-template/issues/194)\n- [Create eslint plugin for organization repositories](https://github.com/asyncapi/community/issues/238)\n\n### Go\n\n- [Support Kafka](https://github.com/asyncapi/go-watermill-template/issues/126) - Also includes JavaScript work.\n- [Create Avro schema parser](https://github.com/asyncapi/parser-go/issues/51)\n\n### Others\n\n- [Define a better API that can be used by other applications](https://github.com/asyncapi/event-gateway/issues/47)\n- [Idea: Using EventGateway Websocket with Grafana](https://github.com/asyncapi/event-gateway/issues/60)\n\n\n> Photo by <a href=\"https://www.openforce.tech/\">OpenForce</a>\n",
    "toc": [
      {
        "content": "What we offer",
        "slug": "what-we-offer",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "How to connect",
        "slug": "how-to-connect",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "List of issues you can work on [TODO]",
        "slug": "list-of-issues-you-can-work-on-todo",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "CI/CD",
        "slug": "cicd",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "K8S/Helm",
        "slug": "k8shelm",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "TypeScript",
        "slug": "typescript",
        "lvl": 3,
        "i": 5,
        "seen": 0
      },
      {
        "content": "JavaScript",
        "slug": "javascript",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Go",
        "slug": "go",
        "lvl": 3,
        "i": 7,
        "seen": 0
      },
      {
        "content": "Others",
        "slug": "others",
        "lvl": 3,
        "i": 8,
        "seen": 0
      }
    ],
    "slug": "/blog/openforce-2022",
    "filePath": "pages/blog/openforce-2022.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Initiative 2021 in Numbers",
      "date": "2022-02-07T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/2021-summary/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Dev Comm Keeper"
        }
      ],
      "excerpt": "AsyncAPI Initiative growth presented in different metrics from different channels in 2021.",
      "readingTime": 13
    },
    "content": "\nThis article is a continuation of a tradition where once a year, we summarize all the metrics that we can collect from our different tools to see how we are growing as a community.\n\nIt is good to see how we are doing, how are we growing :rocket:\n\nIf you are interested in previous years, look at [this 2020 summary article](2020-summary).\n\n## Slack\n\nWe noted 1846 members at the end of 2021:\n\n<table>\n  <tr>\n    <td align=\"center\">\n    </td>\n    <td align=\"center\">\n      2020\n    </td>\n    <td align=\"center\">\n      2021\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      New members\n    </td>\n    <td align=\"center\">\n      490\n    </td>\n    <td align=\"center\">\n      877<br/>\n      (79% increase)\n    </td>\n  </tr>\n</table>\n\nIn 2021 we also went through reorganization of the channels setup, created etiquette, and most importantly, got a standard subscription from Slack. We definitely are not going away from Slack.\n\n### Weekly active members\n\nSlack is our primary community channel, a kind of direct connection between community members. In my opinion, it indicates the community's growth that is more active in the initiative. \n\nFor this year, I removed the stats about the number of posted messages. We have many messages posted by bots (about GitHub activity, for example) affecting the numbers. They are big but do not indicate only Slack activity.\n\nData is shown weekly and not daily, so the numbers are not affected by usually silent weekends.\n\n<table>\n  <tr>\n    <td align=\"center\">\n    </td>\n    <td align=\"center\">\n      2020\n    </td>\n    <td align=\"center\">\n      2021\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Active members weekly\n    </td>\n    <td align=\"center\">\n      81 average<br/>\n      77 median\n    </td>\n    <td align=\"center\">\n      174 average<br/>\n      (114% increase)<br/>\n      173 median<br/>\n      (125% increase)\n    </td>\n  </tr>\n    <tr>\n    <td align=\"center\">\n      Active members posting messages weekly\n    </td>\n    <td align=\"center\">\n      20 average<br/>\n      19 median\n    </td>\n    <td align=\"center\">\n      40 average<br/>\n      (100% increase)<br/>\n      41 median<br/>\n      (116% increase)\n    </td>\n  </tr>\n</table>\n\nI think the median is accurate not only because it shows higher numbers. It basically eliminates super high weeks (like when we organized conferences) and weeks when we have lots of holidays simultaneously, like Christmas break.\n\n## LinkedIn\n\n[LinkedIn](https://www.linkedin.com/company/asyncapi/) grows like other channels. We mostly attract folks with job functions related to engineering (51%). Other are also tech but related to business development or product management.\n\nI personally wish we actually reach more product managers (PM) than 2%. As a person that was a PM in the past, I remember how much specs and APIs were important for products and hope other PMs go that path too.\n\n### Followers and impressions\n\nAt the moment, we have 1534 followers. Unfortunately, LinkedIn memory is short and remembers only numbers one year back. I do not have access to January 2021 data. \n\nIn the case of a percentage increase, I take only numbers related to organic growth.\n\n<table>\n  <tr>\n    <td align=\"center\">\n    </td>\n    <td align=\"center\">\n      2020\n    </td>\n    <td align=\"center\">\n      2021\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Followers\n    </td>\n    <td align=\"center\">\n       611<br/>\n       57 from payed marketing\n    </td>\n    <td align=\"center\">\n       745<br/>\n       (34% increase)\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Impressions\n    </td>\n    <td align=\"center\">\n       80 095\n    </td>\n    <td align=\"center\">\n       248 571<br/>\n       146 252 from payed marketing<br/>\n       (28% increase)\n    </td>\n  </tr>\n</table>\n\nWe published 265 posts on LinkedIn, and with a growing number of followers, it converted into many users visiting our [website](http://asyncapi.com/).\n\n<table>\n  <tr>\n    <td align=\"center\">\n    </td>\n    <td align=\"center\">\n      2020\n    </td>\n    <td align=\"center\">\n      2021\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Users\n    </td>\n    <td align=\"center\">\n       715\n    </td>\n    <td align=\"center\">\n       1 857<br/>\n       (160% increase)\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      New Users\n    </td>\n    <td align=\"center\">\n       656\n    </td>\n    <td align=\"center\">\n       1 699<br/>\n       (159% increase)\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Sessions\n    </td>\n    <td align=\"center\">\n       1 042\n    </td>\n    <td align=\"center\">\n       2 511<br/>\n       (141% increase)\n    </td>\n  </tr>\n</table>\n\n### Sponsored marketing\n\nWe spent $1200 on paid marketing on LinkedIn to increase awareness about AsyncAPI Hackathon and Conference. We noticed a large increase in impressions on our sponsored posts. These sponsored posts did not link to our AsyncAPI website but to the conference registration site. To summarize, $1200 converted into 763 visits to the registration website and ... wait for it ... wait for it ... 15 registrations. I have to tell you that 2021 taught me that there is nothing better than organic marketing. Better pay $1200 to contributors for their work rather than give it out to LinkedIn.\n\nI recommend everyone to maintain a relationship with the community also on LinkedIn. This social media is changing. Many folks that are not active on Twitter are active on LinkedIn, and you should target them. In the end, reposting stuff you have for Twitter to LinkedIn is not very time-consuming.\n\nIn Q4 of 2021, we also started streaming different meetings to LinkedIn. In three months, we noted 1180 views of our streaming content. So we basically enabled over 1k users to watch the content they would probably not watch if LinkedIn was their only social media channel. Think about it, omnichannel is the only way to build the community,\n\n## Google Analytics\n\nWe use Google Analytics on [AsyncAPI website](https://www.asyncapi.com/) because we want to understand what content is most valuable for you, and we want to learn how the interest is growing. \n\n### Traffic got much higher\n\nThe interest is growing by a lot! Our website handles it well with the support of [Netlify](https://www.netlify.com), which is free for open-source projects.\n\n<table>\n  <tr>\n    <td align=\"center\">\n    </td>\n    <td align=\"center\">\n      2019\n    </td>\n    <td align=\"center\">\n      2020\n    </td>\n    <td align=\"center\">\n      2021\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Users visits\n    </td>\n    <td align=\"center\">\n      27 090\n    </td>\n    <td align=\"center\">\n      83 655<br/>\n      (208% increase)\n    </td>\n    <td align=\"center\">\n      131 802<br/>\n      (57% increase)\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Sessions\n    </td>\n    <td align=\"center\">\n      50 405\n    </td>\n    <td align=\"center\">\n      147 409<br/>\n      (192% increase)\n    </td>\n    <td align=\"center\">\n      235 321<br/>\n      (60% increase)\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Pageviews\n    </td>\n    <td align=\"center\">\n      143 059\n    </td>\n    <td align=\"center\">\n      362 686<br/>\n      (153% increase)\n    </td>\n    <td align=\"center\">\n      590 501<br/>\n      (63% increase)\n    </td>\n  </tr>\n</table>\n\n### Top blog posts\n\n[AsyncAPI blog](/blog) is a place where the AsyncAPI Community can publish articles. Anyone can share knowledge, experience, and showcase their work there. Just [let us know what you want to write about](https://github.com/asyncapi/website/issues/new?template=blog.md).\n\nWhat is the benefit of writing/republishing on the AsyncAPI blog? Visibility among the AsyncAPI community plus our activities to make your work go viral. Just look at the below table to see our top 3 viral posts.\n\n<table>\n  <tr>\n    <td align=\"center\">\n      Post\n    </td>\n    <td align=\"center\">\n      Unique pageviews\n    </td>\n    <td align=\"center\">\n      Author\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n    <Link href=\"/blog/openapi-vs-asyncapi-burning-questions\" passHref>\n      <a>\n      AsyncAPI vs OpenAPI: Answers to Your Burning Questions About Two Leading API Specs\n      </a></Link> (September 2021)\n    </td>\n    <td align=\"center\">\n      8 107\n    </td>\n    <td align=\"center\">\n      <a href=\"https://www.linkedin.com/in/jmenning/\">\n      Jesse Menning\n      </a>\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n    <Link href=\"/blog/understanding-asyncapis\" passHref>\n      <a>\n      Understanding AsyncAPIs with a Practical Example\n      </a></Link> (March 2021)\n    </td>\n    <td align=\"center\">\n      6 161\n    </td>\n    <td align=\"center\">\n      <a href=\"https://twitter.com/dunithd\">\n      Dunith Dhanushka\n      </a>\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n    <Link href=\"/blog/websocket-part2\" passHref>\n      <a>\n      Creating AsyncAPI for WebSocket API - Step by Step\n      </a></Link> (April 2021)\n    </td>\n    <td align=\"center\">\n      5 049\n    </td>\n    <td align=\"center\">\n      <a href=\"https://twitter.com/derberq\">\n      Lukasz Gornicki\n      </a>\n    </td>\n  </tr>\n</table>\n\n### Google Search Console\n\nIn 2021 we integrated our Google Analytics with Google Search Console (GSC). I believe that numbers from GSC can show how many more people hear about AsyncAPI and gain interest in the topic. In other words, the assumption is that the more people google, the more people are aware of AsyncAPI.\n\nThe last data we have access to is from the 20th of September 2020. So we cannot fully compare 2020 and 2021. We know we had 1 230 000 (OVER ONE MILLION) impressions and 104 000 clicks in 2021 in total, but in the table below we only compare data between the 20th of September and the 31st of December.\n\n<table>\n  <tr>\n    <td align=\"center\">\n    </td>\n    <td align=\"center\">\n      2020\n    </td>\n    <td align=\"center\">\n      2021\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://support.google.com/webmasters/answer/7042828#click\">\n        Total clicks\n      </a>\n    </td>\n    <td align=\"center\">\n       19 200\n    </td>\n    <td align=\"center\">\n       34 400<br/>\n       (79% increase)\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://support.google.com/webmasters/answer/7042828#impressions\">\n        Total impressions\n      </a>\n    </td>\n    <td align=\"center\">\n       300 000\n    </td>\n    <td align=\"center\">\n       350 000<br/>\n       (17% increase)\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n       Impressions conversion into clicks\n    </td>\n    <td align=\"center\">\n       6.4% average\n    </td>\n    <td align=\"center\">\n       9.8% average\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n        Position in search results\n    </td>\n    <td align=\"center\">\n       31.3 average\n    </td>\n    <td align=\"center\">\n       29.7 average\n    </td>\n  </tr>\n</table>\n\nWe can compare only three months, so numbers for 2022 will definitely be better than 2021.\n\nWe did some [super basic SEO improvements](https://github.com/asyncapi/website/pull/255) in mid 2021, which sure took effect on increased click rate. We also published a few articles with topics that people google for together with `asyncapi`, WebSocket, and OpenAPI.\n\nI think we have proof that all additional activities planned for 2022, such as rework of existing documentation, should improve numbers even more.\n\nIf you have more ideas on improving, just open up an issue in [the website repository](https://github.com/asyncapi/website/), and let's discuss how we can get better.\n\n## Twitter\n\nBy the time I gathered data for this blog post, we had 2997 followers on Twitter. 1 564 increase since the last time we had published such metrics in mid-December 2020. It is **78% more followers in a year compared to 2020**.\n\nI'm not gonna hide, I'm not a Twitter fan, really. :smiley:\nWho cares about my preferences, though, our community is present there, and we must too. In the end, Twitter led 2 478 new users to AsyncAPI website.\n\nWhat I can tell you for sure. Do not spend your money on Twitter marketing. We tried it for AsyncAPI Conference. Of course, I might configure something in a bad way, but does it change anything? We spent $560.21 on sponsored tweets that converted into 16 471 visits to the conference registration page. Guess what, **0 folks registered**. \n\nNow yes, of course, might be that tweets were not targetted properly, might be that registration page was not attractive. But I challenge you with a question: is it worth spending many extra hours and money on this classical marketing instead of the community?\n\n## GitHub\n\nWe notice growing traffic in [our GitHub organization](https://github.com/asyncapi) like on other channels.\n\n### Most popular repositories\n\nOur most popular repositories contain the AsyncAPI specification and the AsyncAPI Generator that the community can use to generate documentation and code.\n\n[The AsyncAPI Specification repository](https://github.com/asyncapi/spec/) that had 1 357 stars in 2020 jumped to 1 870. \n\n[The AsyncAPI Generator repository](https://github.com/asyncapi/generator/) grew from 198 to 417. So the number of fans doubled. \n\nThe number of contributors also increased, but the problem is I no longer have access to tools that can help me get exact numbers, like the ones I got last year.\n\nThe good news is that we should get access to Linux Foundation Insights tool around April. It will enable us to look deep into not only GitHub stats in one place. We will definitely get more accurate numbers for 2022.\n\n## npm\n\nThe majority of our tools are written in JavaScript/TypeScript, and we host them on Node Package Manager (npm).\n\n### Top packages\n\nOur most important packages are [the project that provides AsyncAPI JSON Schema files](https://www.npmjs.com/package/@asyncapi/specs), [the Generator](https://www.npmjs.com/package/@asyncapi/generator) and [the Parser](https://www.npmjs.com/package/@asyncapi/parser). Below you can see how downloads of these packages increased.\n\n<table>\n  <tr>\n    <td align=\"center\">\n    </td>\n    <td align=\"center\">\n      2019\n    </td>\n    <td align=\"center\">\n      2020\n    </td>\n    <td align=\"center\">\n      2021\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Generator\n    </td>\n    <td align=\"center\">\n      21 536\n    </td>\n    <td align=\"center\">\n      136 994\n    </td>\n    <td align=\"center\">\n      396 766\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Parser\n    </td>\n    <td align=\"center\">\n      18 591\n    </td>\n    <td align=\"center\">\n      187 475\n    </td>\n    <td align=\"center\">\n      1 460 275\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Module with JSON Schema files for specification<br/>\n      (new `@asyncapi/specs` & old `asyncapi`)\n    </td>\n    <td align=\"center\">\n      79 527\n    </td>\n    <td align=\"center\">\n      215 016\n    </td>\n    <td align=\"center\">\n      1 483 839!\n    </td>\n  </tr>\n</table>\n\nThe increase in numbers is insanely huge. People automatically say that it is because of build systems, local development, or some single corporation started using it at scale. In other words, the increase could result from just one project that uses these tools as a dependency.\n\nLet me challenge you:\n- Corporations always use mirrored versions in npm. When you work on a project in a corporate network, you will always hit internal proxy. Not included in downloads.\n- Most build systems cache packages that are downloaded already to improve performance. Not included in downloads.\nWhen you work with npm locally, you also have a local cache that is used if you want to install something that you already installed. Not included in downloads.\n\nAn interesting observation is that Generator uses Parser and Parser uses the package with AsyncAPI specs. So you can read from this data that packages with specs are primarily used in the AsyncAPI Parser. You can also see that Parser is a backbone for many more projects than just the AsyncAPI Generator.\n\nDo you see it? Last year Generator and Parser download numbers were super close to each other, now the difference is much higher, 1 MILLION!\n\n## YouTube\n\nThe [AsyncAPI YouTube channel](https://www.youtube.com/asyncapi) had a massive increase in traffic. \n\n### Watch time\n\nYouTube is the only channel where numbers were not higher than in previous years. The main reason is that in 2020, our conference took place in March, while in 2021, it was November. We only released like 1/5 of all presentations. Let's see if I'm right. Numbers in 2022 should get up.\n\n<table>\n  <tr>\n    <td align=\"center\">\n    </td>\n    <td align=\"center\">\n      2019\n    </td>\n    <td align=\"center\">\n      2020\n    </td>\n    <td align=\"center\">\n      2021\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Views\n    </td>\n    <td align=\"center\">\n      527\n    </td>\n    <td align=\"center\">\n      8 830\n    </td>\n    <td align=\"center\">\n      10 444\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Watch time\n    </td>\n    <td align=\"center\">\n      29.9h\n    </td>\n    <td align=\"center\">\n      1 900h\n    </td>\n    <td align=\"center\">\n      1 672.9h\n    </td>\n  </tr>\n    <tr>\n    <td align=\"center\">\n      Subscribers\n    </td>\n    <td align=\"center\">\n      35\n    </td>\n    <td align=\"center\">\n      396\n    </td>\n    <td align=\"center\">\n      292\n    </td>\n  </tr>\n</table>\n\n## Open Collective\n\nWe earned and spent lots of money this year. :money_mouth_face:\n\nHuge applause :clap: to all [our sponsors](https://opencollective.com/asyncapi#section-contributors)! \n\n<table>\n  <tr>\n    <td align=\"center\">\n      Source\n    </td>\n    <td align=\"center\">\n      Expenses\n    </td>\n    <td align=\"center\">\n      Balance\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://opencollective.com/asyncapi/events/asyncapi-hackathon-and-conference-2021-3156d7af\">\n        AsyncAPI Hackathon & Conference\n      </a>\n    </td>\n    <td align=\"left\">\n      $1,200.51 LinkedIn marketing<br/>\n      $563.00 Twitter marketing<br/>\n      $2,200.53 Daily.dev marketing (converted into 22 registrations out of 369 visits)<br/>\n      $11,023.92 Hackathon prizes<br/>\n      $1,972.31 Swags for Hackathon participants and Conference presenters<br/>\n    </td>\n    <td align=\"center\">\n      $8,146.63\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://opencollective.com/asyncapi\">\n        AsyncAPI Initiative\n      </a>\n    </td>\n    <td align=\"center\">\n      $15,093.31 Marketing and Maintainance<br/>\n      $3,000.00 Donation to <a href=\"https://opencollective.com/json-schema\">\n        JSON Schema\n      </a> \n    </td>\n    <td>\n      $56 252.68\n    </td>\n  </tr>\n</table>\n\nWe also have a good amount of money thanks to the new Platinum sponsor that joined last year, IBM. Also, RedHat joined as a Gold sponsor. We also had other donations.\n\n## Final words\n\nWe grow. Numbers just confirm our observation. We grow not only because people love to build a community around the specification. We grow because AsyncAPI Initiative is attractive for contributors because we also host tools related to AsyncAPI.\n\nIf you want to look at more data, some of it is available [in this spreadsheet](https://docs.google.com/spreadsheets/d/1KxEkX9BqtJ4WIkh-NMftq5pDTcBStV_pHqa6P6-7bfM/edit?usp=sharing) and for others you just need to contact me directly. \n\nIn 2022, we need to establish a stronger bond with the community. We have many folks that give back a lot of time into the project, and it is time to give back. The main goals we have:\n- Meet in person for AsyncAPI Conference\n- Setup Ambassador program to give back to most active community members\n- Get involved in more events like Google Summer of Code\n\nJoin us so we can work on these together!\n\n> Photo by <a href=\"https://unsplash.com/@alternateskate?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Alternate Skate</a> on <a href=\"https://unsplash.com/s/photos/accelerate-speed?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "Slack",
        "slug": "slack",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Weekly active members",
        "slug": "weekly-active-members",
        "lvl": 3,
        "i": 1,
        "seen": 0
      },
      {
        "content": "LinkedIn",
        "slug": "linkedin",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Followers and impressions",
        "slug": "followers-and-impressions",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Sponsored marketing",
        "slug": "sponsored-marketing",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Google Analytics",
        "slug": "google-analytics",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Traffic got much higher",
        "slug": "traffic-got-much-higher",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Top blog posts",
        "slug": "top-blog-posts",
        "lvl": 3,
        "i": 7,
        "seen": 0
      },
      {
        "content": "Google Search Console",
        "slug": "google-search-console",
        "lvl": 3,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Twitter",
        "slug": "twitter",
        "lvl": 2,
        "i": 9,
        "seen": 0
      },
      {
        "content": "GitHub",
        "slug": "github",
        "lvl": 2,
        "i": 10,
        "seen": 0
      },
      {
        "content": "Most popular repositories",
        "slug": "most-popular-repositories",
        "lvl": 3,
        "i": 11,
        "seen": 0
      },
      {
        "content": "npm",
        "slug": "npm",
        "lvl": 2,
        "i": 12,
        "seen": 0
      },
      {
        "content": "Top packages",
        "slug": "top-packages",
        "lvl": 3,
        "i": 13,
        "seen": 0
      },
      {
        "content": "YouTube",
        "slug": "youtube",
        "lvl": 2,
        "i": 14,
        "seen": 0
      },
      {
        "content": "Watch time",
        "slug": "watch-time",
        "lvl": 3,
        "i": 15,
        "seen": 0
      },
      {
        "content": "Open Collective",
        "slug": "open-collective",
        "lvl": 2,
        "i": 16,
        "seen": 0
      },
      {
        "content": "Final words",
        "slug": "final-words",
        "lvl": 2,
        "i": 17,
        "seen": 0
      }
    ],
    "slug": "/blog/2021-summary",
    "filePath": "pages/blog/2021-summary.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Spec 2.3.0 Release Notes",
      "date": "2022-02-01T18:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Specification",
        "Release Notes"
      ],
      "cover": "/img/posts/release-notes-2.3.0/cover.webp",
      "authors": [
        {
          "name": "Dale Lane",
          "photo": "/img/avatars/dalelane.webp",
          "link": "https://twitter.com/dalelane"
        }
      ],
      "excerpt": "AsyncAPI 2.3 is now released. This brings enhancements allowing new ways of structuring AsyncAPI documents and support for describing Solace APIs.",
      "readingTime": 3
    },
    "content": "\nThe new version of the AsyncAPI specification - 2.3.0 - is now available.\n\n> This is a minor release, and it doesn't bring any breaking changes. You can switch to it by modifying the following value in your AsyncAPI file `asyncapi: '2.2.0'` into `asyncapi: '2.3.0'`\n\n\n## Servers and channels can now be defined as reusable components\n\nTo allow for more flexibility in how AsyncAPI documents are structured and enable content to be reused, `servers` and `channels` can now be defined as reusable components.\n\nFor example:\n\n```yaml\nasyncapi: 2.3.0\nservers:\n  production:\n    $ref: '#/components/servers/myserver'\nchannels:\n  some/events:\n    $ref: '#/components/channels/myChannel'\ncomponents:\n  servers:\n    myserver:\n      url: \"http://localhost:5000/ws\"\n      protocol: ws\n  channels:\n    myChannel:\n      description: \"mychannel\"\n```\n\nThese are added to the many other aspects of the AsyncAPI specification which can be declared as reusable components. You can see the full list in the [Components Object section of the AsyncAPI specification](https://www.asyncapi.com/docs/specifications/v2.3.0#componentsObject).\n\nThis new feature was contributed by [Sergio Moya](https://www.linkedin.com/in/smoya). For more detail, see this [pull request](https://github.com/asyncapi/spec/pull/665) and the [Github issue where this change was discussed](https://github.com/asyncapi/spec/issues/660).\n\n\n## New protocol bindings\n\nThe specification is now extended to support another custom protocol through the bindings feature:\n\nSolace, thanks to [Michael Davis](https://github.com/damaru-inc).\nFor more details, check out this [pull request](https://github.com/asyncapi/spec/pull/666) and [binding definition](https://github.com/asyncapi/bindings/tree/master/solace).\n\n\n## Other enhancements\n\nRegular expressions are now Unicode-compliant. This enhancement to the specification from [Sergio Moya](https://www.linkedin.com/in/smoya) means that regular expressions (found in `pattern` and `patternProperties` fields) are now Unicode-compliant (according to ECMA-262).\n\nThis improves compatibility with some JSON Schema parsers. For more details, check out the [pull request](https://github.com/asyncapi/spec-json-schemas/pull/145).\n\n\n## Deprecations\n\nThe `$ref` field in [Channel Item Object](#https://www.asyncapi.com/docs/specifications/v2.3.0#channelItemObject) is now deprecated from AsyncAPI 2.3.0.\n\nThe current plan is that the `$ref` field will be removed from **Channel Item Object** in AsyncAPI 3.0, and replaced with [Reference Object](https://www.asyncapi.com/docs/specifications/v2.3.0#referenceObject).\n\nFor more detail, you can see the [discussion about this issue in Github](https://github.com/asyncapi/spec/issues/607).\n\n\n## Tooling support\n\nThe following official AsyncAPI tools are already updated to support 2.3.0 version of the specification:\n- JSON Schema that supports validation of AsyncAPI documents is updated in [this](https://github.com/asyncapi/asyncapi-node) repository. Also **@asyncapi/specs** package has been updated on NPM to version 2.13.0, and it contains the 2.3.0 JSON Schema.\n- [JavaScript Parser](https://github.com/asyncapi/parser-js/) uses latest **@asyncapi/specs** package and can be used to parse and validate 2.3.0 documents. Upgrade to 1.14.0 version.\n- [HTML template](https://github.com/asyncapi/html-template) uses the latest **@asyncapi/react-component** package. Upgrade to 0.24.7 version.\n- [JavaScript Converter](https://github.com/asyncapi/converter-js/) enables conversion from any AsyncAPI version into the 2.3.0 version of the spec. Upgrade to 0.7.0 version.\n- [Modelina](https://github.com/asyncapi/modelina/) now also accepts AsyncAPI documents valid against the 2.3.0 version of the spec. Upgrade to 1.46.0 version.\n - [Generator](https://github.com/asyncapi/generator/) uses the latest @asyncapi/parser package, so while generating output, it can validate 2.1.0 documents. Upgrade to 1.9.0 version.\nLast but not least is the AsyncAPI Studio. Check new studio with [this example](https://studio.asyncapi.com/?url=https://raw.githubusercontent.com/asyncapi/spec/v2.3.0/examples/websocket-gemini.yml).\n\nBig thanks to [Maciej Urbanczyk](https://github.com/magicmatatjahu) and [Jonas Lagoni](https://github.com/jonaslagoni/) for updating most relevant tooling.\n\n\n## Look ahead\n\nWe aim to have a regular cadence of releases of the AsyncAPI specification, four times a year. For more information about when to expect future releases, you can see our [release process document](https://github.com/asyncapi/spec/blob/master/RELEASE_PROCESS.md#release-cadence).\n\nWe're also working on the next major release of the AsyncAPI specification: 3.0.0. If you'd like to contribute, or just follow the discussions, you can see the [milestone on Github](https://github.com/asyncapi/spec/milestone/18).\n\n\n> Photo by <a href=\"https://unsplash.com/@aridley88?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Andrew Ridley</a> on <a href=\"https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "Servers and channels can now be defined as reusable components",
        "slug": "servers-and-channels-can-now-be-defined-as-reusable-components",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "New protocol bindings",
        "slug": "new-protocol-bindings",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Other enhancements",
        "slug": "other-enhancements",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Deprecations",
        "slug": "deprecations",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Tooling support",
        "slug": "tooling-support",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Look ahead",
        "slug": "look-ahead",
        "lvl": 2,
        "i": 5,
        "seen": 0
      }
    ],
    "slug": "/blog/release-notes-2.3.0",
    "filePath": "pages/blog/release-notes-2.3.0.md"
  },
  {
    "meta": {
      "title": "AsyncAPI and Apicurio for Asynchronous APIs",
      "date": "2022-01-26T05:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "Schemas",
        "Schema-Registry",
        "Kafka",
        "Avro",
        "Apicurio"
      ],
      "cover": "/img/posts/asyncapi-and-apicurio-for-asynchronous-apis/apicurio_registry.webp",
      "authors": [
        {
          "name": "Nadja Hagen",
          "photo": "/img/avatars/nadjahagen.webp",
          "link": "https://twitter.com/hg_nadja",
          "byline": "Jr. Consultant at Novatec Consulting"
        }
      ],
      "readingTime": 11,
      "excerpt": "This post originally appeared on https://novatec-gmbh.de\n\nThe OpenAPI specification has already established itself in many project and application areas. It can be applied to describe HTTP APIs in a s"
    },
    "content": "\n> This post originally appeared on [https://novatec-gmbh.de](https://www.novatec-gmbh.de/en/blog/asyncapi-and-apicurio-for-asynchronous-apis/)\n\nThe [OpenAPI](https://www.openapis.org/) specification has already established itself in many project and application areas. It can be applied to describe HTTP APIs in a standardized way, understandable for humans and computers. While OpenAPI is mainly intended for synchronous interfaces, asynchronous communication places new demands on the interface definition.  \nAsynchronous architectures can build on different types of protocols, e.g., Kafka, AMQP, or MQTT. Additionally, communication often includes a messaging broker, which maintains several topics or channels. Another difference is the communication style: OpenAPI only allows specifying one-to-one connection links. In contrast to that, asynchronous communication often involves multiple communication partners. Therefore, common patterns like publish/subscribe require a new approach to defining APIs.  \n[AsyncAPI](https://www.asyncapi.com/) was developed as an extension of OpenAPI to meet these new requirements of asynchronous communication and interfaces. [This article](https://www.asyncapi.com/blog/openapi-vs-asyncapi-burning-questions) highlights the differences between OpenAPI and AsyncAPI in more detail.\n\nAs another aspect, large projects usually include multiple teams working and developing together. Therefore, standardized development of APIs is a central aspect of cross-team application development. At the same time, the API definitions need to be available and easy to access for all teams. These demands are also addressed by [Apicurio Registry](https://www.apicur.io/registry/). It supports registering different document formats, e.g., OpenAPI, AsyncAPI, GraphQL, Apache Avro, or Protobuf.\n\nSince AsyncAPI is developing quite fast, we want to have a look at what the specification and corresponding tools currently cover. Additionally, we will shortly examine how Apicurio and AsyncAPI can work together at the moment. Nevertheless, there are many new tools and features for AsyncAPI on the roadmap. For this reason, this article can only be a snapshot. So stay tuned until the end of this post to get an outlook on what is next to come.\n\nElements of an AsyncAPI Document\n================================\n\nComing to the basics of AsyncAPI: How does an AsyncAPI definition look? AsyncAPI allows using YAML or JSON for document definition. A document consists of the following elements:\n\n<p align=\"center\">\n  <img src=\"/img/posts/asyncapi-and-apicurio-for-asynchronous-apis/asyncapi.webp\" alt=\"Elements of an AsyncAPI document\"/>\n</p>\n\nIn practice, the definition can become quite long. Consider the below example from AsyncAPI’s Github to get an impression of how such a definition can look:\n\n    asyncapi: '2.2.0'\n    info:\n      title: Streetlights Kafka API\n      version: '1.0.0'\n      description: |\n        The Smartylighting Streetlights API allows you to remotely manage the city lights.\n      license:\n        name: Apache 2.0\n        url: https://www.apache.org/licenses/LICENSE-2.0\n\n    servers:\n      test:\n        url: test.mykafkacluster.org:8092\n        protocol: kafka-secure\n        description: Test broker\n        security:\n          - saslScram: []\n\n    defaultContentType: application/json\n\n    channels:\n      smartylighting.streetlights.1.0.event.{streetlightId}.lighting.measured:\n        description: The topic on which measured values may be produced and consumed.\n        parameters:\n          streetlightId:\n            $ref: '#/components/parameters/streetlightId'\n        publish:\n          summary: Inform about environmental lighting conditions of a particular streetlight.\n          operationId: receiveLightMeasurement\n          message:\n            $ref: '#/components/messages/lightMeasured'\n\n    components:\n      messages:\n        lightMeasured:\n          name: lightMeasured\n          title: Light measured\n          summary: Inform about environmental lighting conditions of a particular streetlight.\n          contentType: application/json\n          payload:\n            $ref: \"#/components/schemas/lightMeasuredPayload\"\n\n      schemas:\n        lightMeasuredPayload:\n          type: object\n          properties:\n            lumens:\n              type: integer\n              minimum: 0\n              description: Light intensity measured in lumens.\n            sentAt:\n              $ref: \"#/components/schemas/sentAt\"\n        sentAt:\n          type: string\n          format: date-time\n          description: Date and time when the message was sent.\n\n      securitySchemes:\n        saslScram:\n          type: scramSha256\n          description: Provide your username and password for SASL/SCRAM authentication\n\n      parameters:\n        streetlightId:\n          description: The ID of the streetlight.\n          schema:\n            type: string\n\nIf you want to look at it in a more readable way, you can copy and paste the definition to the [AsyncAPI Studio](https://studio.asyncapi.com/) or the [AsyncAPI playground](https://playground.asyncapi.io)(*Remark*: AsyncAPI Playground will soon be archived and replaced by AsyncAPI Studio). More examples are available on [Github](https://github.com/asyncapi/spec/tree/master/examples).\n\nI do not want to dive too deep into the exact details of the specification because the [documentation](https://www.asyncapi.com/docs/specifications/v2.2.0) is already helpful enough for this. But I want to highlight some parts of the specification that could be the icing on the cake when considering it.\n\nBesides some general information about the API, like the title and the description, the \"Info\" object can contain a [\"Contact\" object](https://www.asyncapi.com/docs/specifications/v2.2.0#contactObject). Especially when thinking about multiple groups working together, the responsible team and how to reach them can be linked at this place. In the example from above, this would look like this:\n\n    asyncapi: '2.2.0'\n    info:\n      title: Streetlights Kafka API\n      version: '1.0.0'\n      description: |\n        The Smartylighting Streetlights API allows you to remotely manage the city lights.\n      contact:\n        name: API Support\n        url: https://www.asyncapi.org/support\n        email: support@asyncapi.org\n      license:\n    ...\n\nThe fixed structure defined by the specification might not be sufficient for all use cases. Therefore, it is possible to link external documentation for nearly every object in the AsyncAPI definition. Additionally, user-defined properties can be set to [extend the specification](https://www.asyncapi.com/docs/specifications/v2.2.0#specificationExtensions). This can be done by simply prepending an \"x-\" at the field name. For example, we could add the internal team or project name:\n\n    ...\n      contact:\n        name: API Support\n        url: https://www.asyncapi.org/support\n        email: support@asyncapi.org\n        x-project-name: Future-Light-X10\n        x-team-name: Kafka Streetlights Team\n    ...\n\nFor long and detailed API definitions, the document can become messy fast. As an improvement for this, it is possible to include references to internal and external resources (using the $ref field). They enable us to reuse objects, add schemas and add definitions from external sources.  \nAs another use case, let’s assume there are already event-driven applications using an Avro schema for their messages. For example, the schema is registered at Confluent Schema Registry or Apicurio Registry. Using $ref, it is possible to reference this Avro schema within a message object in the AsyncAPI definition:\n\n    ...\n    messages:\n        lightMeasured:\n          name: lightMeasured\n          title: Light measured\n          summary: Inform about environmental lighting conditions of a particular streetlight.\n          contentType: avro/binary\n          schemaFormat: application/vnd.apache.avro+json;version=1.9.0\n          payload:\n            $ref: 'http://schema-registry:8081/subjects/topic/versions/1/#LightMeasuredPayload'\n    ...\n\nAsyncAPI also offers an [Avro schema parser](https://github.com/asyncapi/avro-schema-parser) which collects local Avro references or remote files from Confluent Schema Registry and inserts them into the definition.\n\nKafka, AMQP, MQTT or HTTP: Protocol-Specific Properties\n=======================================================\n\nAs already mentioned at the beginning of this post, asynchronous communication can involve different types of protocols. As this is a fundamental aspect of your API definitions, AsyncAPI supports adding protocol-specific properties.  \nThese protocol-specific properties can be necessary on different levels: server level, channel level, operation level, and message level. For these levels, AsyncAPI allows defining protocol-specific objects, so-called bindings. This [repository](https://github.com/asyncapi/bindings) provides a complete list of all bindings and their specification details.  \nFor example, it is possible to add a key for Kafka messages:\n\n    ...\n    channels:\n      smartylighting.streetlights.1.0.event.{streetlightId}.lighting.measured:\n        description: The topic on which measured values may be produced and consumed.\n        parameters:\n          streetlightId:\n            $ref: '#/components/parameters/streetlightId'\n        publish:\n          summary: Inform about environmental lighting conditions of a particular streetlight.\n          operationId: receiveLightMeasurement\n          message:\n            bindings:\n              kafka:\n                key:\n                  type: string\n                  enum: ['Germany', 'Austria', 'Switzerland']\n                bindingVersion: '0.1.0'\n            $ref: '#/components/messages/lightMeasured'\n    ...\n\nUnfortunately, for many protocols, there are a lot of binding objects which are not specified yet. E.g., for Kafka, there are no specifications for the Server and Channel Binding objects. In the case of Kafka, relevant but missing properties could be the number of partitions or the delivery guarantee. These properties would be a good use case for [specification extensions](https://www.asyncapi.com/docs/specifications/v2.2.0#specificationExtensions) that [currently cannot be used in binding objects](https://github.com/asyncapi/bindings/issues/83#issuecomment-925965378).  \nIn addition, some [conventions](https://github.com/asyncapi/bindings/pull/75) for the specification of bindings are on the roadmap. As protocol-specific bindings are still in the alpha version, this feature will become mature with continuous development.\n\nAsyncAPI and Apicurio: A Match?\n===============================\n\nIn contrast to the [Confluent Schema Registry](https://docs.confluent.io/platform/current/schema-registry/index.html), Apicurio is not limited to [message schemas but also supports API specifications](https://www.apicur.io/registry/docs/apicurio-registry/2.1.x/getting-started/assembly-intro-to-the-registry.html). Apicurio could therefore also replace the Confluent Schema Registry.  \nHowever, this is probably only true if the architecture does not mainly base on a Confluent ecosystem. But depending on the use case, Apicurio can be a helpful addition to the Schema Registry due to the additionally supported formats.\n\nApicurio Registry allows registering AsyncAPI definitions, which can then be searched and browsed. At the moment, unfortunately, AsyncAPI documents are not rendered to make them more readable. External references (like in the example above) are currently not resolved automatically either. Orientation for this could be the [AsyncAPI playground](https://playground.asyncapi.io/), where this is already possible. However, Apicurio Studio already offers this functionality for OpenAPI, and support for AsyncAPI in Apicurio Studio [is already planned](https://github.com/Apicurio/apicurio-registry/issues/865).\n\nAt the same time, Apicurio also offers the [Data Models Library](https://github.com/Apicurio/apicurio-data-models), which allows reading, writing, and modifying AsyncAPI and OpenAPI documents. The [Dereferencer-class](https://github.com/Apicurio/apicurio-data-models/blob/master/src/main/java/io/apicurio/datamodels/openapi/visitors/dereference/Dereferencer.java) resolves external references to other documents and inserts them into the definition. It is also possible to add your implementations of the [IReferenceResolver](https://github.com/Apicurio/apicurio-data-models/blob/master/src/main/java/io/apicurio/datamodels/core/util/IReferenceResolver.java) interface for custom resolution of references.  \nWhen testing the library, I noticed that it cannot resolve all references in a document yet: The AsyncAPI specification also allows references in the payload object of a message (as shown in the example above). The library only checks objects for links that also implement the [IReferenceNode](https://github.com/Apicurio/apicurio-data-models/blob/master/src/main/java/io/apicurio/datamodels/core/models/IReferenceNode.java) interface. However, the [payload object](https://github.com/Apicurio/apicurio-data-models/blob/master/src/main/java/io/apicurio/datamodels/asyncapi/models/AaiMessage.java) does not yet implement this interface, and therefore, references in this object remain unresolved.  \nThere already is a [Github issue](https://github.com/Apicurio/apicurio-data-models/issues/327) which will hopefully resolve this soon.\n\nFor Avro schemas, Apicurio Registry supports schema validation and a compatibility check. However, this seems to be still missing for AsyncAPI, even when the user interface suggests the opposite (see screenshot below). I tested this feature with syntactically invalid AsyncAPI definitions (which were classified as invalid by AsyncAPI playground), which were not recognized as wrong by Apicurio Registry. Also, definition updates, including breaking changes, were not recognized as so. Nevertheless, this [Github issue](https://github.com/Apicurio/apicurio-registry/issues/16) suggests that support is planned.\n\n![Screenshot of the details overview for artifacts in Apicurio](/img/posts/asyncapi-and-apicurio-for-asynchronous-apis/apicurio_registry_details.webp)\n\nThe Data Models Library of Apicurio and Apicurio Registry gives a first idea of what can be done with AsyncAPI. Nevertheless, the functionalities and use cases are still limited. When I tested the Data Models Library, I hoped for more features that could be used at runtime. In fact, it is currently cumbersome to extract message schemas from the AsyncAPI definition. Therefore, I would not recommend the library for this use case.  \nHowever, one possibility would be to use Confluent Schema Registry or Apicurio Registry for Avro schemas. Messages could be serialized and deserialized with the schemas from there. The AsyncAPI definition can then reference these schemas. In addition, Apicurio Registry can be used as an API catalog. Developers could then use this catalog to work on new services or to mock applications.\n\nBesides these aspects, you should consider that Apicurio has little to no competition. At least I could not find another established open-source registry on the market that supports both schemas and APIs and so many formats. Feel free to leave a comment if you know more about this!\n\nAs an alternative, it is also possible to build your own AsyncAPI catalog to support missing features. E.g., you could use existing AsyncAPI libraries and modules like the [AsyncAPI React component](https://github.com/asyncapi/asyncapi-react) to render definitions. If you want to know how this could look, have a look at [this repository](https://github.com/NovatecConsulting/tc-asyncapi-directory#2-preview) where I implemented this myself. In this prototype, I used the React component with Angular. In case you feel more comfortable with other frameworks, it is also possible to integrate it in Vue or NextJS.\n\nIf you want to test how Apicurio works, check out this small [quick start guide](https://github.com/NovatecConsulting/tc-apicurio-quickstart). It starts an Apicurio container and deploys some AsyncAPI example files.\n\nThe Roadmap: What is Next to Come\n=================================\n\nIf you take a closer look at the [Github repositories](https://github.com/asyncapi) of AsyncAPI, you will quickly notice that a lot is happening here right now. There are many exciting and promising ideas, and the community seems to grow steadily. For example, an [event gateway](https://github.com/asyncapi/event-gateway) is currently being developed that will make it possible to validate and modify messages even before they arrive at the broker. Another idea is the [Glee framework](https://github.com/asyncapi/glee), which ensures that AsyncAPI definition and code match. At first glance, an unexpected project is the [AsyncAPI Chatbot](https://github.com/asyncapi/chatbot). It helps to create an AsyncAPI document without having to know the specification yourself.\n\nBesides these innovative ideas, there are also tools to enable validation and compatibility checks. The [CLI](https://github.com/asyncapi/cli) tool validates AsyncAPI files. Also, the [Diff](https://github.com/asyncapi/diff) tool points out breaking changes to ensure backward compatibility. A combination of these projects would be helpful, as it is already requested on [Github](https://github.com/asyncapi/cli/issues/58). These two tools could also be integrated into Apicurio Registry to add missing features.\n\nThe AsyncAPI website also lists tools [developed by the community](https://www.asyncapi.com/docs/community/tooling). Many of these and several tools by the core team mainly support JavaScript - so ideally, you should not have a problem with that. Nevertheless, it is to be hoped that other programming languages will be supported in the future. This would make it easier for the community to access them.  \nMany other official projects of the AsyncAPI team are still in the alpha or beta phase. Therefore, most of them cannot yet be used to their full potential. But since companies like eBay and Slack already use AsyncAPI, we can expect a lot more to come.\n\nIf you want to dive a bit deeper, I recommend having a look at the recording of the AsyncAPI conference in November 2021. There were many interesting talks on how AsyncAPI can be used in projects and with other tools. For more details on how to use schemas, schema registries, and API registries with AsyncAPI, listen to my conference talk below.\n\n<YouTube id=\"37X4Hbu0bSQ\" />\n",
    "toc": [
      {
        "content": "Elements of an AsyncAPI Document",
        "slug": "elements-of-an-asyncapi-document",
        "lvl": 1,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Kafka, AMQP, MQTT or HTTP: Protocol-Specific Properties",
        "slug": "kafka-amqp-mqtt-or-http-protocol-specific-properties",
        "lvl": 1,
        "i": 1,
        "seen": 0
      },
      {
        "content": "AsyncAPI and Apicurio: A Match?",
        "slug": "asyncapi-and-apicurio-a-match",
        "lvl": 1,
        "i": 2,
        "seen": 0
      },
      {
        "content": "The Roadmap: What is Next to Come",
        "slug": "the-roadmap-what-is-next-to-come",
        "lvl": 1,
        "i": 3,
        "seen": 0
      }
    ],
    "slug": "/blog/asyncapi-and-apicurio-for-asynchronous-apis",
    "filePath": "pages/blog/asyncapi-and-apicurio-for-asynchronous-apis.md"
  },
  {
    "meta": {
      "title": "2nd half of 2021 at AsyncAPI",
      "date": "2021-12-21T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/july-december-2021-at-asyncapi/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "excerpt": "It has been a while since the last update on the things at AsyncAPI Initiative. Lots of things have happened since June. You better have a read or listen to the podcast.",
      "readingTime": 8
    },
    "content": "\n<iframe src=\"https://anchor.fm/asyncapi/embed/episodes/2nd-half-of-2021-at-AsyncAPI-Initiative-e1bvc3u\" height=\"102px\" width=\"600px\" scrolling=\"no\"></iframe>\n\nAround August, I communicated that because vacation is a dead season (in Poland we call it cucumber time) I will not do my monthly updates or write a single vacation summary.\n\nWell, the thing is that vacations were not as quiet as I expected. In September, a carousel started that was impossible to stop.\n\nI started writing status updates bi-weekly in early 2020. These were about simple improvements in specific libraries, very detailed on libraries release level. Back then, I basically knew every single new thing happening in the initiative. This year I switched to monthly updates as there was simply too much happening, and I could not really do those bi-weekly. I also started picking the most important news as there were too many things happening.\n\nI submit my official apologies to those awaiting my update-related articles. Honestly, looking at the size of the community and the growth that we are noticing, I don't know how I'll manage to publish these regularly in 2022. Maybe we should start writing those as a collective. \n\nWhat I can promise for sure is that in January 2022, I will write a summary article about AsyncAPI growth in 2021. \n\n## More regular live-streams\n\nWe started two live streams under the AsyncAPI brand:\n- **Thinking Out Loud** is hosted by AsyncAPI Founder (Fran Mendez). He invites different community members to talk about AsyncAPI specification. All recordings are available [in the official YouTube playlist](https://www.youtube.com/playlist?list=PLbi1gRlP7pigPxRRylHGCvpdppYLmSKfJ). Fran plans to continue doing them in 2022 as well.\n- **Contributor-first** is strictly targeted at new or existing contributors. Any AsyncAPI Technical Steering Committee member can volunteer as a host and talk about specific contribution-related topics. We aim to have it as frequently as possible, at least once a week. All recordings are available [in the official YouTube playlist](https://www.youtube.com/playlist?list=PLbi1gRlP7pigPBrBMaNQhUeniR1pdDMiY). Based on the community feedback, the live stream will be renamed to **Let's talk about contributing** in 2022.\n\nHosting these live streams is all possible thanks to the great support from the [Restream.io](https://restream.io/) folks who gave us free access to the tool that enables us to live stream directly to all our social media channels.\n\nAll official meetings are always listed in our:\n- [Community repository](https://github.com/asyncapi/community/labels/meeting)\n- [official Google Calendar](https://calendar.google.com/calendar/u/0/embed?src=tbrbfq4de5bcngt8okvev4lstk@group.calendar.google.com)\n\nThe best way to learn about a new event is to join [our official Google Group](https://groups.google.com/u/1/g/asyncapi-users) that we use as a mailing list for invites.\n\n## Solving publish/subscribe confusion aka possible AsyncAPI 3.0 release in 2022\n\nIt was hard to find someone in the community that was not confused by the semantics related to the **publish** and **subscribe** operations when learning about the AsyncAPI specification. Many people were asking in Slack. People were also opening pull requests to fix our documentation, assuming we mixed things up by accident.\n\nThere are cases where education is not enough. You can have great docs and education materials. Still, some stuff just needs to be improved and cannot be fixed by documentation.\n\nAt the beginning of my tech career, I learned a sentence from an experienced developer: \"documented bugs become features\". Sometimes you do not have a chance to learn from the best :sweat_smile:\n\nThis is causing too much confusion and needs to be solved in 2022. It is probably not possible without a breaking change in the specification. \n\nPlease join us and help us improve not only the specification but also update the tooling:\n- [Proposal to solve publish/subscribe confusion](https://github.com/asyncapi/spec/issues/618)\n- [The many meanings of an AsyncAPI file](https://github.com/asyncapi/spec/issues/628)\n\n## Google Summer of Code Summary\n\nWe closed holidays 2021 with massive success of the [Google Summer of Code](https://www.asyncapi.com/blog/march-2021-at-asyncapi#google-summer-of-code) participants. All participants not only finished their projects, but they also became members of AsyncAPI Technical Steering Committee and also got a chance to present their work at the 2021 AsyncAPI Conference.\n\n- [Aayush Sahu](https://www.linkedin.com/in/aayushmau5) created [Diff](https://github.com/asyncapi/diff)\n  <YouTube id=\"yILtksZriqA\" /> \n- [Khuda Dad Nomani](https://www.linkedin.com/in/khudadadnomani) created [Optimizer](https://github.com/asyncapi/optimizer)\n  <YouTube id=\"wHBfRheAero\" /> \n- [Arjun Garg](https://www.linkedin.com/in/arjungarg17) created [Cupid](https://github.com/asyncapi/cupid)\n  <YouTube id=\"V5H4pmz6yq8\" /> \n- [Elegbede Azeez Wahab aka Ace](https://www.twitter.com/_acebuild) created [Chatbot](https://github.com/asyncapi/chatbot)\n  <YouTube id=\"pxOrJl2c_DQ\" /> \n- [Nektarios Fifes](https://www.linkedin.com/in/nektarios-fifes-372740220) created [Simulator](https://github.com/asyncapi/simulator). He could not unfortunately join us at the AsyncAPI Conference to talk about his work, but I'm sure he will be open to answer any of your questions asked through GitHub Issues.\n\nIt was a pleasure to work with these folks and see them staying with us after GSoC ends. I, therefore [proposed we do it again in 2022 on a larger scale](https://github.com/asyncapi/community/discussions/193).\n\n## Technical Steering Committee members setup\n\nAfter joining the [Linux Foundation (LF)](https://www.asyncapi.com/blog/asyncapi-joins-linux-foundation) and applying the [open governance model](https://github.com/asyncapi/community/blob/master/CHARTER.md), it was time for us to start setting up a Technical Steering Committee (TSC). \n\nSo here we are, 9 months after joining LF, we already have 24 members. Check out the [complete list of all the TSC members](https://www.asyncapi.com/community/tsc). Pay attention to those that are marked as **Available for hire**. Don't let folks work for free. Pay them to work on open-source. Be good humans.\n\nDo you want to be on that list? Watch the following :point_down: presentation.\n\n<YouTube id=\"uG_aLF9Z1F0\" /> \n\nThere are many things still missing, such as a TSC list synchronization, voting process automation, and more. Other things still need a lot of work. If you want to contribute to the project and you are a fan of automation, this is the right topic to help with.\n\n## Welcome Studio and Goodbye Playground\n\nWe released a new application that you can use to work on your AsyncAPI files. \n\nBefore, you could use the [AsyncAPI Playground](https://playground.asyncapi.com/), but soon we'll start redirecting traffic to a new, beautiful :point_right: [AsyncAPI Studio](https://studio.asyncapi.com/) :point_left:\n\nThe new Studio has a bright future, and you should expect lots of new features coming there. I definitely recommend checking out [Studio's GitHub repository](https://github.com/asyncapi/studio/).\n\nThe cool stuff is that it is also integrated with the [AsyncAPI CLI](https://www.asyncapi.com/tools/cli):\n```bash\n#install CLI\nnpm install -g @asyncapi/cli\n#create new file using an example\nasyncapi new --file-name=asyncapi.yml --example=default-example.yaml --no-tty\n#start studio that picks up asyncapi.yml file from the context it runs in\nasyncapi start studio\n```\n\nRepository with [Playground source code](https://github.com/asyncapi/playground) will most probably be archived and moved to [organization with old archived projects](https://github.com/asyncapi-archived-repos). \n\n## Hackathon\n\nThis year, we hosted our first [AsyncAPI Hackathon](https://www.asyncapi.com/blog/hackathon-faq). Even though we did not have a dedicated marketing campaign, and even though AsyncAPI is not trivial and requires experience to build tools for it, we received 9 submissions.\n\n[Souvik De](https://www.linkedin.com/in/souvik-de-a2b941169) won first prize with [AsyncAPI Bundler](https://github.com/asyncapi/community/discussions/128). Check out Souvik talking about the AsyncAPI Bundler at AsyncAPI Conference.\n\n<YouTube id=\"j_KLiCRW3t0\" /> \n\nWe also had 2 folks that tied in 2nd place:\n- [Ace](https://www.twitter.com/_acebuild) submitted [AsyncAPI Blocks](https://github.com/asyncapi/community/discussions/149)\n- [Greg Meldrum](https://www.linkedin.com/in/greg-meldrum-8b15a03/) submitted [Event Discovery Agent](https://github.com/asyncapi/community/discussions/147)\n\nCongrats to all of you folks!\n\nCheck out [this discussion to get more details on the Hackathon voting process](https://github.com/asyncapi/community/discussions/165).\n\nP.S. During the Hackathon, we also had a lot of people engaging with us because of Hacktoberfest. We got [30 issues resolved and merged](https://docs.google.com/spreadsheets/d/17YYe-ZompcuUACfCGa8Pc3XunFfWRBrNllIBChJ0yWw/edit#gid=0).\n\n## Conference\n\nCOVID-19 is still here. Thus, we decided to host the 2021 AsyncAPI Conference this year only in online mode. It was a three-day event with lots of great content, and most importantly, with the 1st day dedicated to contributors only.\n\nThe conference was live-streamed. Full-day recordings were released immediately, and individual talk recordings will follow. All will be listed under the [dedicated Conference playlist](https://www.youtube.com/playlist?list=PLbi1gRlP7pijq9F5eYsJomWc7Zf6EYVTZ).\n\nCheck out the current sum of people that watched it during the conference and after as recordings:\n- Day 1:\n  - YouTube: 1119\n  - Twitch: 89 (during event only, later Twitch removes old videos)\n  - LinkedIn: 148\n  - Twitter: 692\n\n  Total: **2048**\n- Day 2:\n  - YouTube: 737 \n  - Twitch: 56 (during event only, later Twitch removes old videos)\n  - LinkedIn: 49\n  - Twitter: 283\n\n  Total: **1125**\n- Day 3:\n  - YouTube: 521\n  - Twitch: 26 (during event only, later Twitch removes old videos)\n  - LinkedIn: 29\n  - Twitter: 312\n\n  Total: **888**\n\nThese numbers are great if we compare them against a total of 600 registrations!\n\nPersonally, the best number that I discovered was when I started listing the names of all the people who helped during the hackathon and conference organization. I think 62 is now my favorite number :heart:\n\n<Figure\n  src=\"/img/posts/july-december-2021-at-asyncapi/conf_contrib.webp\"\n  caption=\"Picture showing names of all people that helped in event organization.\"\n  className=\"text-center\"\n/>\n\nWhat about 2022? People during the conference voted for a hybrid approach:\n\n<Figure\n  src=\"/img/posts/july-december-2021-at-asyncapi/asyncapi_conf.webp\"\n  caption=\"Picture showing that out of 25 voters, 18 (72%) voted for a hybrid conference that is both online and in-person.\"\n  className=\"text-center\"\n/>\n\nJoin [related discussion and help organize it](https://github.com/asyncapi/community/discussions/193).\n\n> Photo by <a href=\"https://unsplash.com/@goian?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Ian Schneider</a> on <a href=\"https://unsplash.com/s/photos/end-of-the-year-ahead?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n  \n",
    "toc": [
      {
        "content": "More regular live-streams",
        "slug": "more-regular-live-streams",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Solving publish/subscribe confusion aka possible AsyncAPI 3.0 release in 2022",
        "slug": "solving-publishsubscribe-confusion-aka-possible-asyncapi-30-release-in-2022",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Google Summer of Code Summary",
        "slug": "google-summer-of-code-summary",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Technical Steering Committee members setup",
        "slug": "technical-steering-committee-members-setup",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Welcome Studio and Goodbye Playground",
        "slug": "welcome-studio-and-goodbye-playground",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Hackathon",
        "slug": "hackathon",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Conference",
        "slug": "conference",
        "lvl": 2,
        "i": 6,
        "seen": 0
      }
    ],
    "slug": "/blog/july-december-2021-at-asyncapi",
    "filePath": "pages/blog/july-december-2021-at-asyncapi.md"
  },
  {
    "meta": {
      "title": "Change is coming to our AsyncAPI Developer Documentation",
      "date": "2021-12-13T05:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "Documentation",
        "Announcement"
      ],
      "cover": "/img/posts/changes-coming-docs/mind-map.webp",
      "authors": [
        {
          "name": "Alejandra Quetzalli",
          "photo": "/img/avatars/canela-ale.webp",
          "link": "https://www.linkedin.com/in/alejandra-quetzalli/",
          "byline": "AsyncAPI Dev Docs are getting a makeover!"
        }
      ],
      "excerpt": "Did you know that you can contribute Docs to AsyncAPI as well? Code isn't the only way to contribute to OSS; Dev Docs are a huge help that benefit the entire OSS ecosystem.",
      "readingTime": 7
    },
    "content": "\n## 🦄 Hola, soy Alejandra Quetzalli\n\n¡Hola! 😄\n\nAsyncAPI community, it's an absolute pleasure to meet you. My name is Alejandra. I was born and raised in México 🇲🇽, so my first language is Spanish.\n\nI’m a Senior Technical Writer 👩🏻‍💻 recently hired by [Postman](https://www.postman.com/alejandra-quetzalli) to focus solely on the Open-Source (OSS) [AsyncAPI initiative](https://www.asyncapi.com/) as primary owner for our AsyncAPI Dev Docs 📄 . \n\nI also recently [joined our initiative's Technical Steering Committee (TSC)](https://www.asyncapi.com/community/tsc)! The TSC is responsible for the oversight of the AsyncAPI Initiative, helping make decisions on a higher level, or when maintainers cannot find a consensus.\n\nBy the second day, I was already working on community Pull Requests (PRs) and getting to know more of our community members. This direct engagement with community feels amazing, because I really **_do_** want to help as much as I can. I'm excited to listen what our OSS community thinks needs to be documented first.\n\nBefore I tell you more details about upcoming changes to the Docs and how you can contribute to them, I also want to share more granular details about my work here within our OSS community.\n\n***\n\n### 👩🏻‍💻 What I do for AsyncAPI Docs\n- **Own the docs for the AsyncAPI feature set** — documenting this specific area of our Open Technologies function and driving all docs efforts around it.\n- **Plan documentation in conjunction with OSS community feedback** — working with open-source communities to learn about a feature from specifications and user research.\n- **Collaborate closely with Developer Relations to ensure docs, educational, and learning materials align with community needs:** this includes assisting with documentation, tutorials, and all education efforts within AsyncAPI.\n- **Conduct editorial reviews on community doc drafts**— providing constructive and kind feedback that helps colleagues to grow.\n- **Liaise with stakeholders** across the AsyncAPI Initiative to establish and address docs needs.\n- **Maintain [AsyncAPI Docs GitHub Discussions](https://github.com/asyncapi/community/discussions/categories/docs)**.\n \n***\n\n\n## 💄 AsyncAPI Docs are getting a makeover!\nNow that I've introduced myself, my role, and high-level goals, I wanted to tell you more about some of the cool stuff coming up for AsyncAPI Docs. Pretty big changes are coming to our Dev Docs; in fact, our first \"big\" item to tackle will be giving the Information Architecture (IA) a makeover!\n\n\n#### 😭 Why do we need to make so many changes?\nThe current docs and repo READMEs were(are) made with much care and love, but with growth comes change, and with change comes improvements! \n\nIn our case, we need to add...\n- **Conceptual docs** that explain our spec terminology in more detail that include **engineering diagrams**: people often learn visually! \n- **Many more tutorials**. _(i.e. Websocket tutorial)_\n- **CLI docs** under a **Reference** content bucket.\n- A **tools section**! Currently we have documentation for our tools in individual tools' GitHub repos, under a `/docs` directory. Those should still remain there and continue to be maintained, but they also need to be documented in our Docs in a less informal way than what you see in a `README`.\n- **Usecases** and **Troubleshooting Guides**, under a new _How-To_ section.\n\n\n#### 🪣 Agnostic Content Buckets, coming right up\nEngineering Documentation can and should be divided into _agnostic_ content buckets.\n\nCurrently, our documentation has the following content buckets:\n- Getting Started\n- Tutorials\n- Specification\n- Community\n\nIn upcoming months, the plan is to change it to the following content buckets instead:\n- Concepts\n- Tutorials\n- Reference\n- How-To \n- Tools\n\nWhy, you wonder? \n\nIt was important (and exciting!) to me to introduce best practices from the [Diátaxis Framework](https://diataxis.fr/) for our new content buckets.\n\n![Diátaxis framework](/img/posts/changes-coming-docs/diataxis.webp)\n> Photo from <a href=\"https://diataxis.fr/\">Diátaxis</a> on <a href=\"https://diataxis.fr/\">Diátaxis framework</a>\n\nThe Diátaxis engineering documentation system classifies content under 4 main _agnostic_ buckets. This approach for Information Architecture (IA) and User Flows in dev docs is currently upheld widely within the tech industry. _(i.e. One current live example is GatsbyJS, which also uses the Diátaxis system for their Dev Docs. If you want to see a longer list of companies using it, go over [here](https://diataxis.fr/adoption/).)_\n\n#### The Diátaxis 4-Part Classification System:\n- **concepts:** Defining concepts within a technology's features and capabilities.\n- **how-to:** Solve a problem or advanced use case by doing.\n- **tutorial:** Learn a beginner process or concept by doing.\n- **reference:** Learn how to set up your development environment, CLI, APIs, etc.\n\n\n#### 💁🏻‍♀️ How does the Diátaxis system apply to an actual technology?\nLet’s take a look at the following Mind Map.\n\n![Mind Map, displaying Diátaxis system applied to documenting AsyncAPI capabilities](/img/posts/changes-coming-docs/mind-map.webp)\n\nHere we see that the AsyncAPI _CLI_ and _Spec_ fall under the `Reference` bucket. The `Concepts` bucket details AsyncAPI's specification concepts and terms that deserve to be covered in more detail. But when it comes to understanding the difference between what fits under a `Tutorial` vs. a `How-To` bucket, it feels harder to understand.\n\nLet’s make the subtle difference between the audiences for `Tutorial` and `How-To` buckets clearer.\n\n***\n\n##### The Tutorial bucket\n\nThink of a Tutorial as something that you need to teach a user that is new to your technology.\n- A first-time AsyncAPI user.\n- A user who is new to APIs **AND** AsyncAPI.\n\n##### The How-To bucket\n\nThink of a How-To as the bucket to address problems and advanced scenarios that you already know your users will encounter. These problems tend to fall under unique usecases or advanced troubleshooting guides that a more active user would encounter.\n\n- How to generate documentation from an AsyncAPI file\n  - How to generate a standalone static website with documentation\n  - How to generate documentation in a component that you can embed in an existing website\n  - How to generate markdown\n  - How to generate PDFs\n- How to reuse schema definitions from an OpenAPI file with an AsyncAPI file\n\n- Organising your AsyncAPI files\n- Generating documentation from your AsyncAPI files\n- Describing WebSocket APIs with AsyncAPI\n***\n\n## 👉🏽 How to contribute to AsyncAPI Docs\nDid you know that you can contribute Docs to AsyncAPI as well? Code isn't the only way to contribute to OSS; Dev Docs are a **huge** help that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution. ❤️\n\n\nTo get started as a Docs contributor:\n1. Familiarize yourself with our [project's Contribution Guide](https://github.com/asyncapi/community/blob/master/CONTRIBUTING.md) and our [Code of Conduct](https://github.com/asyncapi/.github/blob/master/CODE_OF_CONDUCT.md).\n2. Head over to our Docs GH Board [here](https://github.com/orgs/asyncapi/projects/8).\n3. Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started. \n4. If there is no work done in that Docs issue yet, feel free to open a PR and get started!\n\n### 🏷 Tag me in your AsyncAPI Doc PRs\nDo you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear!\n\nTag me in your AsyncAPI Doc PRs or [GitHub Discussions](https://github.com/asyncapi/community/discussions/categories/docs) via my GitHub handle, [`/alequetzalli`](https://github.com/alequetzalli) 🐙.\n\n\n## 🙂 Talk to me\nI want and need to listen 👂🏽 to all of your perspectives and ideas. Please don't be shy to express to me what you think needs to be documented first or what is missing. 📝\n\nThere's a lot of good work ahead, but **you** determine _our content roadmap_ because the OSS community needs should always come first.✨\n",
    "toc": [
      {
        "content": "🦄 Hola, soy Alejandra Quetzalli",
        "slug": "🦄-hola-soy-alejandra-quetzalli",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "👩🏻‍💻 What I do for AsyncAPI Docs",
        "slug": "👩🏻‍💻-what-i-do-for-asyncapi-docs",
        "lvl": 3,
        "i": 1,
        "seen": 0
      },
      {
        "content": "💄 AsyncAPI Docs are getting a makeover!",
        "slug": "💄-asyncapi-docs-are-getting-a-makeover",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "😭 Why do we need to make so many changes?",
        "slug": "😭-why-do-we-need-to-make-so-many-changes",
        "lvl": 4,
        "i": 3,
        "seen": 0
      },
      {
        "content": "🪣 Agnostic Content Buckets, coming right up",
        "slug": "🪣-agnostic-content-buckets-coming-right-up",
        "lvl": 4,
        "i": 4,
        "seen": 0
      },
      {
        "content": "The Diátaxis 4-Part Classification System:",
        "slug": "the-diataxis-4-part-classification-system",
        "lvl": 4,
        "i": 5,
        "seen": 0
      },
      {
        "content": "💁🏻‍♀️ How does the Diátaxis system apply to an actual technology?",
        "slug": "💁🏻‍♀️-how-does-the-diataxis-system-apply-to-an-actual-technology",
        "lvl": 4,
        "i": 6,
        "seen": 0
      },
      {
        "content": "The Tutorial bucket",
        "slug": "the-tutorial-bucket",
        "lvl": 5,
        "i": 7,
        "seen": 0
      },
      {
        "content": "The How-To bucket",
        "slug": "the-how-to-bucket",
        "lvl": 5,
        "i": 8,
        "seen": 0
      },
      {
        "content": "👉🏽 How to contribute to AsyncAPI Docs",
        "slug": "👉🏽-how-to-contribute-to-asyncapi-docs",
        "lvl": 2,
        "i": 9,
        "seen": 0
      },
      {
        "content": "🏷 Tag me in your AsyncAPI Doc PRs",
        "slug": "🏷-tag-me-in-your-asyncapi-doc-prs",
        "lvl": 3,
        "i": 10,
        "seen": 0
      },
      {
        "content": "🙂 Talk to me",
        "slug": "🙂-talk-to-me",
        "lvl": 2,
        "i": 11,
        "seen": 0
      }
    ],
    "slug": "/blog/changes-coming-docs",
    "filePath": "pages/blog/changes-coming-docs.md"
  },
  {
    "meta": {
      "type": "Engineering",
      "cover": "/img/posts/asyncapi-discovery-intro/asyncapi-discovery-tool-header.webp",
      "title": "Align Production Reality and Event Documentation with the AsyncAPI Discovery Tool",
      "date": "2021-12-07T05:00:00.000Z",
      "tags": [
        "Discovery",
        "Specification",
        "EDA",
        "Kafka",
        "Solace",
        "RabbitMQ",
        "NATS"
      ],
      "authors": [
        {
          "name": "Jesse Menning",
          "photo": "/img/avatars/jmenning.webp",
          "link": "https://linkedin.com/in/jmenning",
          "byline": "CTO Architect at Solace"
        }
      ],
      "readingTime": 4,
      "excerpt": "The idealized world of AsyncAPI is neat and tidy:\nInterface definitions show developers exactly what events are exchanged amongst producers and consumers.\nEvent contracts only change when permitted by"
    },
    "content": "\nThe idealized world of AsyncAPI is neat and tidy:\n\n- Interface definitions show developers exactly what events are exchanged amongst producers and consumers.\n- Event contracts only change when permitted by well-defined governance processes.\n- Bindings fill in the implementation details for open-source brokers like Kafka (including Confluent) and RabbitMQ along with closed-source brokers like IBM MQ and Solace.\n\nThe real world is often messier. \n\n> This post [Align Production Reality and Event Documentation with the AsyncAPI Discovery Tool](https://solace.com/blog/asyncapi-discovery-tool/) appeared first on [Solace](https://solace.com).\n\nIn the decades-long absence of an asynchronous API spec, teams adopted (or didn’t adopt, or chose to ignore) different API definitions and governance. The result is a twisted mess of event producers, consumers, data paths, and multiple broker technologies, from on-premises to cloud connections.\n\nOftentimes, removing an event topic or queue requires nerves of steel, for fear it might disrupt key functionality. Many a middleware engineer has found religion during a production broker clean-up.\n\nThankfully, the AsyncAPI Discovery Tool offers a better way.\n# How the AsyncAPI Discovery Tool Works\nThe AsyncAPI Discovery Tool analyzes event traffic passing through brokers like Kafka, RabbitMQ, IBM MQ, Solace, and more. After learning how the broker distributes events, the AsyncAPI Discovery Tool generates a corresponding [AsyncAPI specification](https://www.asyncapi.com/docs/specifications/latest). The generated spec can be used for code generation, documentation, visualization, infrastructure deployment, and more.\n\nIt’s a great starting point for getting events catalogued and governed.\n\nIt’s not perfect (more on that later), and there’s a lot more work to be done, but the AsyncAPI Discovery Tool helps your enterprise align production reality with AsyncAPI documentation. And perhaps relieve some tension for middleware engineers.\n\n# Getting Started with AsyncAPI Discovery Tool\nGetting started means a trip to the [SolaceLabs GitHub](https://github.com/SolaceLabs/event-discovery-agent), where you can find detailed instructions and documentation. (While Solace created the AsyncAPI Discovery Tool, it’s open-source with an Apache 2.0 license.)\n\nThe AsyncAPI Discovery Tool runs as a stand-alone Java Jar, so getting it running requires only Java and Maven. Once it’s up and running, AsyncAPI has its own self-contained UI, offering fill-in-the-blanks configuration. You can read more details about the UI ([here](https://github.com/SolaceLabs/event-discovery-agent/blob/main/docs/ui.md)). \n\nHere’s an example for Kafka:\n\n![Figure 1: UI for AsyncAPI Discovery for Kafka](/img/posts/asyncapi-discovery-intro/asyncapi-discovery-tool-1.webp)\n\nJust fill in the configuration, asking your friendly local administrator for help if needed, and then click the “Start Scan” button. After grinding away, the AsyncAPI Discovery Tool returns a consolidated spec file. The AsyncAPI file describes the channels and schemas of events passing through the broker. From there, the world is your oyster: generate code, create infrastructure, or start governing your events.\n\n![Figure 2: Resulting (greatly simplified) AsyncAPI spec](/img/posts/asyncapi-discovery-intro/asyncapi-discovery-tool-2.webp)\n\n\n# The Future of the AsyncAPI Discovery Tool\n\nThe most obvious place to improve the AsyncAPI Discovery Tool is to expand the number of supported brokers. Right now, it supports:\n\n- Apache Kafka\n- Solace PubSub+\n- NATS\n- RabbitMQ\n- HiveMQ\n\nFortunately, the tool was built with extensibility in mind. There is a documented plug-in architecture just itching to have more brokers added. If you’re interested, the people who maintain the tool welcome pull requests.\n\n- The confusing `publish` and `subscribe` verbs in the output.\n- The requirement that a single file must represent a single application makes it tough to get a high-level understanding of the architecture.\n\nAs the spec matures, the tooling will hopefully be close behind.\n\n# Conclusion\nIn the meantime, the AsyncAPI Discovery Tool can be a huge help to enterprises that are new to AsyncAPI but experienced with event-driven architecture and messaging. The AsyncAPI Discovery Tool can start you down the road from a tangled event mess to a well-organized, fully documented, tightly governed architecture.\n\nIf you have more questions or want to share your experience with these standards, you can let us know in the [AsyncAPI Slack](https://asyncapi.com/slack-inviteyou) or the [Solace Community Forum](http://solace.community/). \n",
    "toc": [
      {
        "content": "How the AsyncAPI Discovery Tool Works",
        "slug": "how-the-asyncapi-discovery-tool-works",
        "lvl": 1,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Getting Started with AsyncAPI Discovery Tool",
        "slug": "getting-started-with-asyncapi-discovery-tool",
        "lvl": 1,
        "i": 1,
        "seen": 0
      },
      {
        "content": "The Future of the AsyncAPI Discovery Tool",
        "slug": "the-future-of-the-asyncapi-discovery-tool",
        "lvl": 1,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Conclusion",
        "slug": "conclusion",
        "lvl": 1,
        "i": 3,
        "seen": 0
      }
    ],
    "slug": "/blog/asyncapi-discovery-intro",
    "filePath": "pages/blog/asyncapi-discovery-intro.md"
  },
  {
    "meta": {
      "title": "The Reference Rabbit Hole",
      "date": "2021-11-30T11:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "Specification",
        "JSON Schema"
      ],
      "cover": "/img/posts/the-reference-rabbit-hole.webp",
      "authors": [
        {
          "name": "Jonas Lagoni",
          "photo": "/img/avatars/jonaslagoni.webp",
          "link": "https://github.com/jonaslagoni",
          "byline": "AsyncAPI Maintainer"
        }
      ],
      "readingTime": 11,
      "excerpt": "Sergio and I went down a bit of a rabbit hole the last couple of days while discussing Fran&amp#39;s proposal to solve the publish/subscribe confusion; I thought I would share the journey. \nA lot of t"
    },
    "content": "\n[Sergio](https://github.com/smoya) and I went down a bit of a rabbit hole the last couple of days while discussing [Fran's proposal to solve the publish/subscribe confusion](https://github.com/asyncapi/spec/issues/618); I thought I would share the journey. \n\nA lot of this can be seen as nitpicking... And I totally get this, as we need to venture deep into the specifications to fully understand the differences.\n\nI'm going to try to not use any complex words and explanations so that everyone can understand the problems, whether you're a novice or an experienced AsyncAPI user. \n\nSo let's split up the understanding of what references are, where references can be used, and what's down this rabbit hole. \n\n# AsyncAPI references\n\nIn AsyncAPI, we have something called a [Reference Object](https://www.asyncapi.com/docs/specifications/v2.2.0#referenceObject), which simply enables reusability in your AsyncAPI documents. This is possible through the simple keyword `$ref`. If we take a look at the [streetlight tutorial](https://www.asyncapi.com/docs/tutorials/streetlights), to utilize reusability, we could change [the document](https://www.asyncapi.com/docs/tutorials/streetlights#creating-the-asyncapi-file) to:\n\n```yaml\nasyncapi: '2.2.0'\n...\nchannels:\n  light/measured:\n    publish:\n      summary: Inform about environmental lighting conditions for a particular streetlight.\n      operationId: onLightMeasured\n      message:\n        $ref: '#/components/messages/LightMeasured'\ncomponents:\n  messages:\n    LightMeasured: \n      name: LightMeasured\n      payload:\n        $ref: '#/components/schemas/LightMeasurement'\n  schemas:\n    LightMeasurement:\n      # Ignore the specifics here for now.\n```\nHere you can see that we simply reference where the definition of messages and payload schema is located.\n\n# Schema Object references\nAs seen in the streetlight example, to define your message payloads in AsyncAPI, we use a [Schema Object](https://www.asyncapi.com/docs/specifications/v2.2.0#schemaObject), which is a superset of [JSON Schema draft 7](https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-01). \n\nWhat `superset` means is we follow the JSON Schema draft 7 specification, but with a few modifications and additions to keywords.\n\nThe message `LightMeasured`, contains a keyword called `payload`, which is by default defined as a **Schema Object**. \n\nThis is where the confusion starts, what behavior does the `$ref` keyword follow? More precisely, which specification?\n\n# The confusion creeps in\nLet's take a closer look at the [Schema Object](https://www.asyncapi.com/docs/specifications/v2.2.0#schemaObject) to see if we can figure out the answer.\n\n> Further information about the properties can be found in JSON Schema Core and JSON Schema Validation. Unless stated otherwise, the property definitions follow the JSON Schema specification as referenced here.\n\nSo what this means is that unless stated otherwise in the **Schema Object**, it should follow the official JSON Schema draft 7 specification. So let's try to read further, to see if anything is stated about references. \n\n> Alternatively, any time a Schema Object can be used, a **Reference Object** can be used in its place. This allows referencing definitions in place of defining them inline.\n\nOkay... So that must mean that if we ever encounter a reference, we follow the **Reference Object** description. \n\nWell, that was easy; I see no rabbit hole here, Jonas!? \n\n# Welcome to the rabbit hole\nDuring the discussion, Sergio brought up that Fran was using an illegal reference, as he, in one of the examples, was using a **Reference Object** for a server, which was not allowed.  More specifically, it was this example where he references the `mosquitto` server:\n\n```yaml\n...\nservers:\n  mosquitto:\n    $ref: 'common.asyncapi.yaml#/components/servers/mosquitto'\n```\n\nMy immediate reaction was \"wait... It's not?!\"\n\nI had always used `$ref` quite extensively in my AsyncAPI documents and specifically used a reference for servers. And I knew that the tooling had no problems with the `$ref` as long as it was a valid reference. \n\nBut Sergio was absolutely right; a second look at the specification showed that `servers` are defined using the [Servers Object](https://www.asyncapi.com/docs/specifications/v2.2.0#serversObject), which is defined by using a map of [Server Object](https://www.asyncapi.com/docs/specifications/v2.2.0#serverObject)s. **NOT** `Server Object | Reference Object` as I expected.\n\nAfter that, we started to realize that there is quite a big difference between when and where **Reference Object**s are allowed. For the full list of discrepancies, check out [spec #650](https://github.com/asyncapi/spec/issues/650).\n\nBut... Why did I think it was allowed to do so? \n\n## Discrepancies in AsyncAPI Tooling\nSo back to my own experience, why was I so sure that the tooling allowed for me to use **Reference Object**s for servers? \n\nWell, as it turns out, it's because the [JS parser](https://github.com/asyncapi/parser-js) dereferences before it validates the AsyncAPI document. This means that if I defined my AsyncAPI document as follows:\n\n```yaml\nasyncapi: '2.2.0'\n...\nservers:\n  test-server:\n    $ref: './servers/testServer.yaml'\n...\n```\n\nTogether with `testServer.yaml`:\n```yaml\nurl: ws://mycompany.com/ws\nprotocol: ws\n```\n\nValidating the AsyncAPI document using a tool such as [ajv](https://ajv.js.org/) against the [JSON Schema representation for 2.2.0](https://github.com/asyncapi/spec-json-schemas/blob/master/schemas/2.2.0.json), it would reject it. \n\nHowever, because the parser dereferences first, the document that is being validated is this:\n\n```yaml\nasyncapi: '2.2.0'\n...\nservers:\n  test-server:\n    url: ws://mycompany.com/ws\n    protocol: ws\n...\n```\n\nCheckout [parser-js #405](https://github.com/asyncapi/parser-js/issues/405) for more information.\n\n## What about `$id` keyword\n\nOne of the key differences between our **Reference Object**, and how `$ref` is resolved in JSON Schema Draft 7, is the [$id keyword](https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-01#section-8.2). This allows you to define a URI that is used as a base URI. This means that for example a message such as this:\n\n```yaml\nasyncapi: '2.2.0'\n...\nchannels:\n  test/channel:\n    publish:\n      message:\n        schemaFormat: application/schema+json;version=draft-07\n        payload: \n          $id: https://example.com/schemas/test\n          type: object\n          properties:\n            address: \n              $ref: \"address\"\n...\n```\n\nThis will result in the reference for the `address` property, to be looked up at `https://example.com/schemas/address`, because it uses the Base URI in `$id` from the parent schema (`https://example.com/schemas`). \n\nI tried a little test in the [new Studio tool](https://studio.asyncapi.com/) (Studio uses the parser, so it could be used for an easy test), [which showed that this was not supported by the parser](https://studio.asyncapi.com/?base64=YXN5bmNhcGk6ICcyLjIuMCcKaW5mbzoKICB0aXRsZTogVGVzdCBvdmVycmlkaW5nIGRlcmVmZXJlbmNlZCBvYmplY3RzIAogIHZlcnNpb246ICcxLjAuMCcKY2hhbm5lbHM6CiAgdGVzdC9jaGFubmVsOgogICAgcHVibGlzaDoKICAgICAgbWVzc2FnZToKICAgICAgICBzY2hlbWFGb3JtYXQ6IGFwcGxpY2F0aW9uL3NjaGVtYStqc29uO3ZlcnNpb249ZHJhZnQtMDcKICAgICAgICBwYXlsb2FkOiAKICAgICAgICAgICRpZDogaHR0cHM6Ly9leGFtcGxlLmNvbS9zY2hlbWFzL3Rlc3QKICAgICAgICAgIHR5cGU6IG9iamVjdAogICAgICAgICAgcHJvcGVydGllczoKICAgICAgICAgICAgYWRkcmVzczogCiAgICAgICAgICAgICAgJHJlZjogImFkZHJlc3Mi). The library tries to resolve the reference at `https:///address` when it should have tried to resolve it from `http://example.com/schemas/address`. See [parser-js #403](https://github.com/asyncapi/parser-js/issues/403) for more information.\n\n## What about `$schema`?\nBefore getting into `$schema` I first need to mention a keyword in AsyncAPI called [schemaFormat which is part of the Message Object](https://www.asyncapi.com/docs/specifications/v2.2.0#messageObject). What this keyword is used for is to change what format the payload is defined with. By defining it with `application/vnd.aai.asyncapi+yaml;version=2.2.0` it is the same as the default format.\n\nIn JSON Schema Draft 7, and in the **Schema Object**, there exists a keyword, similar to what `schemaFormat` is for AsyncAPI, that can be used to define what version of JSON Schema `LightMeasurement` follows.\n\nSo what if both are defined at the same time, and they contradict each other?\n\n```yaml\nasyncapi: '2.2.0'\n...\ncomponents:\n  messages:\n    LightMeasured: \n      name: LightMeasured\n      schemaFormat: application/vnd.aai.asyncapi+yaml;version=2.2.0\n      payload:\n        $ref: '#/components/schemas/LightMeasurement'\n  schemas:\n    LightMeasurement:\n      $schema: 'http://json-schema.org/draft-04/schema#'\n      ...\n```\nWith such contradicting information, how should tooling handle this? This sparked [spec #655](https://github.com/asyncapi/spec/issues/655).\n\n## What about extra keywords?\nFollowing that, by taking a closer look at the [JSON reference](https://datatracker.ietf.org/doc/html/draft-pbryan-zyp-json-ref-03) specification the **Reference Object** follows, we find the [sentence](https://datatracker.ietf.org/doc/html/draft-pbryan-zyp-json-ref-03#section-3):\n\n> Any members other than \"$ref\" in a JSON Reference object SHALL be ignored.\n\nWhat this means, is that if we have a reference defined such as:\n\n```yaml\n...\ncomponents:\n  messages:\n    LightMeasured:\n      payload:\n        type: boolean\n        $ref: '#/components/schemas/LightMeasurement'\n  schemas:\n    LightMeasurement:\n      type: string\n```\n\nThe `type` property for the message payload, should be completely ignored. So let's try and see what happens when we try this in [Studio](https://studio.asyncapi.com/?base64=YXN5bmNhcGk6ICcyLjIuMCcKaW5mbzoKICB0aXRsZTogVGVzdCBvdmVycmlkaW5nIHByb3BlcnRpZXMgd2l0aCBkZXJlZmVyZW5jZWQgb2JqZWN0cyAKICB2ZXJzaW9uOiAnMS4wLjAnCmNoYW5uZWxzOgogIHRlc3Q6CiAgICBwdWJsaXNoOgogICAgICBtZXNzYWdlOgogICAgICAgICRyZWY6ICcjL2NvbXBvbmVudHMvbWVzc2FnZXMvTGlnaHRNZWFzdXJlbWVudCcKY29tcG9uZW50czoKICBtZXNzYWdlczoKICAgIExpZ2h0TWVhc3VyZW1lbnQ6IAogICAgICBuYW1lOiBMaWdodE1lYXN1cmVtZW50CiAgICAgIHBheWxvYWQ6CiAgICAgICAgdHlwZTogYm9vbGVhbgogICAgICAgICRyZWY6ICcjL2NvbXBvbmVudHMvc2NoZW1hcy9MaWdodE1lYXN1cmVtZW50JwogIHNjaGVtYXM6CiAgICBMaWdodE1lYXN1cmVtZW50OgogICAgICB0eXBlOiBzdHJpbmc=).\n\nOnce the schema is parsed, all that remains is `type: boolean`, and not the expected `type: string` from the referenced schema. This is clearly the opposite of what the specification defines. For more information see [parser-js #404](https://github.com/asyncapi/parser-js/issues/404).\n\nWe then asked ourselves, what about JSON Schema, does it define a different behavior? The answer to this question can be found [here](https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-01#section-8.3):\n\n> All other properties in a \"$ref\" object MUST be ignored.\n\nLuckily, they both match the same behavior in terms of extra keywords. Both Reference Object and JSON Schema should ignore extra keywords.\n\nBut, what if I use one of the newer JSON Schema versions, what then?\n\n## Upgrading to JSON Schema draft 2020-12\nWe started to correlate the findings with the feature request from [Maciej](https://github.com/magicmatatjahu) about updating AsyncAPI Schema Object to point towards [JSON Schema Draft 2020-12](https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-00).\n\nWhat would this mean for our little `$ref` keywords?\n\nOpenAPI have in its most recent version 3.1, switched its default JSON Schema version to Draft 2020-12, the exact feature request for AsyncAPI. This, however, introduced a huge change to how you bundle references. I don't want to spend much time on this as [Ben](https://twitter.com/relequestual) and [Mike](https://twitter.com/PermittedSoc) described this entire change and what it means in terms of bundling in this great blog post [Bundling simple external resources](https://json-schema.org/blog/posts/bundling-json-schema-compound-documents#bundling-simple-external-resources). Besides this, the release notes for Draft 2020-12 also offers some guidance which can be found here: https://json-schema.org/draft/2020-12/release-notes.html\n\nBesides having a bunch of new keywords that change the referencing behavior, such as `$dynamicRef`, `$dynamicAnchor`, `$anchor`, one of the key differences is that in [JSON Schema draft 2019-09](https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-02), they changed their behavior of references so that extra keywords are now allowed adjacent to `$ref`.\n\nBut what does this mean exactly? Does this mean `$ref` overwrites any duplicated properties? Or is it the other way around?\n\nWell, there is one thing we need to remember about JSON Schema. It is primarily built for validation rules and how a validator can take input data and determine whether that input is valid against the Schema. \n\nThis means, that if you have a JSON Schema using `$ref` such as:\n```json\n{ \"$ref\": \"./test.json\", \"minLength\": 7, \"maxLength\": 12}\n```\nand `test.json` is defined as:\n\n```json\n{\"minLength\": 5, \"format\": \"email\"}\n```\n\nJSON Schema draft 2019-09, assumes that the references are resolved similar to:\n```json\n{\"$ref\": {\"minLength\": 5, \"format\": \"email\"}, \"minLength\": 7, \"maxLength\": 12}\n```\n\nThis is because in validation, you want to validate that the input data is valid against the referenced schema and should [**not** be seen as a kind of merging behavior](https://github.com/APIDevTools/json-schema-ref-parser/issues/145):\n```json\n{\"format\": \"email\", \"minLength\": 7, \"maxLength\": 12}\n```\n\nThis behavior is different from what is assumed when using AsyncAPI, as the last option, is more aligned with expected behavior.\n\nFurthermore, now, each schema can define it's own `$schema` that they follow, instead of ONLY being available at the root... \n\nThis leaves the question, how can we make sure that we stay consistent and don't introduce more confusion into the AsyncAPI specification? This difference is what triggered the last issue in [spec 649](https://github.com/asyncapi/spec/issues/649).\n\n## Hard to find tooling\nThis leaves us with one huge deficit, that there are so many different behaviors for references that tooling mix and matches between the specifications and what they solve.\n\nOne of the most used tooling for dereferencing stuff in JS, and the one we are using is from [APIDevTools called json-schema-ref-parser](https://github.com/APIDevTools/json-schema-ref-parser). We actually use this tool to ensure **ANY** encounters of `$ref` are dereferenced, so the tool has direct access to the schema, without it having to look elsewhere for it. \n\nHowever, the tool started out being built **ONLY** for dereferencing `$ref` based on the [JSON Reference specification and the JSON Pointer specification](https://github.com/APIDevTools/json-schema-ref-parser/issues/22#issuecomment-231783185).  At least it was, now it's not easy to figure out what it is for, as [it allows extra properties](https://github.com/APIDevTools/json-schema-ref-parser/issues/232) but [$id is not taken into account](https://github.com/APIDevTools/json-schema-ref-parser/issues/136).\n\nThis leaves us in a bit of a struggle, as [there are not many alternatives](https://json-schema.org/implementations.html#general-processing); JS [@hyperjump/json-schema-core](https://github.com/jdesrosiers/json-schema-core) looks promising, but there's no tooling that our [Go parser](https://github.com/asyncapi/parser-go) can use.\n\nAnd with no official or community tooling, we are left with having to develop it ourselves to adopt the spec... There are luckily efforts being made in [JSON Schema to adopt to such a change](https://github.com/json-schema-org/community/discussions/113).\n\n# Final word\nThat concludes the rabbit hole that Sergio and I went down, for a simple `$ref` keyword... (ONE KEYWORD! :sweat_smile:)\n\n\nIf you have any comments or issues with what was described here, please go into the respective issues and make a comment - also if you think we are wrong!\n\nIn case you are interested, we are also looking for contributors, to help us solve these issues. If you want to take one up, just write a comment in the respective issue.\n\nOverview of issues:\n\n- [spec #650](https://github.com/asyncapi/spec/issues/650), highlights the discrepancies when the Reference Object can be used.\n- [spec #649](https://github.com/asyncapi/spec/issues/649), tries to solve the core issue that `$ref` means two different things, depending on when it's used.\n- [spec #655](https://github.com/asyncapi/spec/issues/655), what do you do when encountering `$schema` and Message Object `schemaFormat`, especially when they are contradicting.\n- [parser-js #405](https://github.com/asyncapi/parser-js/issues/405), highlights that the parser accurately validates incorrect AsyncAPI documents, because it bundles references before validating.\n- [parser-js #404](https://github.com/asyncapi/parser-js/issues/404), highlights that the parser allows for keywords to be defined together with `$ref` and are not being ignored.\n- [parser-js #403](https://github.com/asyncapi/parser-js/issues/403), highlights that the parser does not care about `$id` in the Schema Object when it should.\n\n> Photo by <a href=\"https://unsplash.com/@nxvision?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Nigel Tadyanehondo</a> on <a href=\"https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "AsyncAPI references",
        "slug": "asyncapi-references",
        "lvl": 1,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Schema Object references",
        "slug": "schema-object-references",
        "lvl": 1,
        "i": 1,
        "seen": 0
      },
      {
        "content": "The confusion creeps in",
        "slug": "the-confusion-creeps-in",
        "lvl": 1,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Welcome to the rabbit hole",
        "slug": "welcome-to-the-rabbit-hole",
        "lvl": 1,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Discrepancies in AsyncAPI Tooling",
        "slug": "discrepancies-in-asyncapi-tooling",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "What about `$id` keyword",
        "slug": "what-about-id-keyword",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "What about `$schema`?",
        "slug": "what-about-schema",
        "lvl": 2,
        "i": 6,
        "seen": 0
      },
      {
        "content": "What about extra keywords?",
        "slug": "what-about-extra-keywords",
        "lvl": 2,
        "i": 7,
        "seen": 0
      },
      {
        "content": "Upgrading to JSON Schema draft 2020-12",
        "slug": "upgrading-to-json-schema-draft-2020-12",
        "lvl": 2,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Hard to find tooling",
        "slug": "hard-to-find-tooling",
        "lvl": 2,
        "i": 9,
        "seen": 0
      },
      {
        "content": "Final word",
        "slug": "final-word",
        "lvl": 1,
        "i": 10,
        "seen": 0
      }
    ],
    "slug": "/blog/the-reference-rabbit-hole",
    "filePath": "pages/blog/the-reference-rabbit-hole.md"
  },
  {
    "meta": {
      "type": "Engineering",
      "title": "The journey of documenting a Socket.IO API (Pt 2)",
      "date": "2021-11-04T09:00:00.000Z",
      "cover": "/img/posts/socketio-part2/cover.webp",
      "tags": [
        "Specification",
        "Socket.IO",
        "Protocol",
        "Asynction"
      ],
      "authors": [
        {
          "name": "Dimitrios Dedoussis",
          "photo": "/img/avatars/dedoussis.webp",
          "link": "https://twitter.com/dedoussis",
          "byline": "Senior Software Engineer at Babylon & Maintainer of Asynction"
        }
      ],
      "readingTime": 14,
      "excerpt": "This post originally appeared on https://dedouss.is\n\nIn the opening part of this series we outlined the basics of Socket.IO and discussed the importance of documenting Socket.IO APIs. Now it’s time to"
    },
    "content": "\n> This post originally appeared on [https://dedouss.is](https://dedouss.is/posts/2021-07-14-documenting-socketio-part-2.html)\n\nIn [the opening part of this series](/blog/socketio-part1) we outlined the basics of [Socket.IO](https://socket.io) and discussed the importance of documenting Socket.IO APIs. Now it’s time to bring [AsyncAPI](https://www.asyncapi.com/) into play.\n\nIn this post we’re going to cover:\n\n- [A modelling exercise, in which Socket.IO semantics are mapped to AsyncAPI structures](#modelling-the-socketio-protocol-using-asyncapi)\n- [A tutorial involving the creation of an AsyncAPI specification given an existing Socket.IO API](#in-practice)\n- [Asynction, a Socket.IO server framework driven by the AsyncAPI specification](#asynction)\n\n## Modelling the Socket.IO protocol using AsyncAPI\n\nDon’t let the title of this section intimidate you. This modelling exercise ended up being relatively straightforward and I think it makes a great example of how AsyncAPI was designed to fit any event-driven protocol. If you are not interested in the thought process behind this exercise, you may jump straight to the [Summary](#summary) paragraph of this section, which presents the solution.\n\nI will approach this problem by traversing the AsyncAPI object structure, attempting to map each of the objects to a semantic of the Socket.IO client API.\n\nThe root object of the specification is the [AsyncAPI Object](https://www.asyncapi.com/docs/specifications/v2.2.0#A2SObject). The fields of this object that require special attention are **channels** and **servers**.\n\n### Channels\n\nThe [Channels Object](https://www.asyncapi.com/docs/specifications/v2.2.0#channelsObject) is a map structure that relates a channel path (relative URI) to a [Channel Item Object](https://www.asyncapi.com/docs/specifications/v2.2.0#channelItemObject).\n\n```yaml\nchannels:\n  /: {} # Channel Item Object\n  /admin: {} # Channel Item Object\n```\n\nChannels are addressable components where messages/events flow through. The specification suggests that a server may support multiple channel instances enabling an application to separate its concerns. This sounds very much like the definition of the Socket.IO [namespace](https://socket.io/docs/v4/namespaces/index.html). Namespaces are indeed addressable components that follow the relative URI convention. Since Socket.IO supports multiplexing, a client may emit messages to multiple namespaces over a single shared connection. However, it could also force a separate connection per namespace (using the [`forceNew` option](https://socket.io/docs/v4/client-initialization/#forceNew)). Thus, a Socket.IO namespace could either be a virtual or physical channel.\n\nGiven that connections are established on the namespace level, the [Channel Item Object](https://www.asyncapi.com/docs/specifications/v2.2.0#channelItemObject) is the only object of the specification that MAY include **bindings**. For a Socket.IO API, the [Channel Bindings Object](https://www.asyncapi.com/docs/specifications/v2.2.0#channelBindingsObject) should only contain the **ws** field, in which one can specify the handshake context (HTTP headers and query params) that a client should provide when connecting to that particular channel/namespace.\n\n```yaml\nchannels:\n  /:\n    publish: {} # Operation object - Ignore this for now\n    subscribe: {} # Operation object - Ignore this for now\n    bindings:\n      ws:\n        query:\n          type: object\n          properties:\n            token:\n              type: string\n          required: [token]\n```\n\nSince a single connection (and thus binding) is going to be used across multiple channels, there is no need to repeat the same **bindings** object under each channel/namespace. We can introduce the convention of always including bindings under the main (`/`) namespace but omitting them under the custom ones. At this point I would also like to propose the following bonus semantic: If a custom namespace includes bindings, then the client should always [force a new connection](https://socket.io/docs/v4/client-initialization/#forceNew) when connecting to it.\n\nYou have probably noticed that I chose to stick to the [WebSockets Channel Binding](https://github.com/asyncapi/bindings/blob/master/websockets/README.md#channel-binding-object) as the only possible binding that a Socket.IO API may define. One could ask why not use an [HTTP Channel Binding](https://github.com/asyncapi/bindings/blob/master/http/README.md#channel) object alongside the WebSockets one, since the protocol could also be implemented via HTTP long-polling. There are 2 answers to this question:\n\n1. The current latest version of the [AsyncAPI bindings specifications](https://github.com/asyncapi/bindings) does not allow HTTP bindings to be defined at the channel level.\n1. The HTTP long-polling implementation of Socket.IO is essentially a pseudo WebSocket. It is implemented in such a way to resemble the WebSocket implementation. The same HTTP headers and query params are sent to the server no matter the transport mechanism.\n\nHence, it is safe to use the ws bindings even for the HTTP long-polling fallback. However, in an ideal world, we would have AsyncAPI supporting SocketIO bindings through an explicit **socketio** field. In fact, I have created [a github issue](https://github.com/asyncapi/bindings/issues/74) to pitch this proposal.\n\nAlong with **bindings**, the [Channel Item Object](https://www.asyncapi.com/docs/specifications/v2.2.0#channelItemObject) includes the **publish** and **subscribe** fields, in which one defines the operations that a namespace supports. The **publish** [Operation Object](https://www.asyncapi.com/docs/specifications/v2.2.0#operationObject) lists all the possible events that the client may emit (`socket.emit`), while the **subscribe** operation defines the events that the client may listen to (`socket.on`).\n\nA Socket.IO event can be expressed using the [Message Object](https://www.asyncapi.com/docs/specifications/v2.2.0#messageObject), where the **name** field describes the **eventName** and the **payload** field describes the schema of the **args** that the client passes as part of the **socket.emit** invocation: `socket.emit(eventName[, …args][, ack])`. For **subscribe** events, **payload** defines the structure of the arguments that the event handler callback expects: `socket.on(eventName, (...args) => {})`.\n\nThe structure of the payload value depends on the number of arguments expected:\n\n<table>\n  <thead>\n    <tr>\n      <th>Scenario</th>\n      <th>Sender-side code</th>\n      <th>Payload value structure</th>\n      <th>AsyncAPI Message Object</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>No args expected</td>\n      <td><inlineCode>{`socket.emit(\"hello\")`}</inlineCode></td>\n      <td>n/a — Payload field should be omitted</td>\n      <td><CodeBlock showLineNumbers={false}>{`name: hello`}</CodeBlock></td>\n    </tr>\n    <tr>\n      <td>Single arg expected</td>\n      <td><inlineCode>{`socket.emit(\"hello\", {foo: “bar”})`}</inlineCode></td>\n      <td>Any <a href=\"https://json-schema.org/understanding-json-schema/reference/type.html\">type</a> other than <a href=\"https://json-schema.org/understanding-json-schema/reference/array.html#tuple-validation\">tuple</a></td>\n      <td>\n        <CodeBlock showLineNumbers={false}>{`name: hello\npayload:\n  type: object\n  properties:\n    foo:\n      type: string`}\n        </CodeBlock>\n      </td>\n    </tr>\n    <tr>\n      <td>Multiple args expected</td>\n      <td><inlineCode>{`socket.emit(\"hello\", {foo: “bar”}, 1)`}</inlineCode></td>\n      <td><a href=\"https://json-schema.org/understanding-json-schema/reference/array.html#tuple-validation\">Tuple type</a></td>\n      <td>\n        <CodeBlock showLineNumbers={false}>{`name: hello\npayload:\n  type: array\n  prefixItems:\n  - type: object\n      properties:\n        foo:\n          type: string\n  - type: number`}\n        </CodeBlock>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\nTo account for multiple events ([Message Object](https://www.asyncapi.com/docs/specifications/v2.2.0#messageObject)s) per namespace, the **message** field of each [Operation Object](https://www.asyncapi.com/docs/specifications/v2.2.0#operationObject) allows the **oneOf** array structure. For example, in the message of the publish operation of the `/admin` namespace, the **oneOf** array lists all the available **eventName** and **args** payload pairs that a client can pass to the `adminNamespace.emit` call:\n\n```yaml\nchannels:\n  /admin:\n    publish:\n      message:\n        oneOf:\n          - $ref: \"#/components/messages/MessageOne\"\n          - $ref: \"#/components/messages/MessageTwo\"\n```\n\nNow, let’s move on to the acknowledgement semantics of the protocol: The basic unit of information in the Socket.IO protocol is the packet. There are 7 distinct [packet types](https://github.com/socketio/socket.io-protocol#packet-types). The payloads of the publish and subscribe Message Objects described above correspond to the `EVENT` and `BINARY_EVENT` packet types. These are essentially the packets that are transmitted when the Socket.IO sender invokes the **emit** API function of the Socket.IO library (regardless of implementation). In turn, the Socket.IO event receiver handles the received event using the **on** API function of the Socket.IO library. As part of the **on** handler, the receiver may choose to return an acknowledgement of the received message. This acknowledgement is conveyed back to the sender via the `ACK` and `BINARY_ACK` packet types. The ack data is passed as input to the callback that the message sender has provided through the **emit** invocation.\n\n<Figure\n  className=\"text-center\"\n  widthClass=\"w-7/12\"\n  src=\"/img/posts/socketio-part2/socketio-ack-sequence-diagram.webp\"\n  caption=\"Socket.IO ack sequence diagram\"\n/>\n\nIn order to express the above semantics, the Message Object (eventName and args payload pair) should be linked to an optional acknowledgement object. Since the specification in its current form does not support such a structure, I am proposing the following [Specification Extension](https://www.asyncapi.com/docs/specifications/v2.2.0#specificationExtensions):\n\n- [Message Object](https://www.asyncapi.com/docs/specifications/v2.2.0#messageObject)s MAY include the `x-ack` field. The value of this field SHOULD be a [Message Ack Object](#message-ack-object).\n- [Components Object](https://www.asyncapi.com/docs/specifications/v2.2.0#componentsObject) MAY include the `x-messageAcks` field. The value of this field should be of type: `Map[string, Message Ack Object | Reference Object]`.\n\n#### Message Ack Object\n\n| Field Name | Type                                                                              | Description                                                                                                                                                            |\n| ---------- | --------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| args       | [Schema Object](https://www.asyncapi.com/docs/specifications/v2.2.0#schemaObject) | Schema of the arguments that are passed as input to the acknowledgement callback function. In the case of multiple arguments, use the array type to express the tuple. |\n\nIn the case of a **publish** message, the `x-ack` field informs the client that it should expect an acknowledgement from the server, and that this acknowledgement should adhere to the agreed schema. Likewise, for **subscribe** messages the `x-ack` field encourages the client to send a structured acknowledgement, for each message it receives.\n\n### Servers\n\nThe [Servers Object](https://www.asyncapi.com/docs/specifications/v2.2.0#serversObject) is – surprise surprise – a map of Server Objects. Each [Server Object](https://www.asyncapi.com/docs/specifications/v2.2.0#serverObject) contains a **url** field from which the client may infer the custom path to the Socket.IO server. This custom path should then be provided via the **path** option upon the [initialisation of the Socket.IO connection manager](https://socket.io/docs/v4/client-api/#io-url-options), alongside the **url** arg. The **protocol** field of the [Server Object](https://www.asyncapi.com/docs/specifications/v2.2.0#serverObject) is also required, and specifies the scheme part of that **url** arg. Its value should equal any of the **ws**, **wss**, **http** or **https** protocols. For a Socket.IO client, it does not really matter whether the scheme is http or ws, due to the upgrade mechanism. Thus, for Socket.IO APIs, the only purpose of the **protocol** field is to indicate the use (or absence) of SSL.\n\n### Summary\n\nWe made it to the end of the modelling exercise the outcome of which is the following table, relating Socket.IO semantics to AsyncAPI structures.\n\n| Socket.IO                                                                                                                                                                   | AsyncAPI                                                                                                                                                                                                                                                                                                                                                                                 |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [Namespace](https://socket.io/docs/v4/namespaces/index.html)                                                                                                                | [Channel](https://www.asyncapi.com/docs/specifications/v2.2.0#definitionsChannel) (described through the [Channel Item Object](https://www.asyncapi.com/docs/specifications/v2.2.0#channelItemObject))                                                                                                                                                                                   |\n| [IO options](https://www.google.com/url?q=https://socket.io/docs/v4/client-api/%23io-url-options&sa=D&source=editors&ust=1626260158636000&usg=AOvVaw3Jm-RtRjuNphtaCN-54p4L) | [WebSockets Channel Binding](https://github.com/asyncapi/bindings/blob/master/websockets/README.md#channel-binding-object)                                                                                                                                                                                                                                                               |\n| `namespaceSocket.emit(eventName[, …args][, ack])`                                                                                                                           | [Operation Object](https://www.asyncapi.com/docs/specifications/v2.2.0#operationObject) defined under the **publish** field of a [Channel Item Object](https://www.asyncapi.com/docs/specifications/v2.2.0#channelItemObject). The available **eventName** & **args** pairs for this **emit** invocation are listed under the **message** field, through the **oneOf** array structure.              |\n| `namespaceSocket.on(eventName, callback)`                                                                                                                                   | [Operation Object](https://www.asyncapi.com/docs/specifications/v2.2.0#operationObject) defined under the **subscribe** field of a [Channel Item Object](https://www.asyncapi.com/docs/specifications/v2.2.0#channelItemObject). The available **eventName** & **callback** argument pairs for this **on** invocation are listed under the **message** field, through the **oneOf** array structure. |\n| Event                                                                                                                                                                       | [Message](https://www.asyncapi.com/docs/specifications/v2.2.0#definitionsMessage) (described through the [Message Object](https://www.asyncapi.com/docs/specifications/v2.2.0#messageObject))                                                                                                                                                                                            |\n| **eventName**                                                                                                                                                                 | The **name** field of the [Message Object](https://www.asyncapi.com/docs/specifications/v2.2.0#messageObject))                                                                                                                                                                                                                                                                             |\n| Event **args**                                                                                                                                                                | The **payload** field of the [Message Object](https://www.asyncapi.com/docs/specifications/v2.2.0#messageObject)                                                                                                                                                                                                                                                                           |\n| **ack**                                                                                                                                                                       | The `x-ack` field of the [Message Object](https://www.asyncapi.com/docs/specifications/v2.2.0#messageObject). Requires an [extension of the specification](https://www.asyncapi.com/docs/specifications/v2.2.0#specificationExtensions). The field may be populated for both **publish** and **subscribe** messages.                                                                         |\n| Custom path (**path** option)                                                                                                                                                 | The **url** field of the [Server Object](https://www.asyncapi.com/docs/specifications/v2.2.0#serverObject)                                                                                                                                                                                                                                                                                 |\n| Use of TLS (regardless of transport mechanism)                                                                                                                              | The **protocol** field of the [Server Object](https://www.asyncapi.com/docs/specifications/v2.2.0#serverObject)                                                                                                                                                                                                                                                                            |\n\n## In practice\n\nWith the modelling exercise out of the way, I’m now going to guide you through the process of creating an AsyncAPI spec from scratch given an existing Socket.IO API. For the purposes of this simple tutorial, let’s use [this minimal chat application](https://socket.io/demos/chat/), which is one of the get-started demos featured in the Socket.IO website.\n\nBelow is the source of our Socket.IO server:\n\n```javascript\n// Setup basic express server\nconst express = require(\"express\");\nconst app = express();\nconst path = require(\"path\");\nconst server = require(\"http\").createServer(app);\nconst io = require(\"socket.io\")(server);\nconst port = process.env.PORT || 3000;\n\nserver.listen(port, () => {\n  console.log(\"Server listening at port %d\", port);\n});\n\n// Chatroom\nlet numUsers = 0;\n\nio.on(\"connection\", (socket) => {\n  let addedUser = false;\n\n  // when the client emits 'new message', this listens and executes\n  socket.on(\"new message\", (data) => {\n    // we tell the client to execute 'new message'\n    socket.broadcast.emit(\"new message\", {\n      username: socket.username,\n      message: data,\n    });\n  });\n\n  // when the client emits 'add user', this listens and executes\n  socket.on(\"add user\", (username, cb) => {\n    if (addedUser) {\n      cb({ error: \"User is already added\" });\n      return;\n    }\n\n    // we store the username in the socket session for this client\n    socket.username = username;\n    ++numUsers;\n    addedUser = true;\n    socket.emit(\"login\", {\n      numUsers: numUsers,\n    });\n    // echo globally (all clients) that a person has connected\n    socket.broadcast.emit(\"user joined\", {\n      username: socket.username,\n      numUsers: numUsers,\n    });\n    cb({ error: null });\n  });\n\n  // when the client emits 'typing', we broadcast it to others\n  socket.on(\"typing\", () => {\n    socket.broadcast.emit(\"typing\", {\n      username: socket.username,\n    });\n  });\n\n  // when the client emits 'stop typing', we broadcast it to others\n  socket.on(\"stop typing\", () => {\n    socket.broadcast.emit(\"stop typing\", {\n      username: socket.username,\n    });\n  });\n\n  // when the user disconnects.. perform this\n  socket.on(\"disconnect\", () => {\n    if (addedUser) {\n      --numUsers;\n\n      // echo globally that this client has left\n      socket.broadcast.emit(\"user left\", {\n        username: socket.username,\n        numUsers: numUsers,\n      });\n    }\n  });\n});\n\n// Admin\n\nio.of(\"/admin\").on(\"connection\", (socket) => {\n  let token = socket.handshake.query.token;\n  if (token !== \"admin\") socket.disconnect();\n\n  socket.emit(\"server metric\", {\n    name: \"CPU_COUNT\",\n    value: require(\"os\").cpus().length,\n  });\n});\n```\n\nI’ve slightly tweaked the original source located at <https://github.com/socketio/socket.io/tree/master/examples/chat> to include acknowledgments and bindings, so that I can showcase the full spectrum of the AsyncAPI specification.\n\nLet’s start by defining the version of the specification as well as the info object which provides metadata about the service:\n\n```yaml\nasyncapi: 2.2.0\n\ninfo:\n  title: Socket.IO chat service\n  version: 1.0.0\n  description: |\n    This is one of the get-started demos listed in the socket.io website: https://socket.io/demos/chat/\n```\n\nMoving on to the servers section, where one should provide connectivity information for all the instances of their service. In the case of our simple chat application, there is only one demo server accessible at [socketio-chat-h9jt.herokuapp.com](https://socketio-chat-h9jt.herokuapp.com/):\n\n```yaml\nservers:\n  demo:\n    url: socketio-chat-h9jt.herokuapp.com/socket.io\n    protocol: wss\n```\n\nThings get a bit more interesting when it comes to channels. Skimming through the server code we find 2 namespace instances (default and /admin), which means that the channel mapping should consist of 2 entries:\n\n```yaml\nchannels:\n  /: {}\n  /admin: {}\n```\n\nWithin each namespace connection block, there are multiple `socket.on`, and `socket.emit` references. For each unique reference, we need to append a Message Object under the publish and subscribe operations respectively:\n\n```yaml\nchannels:\n  /:\n    publish:\n      message:\n        oneOf:\n          - $ref: \"#/components/messages/NewMessage\"\n          - $ref: \"#/components/messages/Typing\"\n          - $ref: \"#/components/messages/StopTyping\"\n          - $ref: \"#/components/messages/AddUser\"\n    subscribe:\n      message:\n        oneOf:\n          - $ref: \"#/components/messages/NewMessageReceived\"\n          - $ref: \"#/components/messages/UserTyping\"\n          - $ref: \"#/components/messages/UserStopTyping\"\n          - $ref: \"#/components/messages/UserJoined\"\n          - $ref: \"#/components/messages/UserLeft\"\n          - $ref: \"#/components/messages/LogIn\"\n  /admin:\n    subscribe:\n      message: # No need to use `oneOf` since there is only a single event\n        $ref: \"#/components/messages/ServerMetric\"\n```\n\nFrom the server code, we can also see that the connection handler of the admin namespace applies some very sophisticated authorization based on the `token` query parameter. The spec should hence document that the API requires the presence of a valid token query param upon the handshake:\n\n```yaml\nchannels:\n  /:\n    publish:\n      # ...\n    subscribe:\n      # ...\n  /admin:\n    subscribe:\n      # ...\n    bindings:\n      $ref: \"#/components/channelBindings/AuthenticatedWsBindings\"\n```\n\nPutting everything together into a single document:\n\n```yaml\nasyncapi: 2.2.0\n\ninfo:\n  title: Socket.IO chat demo service\n  version: 1.0.0\n  description: |\n    This is one of the get-started demos presented in the socket.io website: https://socket.io/demos/chat/\n\nservers:\n  demo:\n    url: socketio-chat-h9jt.herokuapp.com/socket.io\n    protocol: wss\n\nchannels:\n  /:\n    publish:\n      message:\n        oneOf:\n          - $ref: \"#/components/messages/NewMessage\"\n          - $ref: \"#/components/messages/Typing\"\n          - $ref: \"#/components/messages/StopTyping\"\n          - $ref: \"#/components/messages/AddUser\"\n    subscribe:\n      message:\n        oneOf:\n          - $ref: \"#/components/messages/NewMessageReceived\"\n          - $ref: \"#/components/messages/UserTyping\"\n          - $ref: \"#/components/messages/UserStopTyping\"\n          - $ref: \"#/components/messages/UserJoined\"\n          - $ref: \"#/components/messages/UserLeft\"\n          - $ref: \"#/components/messages/LogIn\"\n  /admin:\n    subscribe:\n      message: # No need to use `oneOf` since there is only a single event\n        $ref: \"#/components/messages/ServerMetric\"\n    bindings:\n      $ref: \"#/components/channelBindings/AuthenticatedWsBindings\"\n\ncomponents:\n  messages:\n    NewMessage:\n      name: new message\n      payload:\n        type: string\n    Typing:\n      name: typing\n    StopTyping:\n      name: stop typing\n    AddUser:\n      name: add user\n      payload:\n        type: string\n      x-ack: # Documents that this event is always acknowledged by the receiver\n        args:\n          type: object\n          properties:\n            error:\n              type: [string, \"null\"]\n    NewMessageReceived:\n      name: new message\n      payload:\n        type: object\n        properties:\n          username:\n            type: string\n          message:\n            type: string\n    UserTyping:\n      name: typing\n      payload:\n        type: object\n        properties:\n          username:\n            type: string\n    UserStopTyping:\n      name: stop typing\n      payload:\n        type: object\n        properties:\n          username:\n            type: string\n    UserJoined:\n      name: user joined\n      payload:\n        type: object\n        properties:\n          username:\n            type: string\n          numUsers:\n            type: integer\n    UserLeft:\n      name: user left\n      payload:\n        type: object\n        properties:\n          username:\n            type: string\n          numUsers:\n            type: integer\n    LogIn:\n      name: login\n      payload:\n        type: object\n        properties:\n          numUsers:\n            type: integer\n    ServerMetric:\n      name: server metric\n      payload:\n        type: object\n        properties:\n          name:\n            type: string\n          value:\n            type: number\n\n  channelBindings:\n    AuthenticatedWsBindings:\n      ws:\n        query:\n          type: object\n          properties:\n            token:\n              type: string\n          required: [token]\n```\n\nThe modified server source code is pushed at <https://github.com/dedoussis/asyncapi-socket.io-example>, along with the above AsyncAPI spec, which can be viewed using the [AsyncAPI playground](https://playground.asyncapi.io/?url=https://raw.githubusercontent.com/dedoussis/asyncapi-socket.io-example/main/asyncapi.yaml).\n\nNote that there is no point in documenting the [reserved events](https://socket.io/docs/v4/emit-cheatsheet/#Reserved-events) since all Socket.IO APIs support these by default.\n\n## Asynction\n\nIn parallel to this exercise I have been developing [Asynction](https://github.com/dedoussis/asynction), a Socket.IO python framework that is driven by the AsyncAPI specification. Asynction is built on top of Flask-Socket.IO and inspired by Connexion. It guarantees that your API will work in accordance with its documentation. In essence, Asynction is to AsyncAPI and Flask-SocketIO, what Connexion is to OpenAPI and Flask.\n\nIn [this example](https://github.com/dedoussis/asynction/tree/main/example), I forked the minimal chat application that we documented above and re-implemented the server in python, using Asynction. Be mindful of the `x-handler` and `x-handlers` extensions that have been introduced to relate AsyncAPI entities (such as message or channel objects) to python callables (event handlers).\n\nYou may find extensive documentation of Asynction at: <https://asynction.dedouss.is>\n\nThe framework is still at a beta stage, so please get in touch before using it in a production setup.\n\nAny piece of feedback would be much appreciated.\n\n## The end\n\nFor any questions, comments, or corrections, feel free to reach out to me at [dimitrios@dedouss.is](mailto:dimitrios@dedouss.is).\n\n_A special shout out to [derberq](https://twitter.com/derberq), [alequetzalli](https://twitter.com/QuetzalliAle), and the wider AsyncAPI community for being particularly helpful and responsive._ 🙇\n\n> Photo by <a href=\"https://unsplash.com/photos/A4iL43vunlY\">Matt Howard</a> on <a href=\"https://unsplash.com/photos/A4iL43vunlY\">Unsplash</a>\n",
    "toc": [
      {
        "content": "Modelling the Socket.IO protocol using AsyncAPI",
        "slug": "modelling-the-socketio-protocol-using-asyncapi",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Channels",
        "slug": "channels",
        "lvl": 3,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Message Ack Object",
        "slug": "message-ack-object",
        "lvl": 4,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Servers",
        "slug": "servers",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Summary",
        "slug": "summary",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "In practice",
        "slug": "in-practice",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Asynction",
        "slug": "asynction",
        "lvl": 2,
        "i": 6,
        "seen": 0
      },
      {
        "content": "The end",
        "slug": "the-end",
        "lvl": 2,
        "i": 7,
        "seen": 0
      }
    ],
    "slug": "/blog/socketio-part2",
    "filePath": "pages/blog/socketio-part2.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Spec 2.2.0 Release Notes",
      "date": "2021-09-28T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Release Notes",
        "Specification"
      ],
      "cover": "/img/posts/release-notes-2.2.0/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "excerpt": "2.2 release of AsyncAPI specification is here. The long-awaited feature for assigning channels to servers is finally here.",
      "readingTime": 3
    },
    "content": "\nI'm happy to share that AsyncAPI specification 2.2.0 is here. Check out all the goodies that it brings.\n\n> This is a minor release, and it doesn't bring any breaking changes. You can switch to it by modifying the following value in your AsyncAPI file `asyncapi: '2.1.0'` into `asyncapi: '2.2.0'`\n\n## Assigning channels to servers\n\nThis feature allows the definition of AsyncAPI documents for applications with more selective use of channels and servers. An example is message protocol adapters that consume messages from one server (say, Kafka) and publish those messages to another server (say, Anypoint MQ).\n\nNow you can add a new **servers** property to [Channel Item Object](https://github.com/asyncapi/spec/blob/2021-09-release/spec/asyncapi.md#channel-item-object). It must be a list of server names provided as a string.\n\n```yaml\ndescription: This application publishes WebUICommand messages to an AMQP queue on RabbitMQ brokers in the Staging and Production environments.\nservers:\n  - rabbitmqBrokerInProd\n  - rabbitmqBrokerInStaging\nsubscribe:\n  message:\n    $ref: \"#/components/messages/WebUICommand\"\nbindings:\n  amqp:\n    is: queue\n```\n\nNames of servers must match the names of the servers defined in the [Servers Object](https://github.com/asyncapi/spec/blob/2021-09-release/spec/asyncapi.md#serversObject). This new property is optional, so moving from 2.1.0 to 2.2.0 is as easy as changing the specification version in your current AsyncAPI file. If **servers** is absent or empty, the given channel must be available on all servers defined in the Servers Object, like the previous version.\n\nFor more details, check out [this pull request](https://github.com/asyncapi/spec/pull/531).\n\nWe heard some community members asking for this feature. It was [Gerald Loeffler](https://www.linkedin.com/in/geraldloeffler/) that decided to champion the proposal and lead it until it got released. Thank you :pray:.\n\n## New protocol bindings\n\nThe specification is now extended to support the following custom protocols through the bindings feature:\n- **Anypoint MQ**, thanks to [Gerald Loeffler](https://www.linkedin.com/in/geraldloeffler/). For more details check out [this pull request](https://github.com/asyncapi/spec/pull/545) and [binding definition](https://github.com/asyncapi/bindings/tree/master/anypointmq).\n\n## Become a contributor\n\nPushing things through into the specification is not an easy process. It requires a lot of time and patience, but it is worth it. Have a look at our [contribution guide](https://github.com/asyncapi/spec/blob/master/CONTRIBUTING.md) and start contributing.\n\n## Conclusions\n\nAre you wondering how we managed to release 2.2.0 just three months after 2.1.0? I recommend you familiarize yourself with the [AsyncAPI release process](https://github.com/asyncapi/spec/blob/master/RELEASE_PROCESS.md). The next release is scheduled for January 2022. Later releases are in April, June and September, according to the agreed [release cadence](https://github.com/asyncapi/spec/blob/master/RELEASE_PROCESS.md#release-cadence).\n\n<img className=\"w-3/4\" src=\"/img/posts/release-notes-2.2.0/brace.webp\" alt=\"Meme showing a knight, Ned Stark from Game of Thrones. Description says: Brace yourself, all the stars in heaven say 3.0.0 version is coming.\" />\n\nDoes the above meme give you mixed feelings? Are you afraid of possible changes, or actually happy to see it coming? Don't overthink it! Join our [Slack](https://www.asyncapi.com/slack-invite) and talk to us, or check out the [3.0.0 milestone](https://github.com/asyncapi/spec/milestone/18).\n\n> Photo by <a href=\"https://unsplash.com/@jeremythomasphoto?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Jeremy Thomas</a> on <a href=\"https://unsplash.com/s/photos/autumn?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "Assigning channels to servers",
        "slug": "assigning-channels-to-servers",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "New protocol bindings",
        "slug": "new-protocol-bindings",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Become a contributor",
        "slug": "become-a-contributor",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Conclusions",
        "slug": "conclusions",
        "lvl": 2,
        "i": 3,
        "seen": 0
      }
    ],
    "slug": "/blog/release-notes-2.2.0",
    "filePath": "pages/blog/release-notes-2.2.0.md"
  },
  {
    "meta": {
      "type": "Engineering",
      "title": "The journey of documenting a Socket.IO API (Pt 1)",
      "date": "2021-09-23T09:00:00.000Z",
      "cover": "/img/posts/socketio-part1/cover.webp",
      "tags": [
        "Specification",
        "Socket.IO",
        "Protocol",
        "Asynction"
      ],
      "authors": [
        {
          "name": "Dimitrios Dedoussis",
          "photo": "/img/avatars/dedoussis.webp",
          "link": "https://twitter.com/dedoussis",
          "byline": "Senior Software Engineer at Babylon & Maintainer of Asynction"
        }
      ],
      "readingTime": 7,
      "excerpt": "This post originally appeared on https://dedouss.is\n\nMy recent adventures with Socket.IO took me off on a tangent, exploring the world of AsyncAPI as a means of documenting Socket.IO APIs. This is the"
    },
    "content": "\n> This post originally appeared on [https://dedouss.is](https://dedouss.is/posts/2021-06-24-documenting-socketio-part-1.html)\n\nMy recent adventures with [Socket.IO](https://socket.io/) took me off on a tangent, exploring the world of [AsyncAPI](https://www.asyncapi.com/) as a means of documenting Socket.IO APIs. This is the first part of a series of blog posts covering the modeling of the Socket.IO protocol using AsyncAPI objects, followed by a step-by-step tutorial on how to create a specification YAML file given an existing Socket.IO API.\n\n## Setting the scene\n\nEarlier this year my team undertook the task of re-implementing the backend of a realtime chat application – mentioning _re-implementing_ and _backend_ in the very first sentence is probably a PTSD trigger for many of you, but thankfully this post has nothing to do with rewriting-from-scratch horror stories. The app was originally built using a 3rd party push-notifications platform which allowed us to deliver a functional MVP in a relatively speedy manner. However, as new requirements started creeping in from the business, it was clear to the team that this 3rd party dependency was not really worth it anymore. We thus had to take the (arguably not so easy) decision to implement our own realtime API to gain complete control of each server connection. The design meeting would soon follow, to answer questions like _“What framework should we use?”_ or _“Would serverless make sense?”_. The stack of the team, namely Python, [Flask](https://flask.palletsprojects.com/) and [Kubernetes](https://kubernetes.io/), pointed us in the direction of [Flask-SocketIO](https://flask-socketio.readthedocs.io/), making Socket.IO the protocol of choice. Although pragmatic, this stack driven design approach felt very unorthodox. The tooling dictated the choice of the client<->server communication protocol rather than the other way around. It was a decision primarily based on the stack and the expertise of the backend team. What if the Socket.IO client library for Swift is not maintained anymore? What if Socket.IO is a very verbose protocol, not friendly for clients with limited network connectivity? Thankfully, this is not the case and Socket.IO happens to be a well supported and carefully designed protocol. Nonetheless, the decision was made and the development of a Socket.IO API was about to commence.\n\nIn the spirit of not repeating the sins of the past (i.e. not focusing on the client<->server interface), I started looking into how one can document a Socket.IO API. By document, I mean putting together some sort of spec or contract that can be agreed upon and shared with the consumers of the API. To my surprise, I couldn’t find a lot of resources on the topic. Coming from the REST world (where [OpenAPI](https://www.openapis.org/) is nowadays the de facto standard) and from the [GraphQL](https://graphql.org/) world (where everything is strictly typed), I found myself rather disappointed. It felt like the industry had been treating the documentation of event-driven APIs, such as Socket.IO or WebSocket ones, as a niche area not worth standardising. This felt odd, given how popular event-driven architectures had become over the past decade.\n\nAfter getting over the initial shock of this realisation, I finally managed to put together some properly worded google searches and came across [AsyncAPI](https://www.asyncapi.com/). Apparently, there is a growing community out there that serves this exact purpose of documenting event-driven APIs! Since 2017, the AsyncAPI folks have been developing a protocol agnostic specification for asynchronous APIs (inspired by OpenAPI), along with tooling such as spec parsers and code generators. Diving deeper into my google search, I looked for articles and tutorials on how one may express a Socket.IO API using the AsyncAPI specification. The only single resource I managed to find on the public cyberspace was [this](https://stackoverflow.com/a/45701602/10975573) (not very comprehensive) StackOverflow answer. It was at this point when I realised that I was on my own, facing the problem of modelling the Socket.IO protocol using the AsyncAPI semantics. I decided to take on the challenge and if successful, write a blog post documenting my journey. So here we are.\n\n## What is Socket.IO?\n\nBefore jumping to the AsyncAPI part of the problem, let’s first try to establish some common understanding of what Socket.IO is.\n\nMany would argue that Socket.IO is a library rather than a protocol. In fact, [its wikipedia entry](https://en.wikipedia.org/wiki/Socket.IO) defines Socket.IO as a JavaScript library for realtime web applications. However, I regard this as an outdated definition. I see Socket.IO as a protocol of its own, with a JavaScript library being the reference implementation. It is a protocol enabling duplex, event-driven communication, treating the underlying WebSocket and fallback HTTP long-polling mechanisms as an infrastructure layer that the user should never be bothered with. The protocol is implemented in various languages ([Java](https://github.com/socketio/socket.io-client-java), [Python](https://github.com/miguelgrinberg/python-socketio), [C++](https://github.com/socketio/socket.io-client-cpp) and [Rust](https://github.com/1c3t3a/rust-socketio) to name a few) and has an official specification sourced at <https://github.com/socketio/socket.io-protocol>.\n\nThe caveat is that a user of Socket.IO (client or server) should never interact with the protocol directly, but instead use the Socket class API of the respective implementation library. The Socket class implements the following symmetrical interface:\n\n- `socket.on(eventName, callback)`:\n  1. Registers a new handler (callback) for a given event.\n  1. Implements a subscribing operation.\n  1. The return value of the callback is sent to the sender party as an acknowledgement.\n- `socket.emit(eventName[, …args][, ack])`:\n  1. Emits an event to the receiver party.\n  1. Implements a publishing operation.\n  1. The `ack` callback is invoked only if the receiver returns an acknowledgment.\n\nA more advanced concept of Socket.IO is [Namespace](https://socket.io/docs/v4/namespaces/), which enables multiplexing capabilities. A Namespace has its own event handlers (and potentially its own dedicated connection). Socket.IO uses the main Namespace (`/`) by default, but it is possible to set up multiple custom Namespaces.\n\nAt this point one may wonder:\n\n> This is all great, but why do we even need to document a Socket.IO API?\n\nThe `eventName` granularity allows Socket.IO to dispatch messages (`args`) based on event names. This means that a Socket.IO server could be supporting any amount of custom event names per namespace. Also note that the event payload (`args`) along with the ACK (`callback` return value) can be of any type as long as it is serializable. Now imagine the very likely scenario of the Socket.IO client being developed from a completely separate team (or even company) to the one developing the server. How would the client know what namespaces and event names the server supports? And even if it was aware of the supported events, how would it know what data structures the server expects for each of those? Does the client need to acknowledge the messages it receives? If yes, what would be the structure of the acknowledgement payload? I wouldn’t want to live in a world where the answers to all of these questions would only be agreed verbally through some meeting. A piece of documentation should stand as the source of truth.\n\nNote that the scope of this documentation is limited to the interface between the client and the server, and does NOT cover the functionality of the server itself. Hence, we are not interested in server specific Socket.IO concepts such as [rooms](https://socket.io/docs/v4/rooms/index.html) or [broadcasting events](https://socket.io/docs/v4/broadcasting-events/).\n\n## What's next\n\nStay tuned for the next (and most exciting) part of this series which adds AsyncAPI into the equation. In the meantime, you can check out [Asynction](https://github.com/dedoussis/asynction), a python Socket.IO micro-framework driven by the AsyncAPI specification.\n\n_Special thanks to [derberq](https://twitter.com/derberq) and [alequetzalli](https://twitter.com/QuetzalliAle) for reviewing this post!_ 🙏\n\n> Photo by <a href=\"https://unsplash.com/photos/A4iL43vunlY\">Matt Howard</a> on <a href=\"https://unsplash.com/photos/A4iL43vunlY\">Unsplash</a>\n",
    "toc": [
      {
        "content": "Setting the scene",
        "slug": "setting-the-scene",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "What is Socket.IO?",
        "slug": "what-is-socketio",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "What's next",
        "slug": "whats-next",
        "lvl": 2,
        "i": 2,
        "seen": 0
      }
    ],
    "slug": "/blog/socketio-part1",
    "filePath": "pages/blog/socketio-part1.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Hackathon FAQ",
      "date": "2021-09-19T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Conference",
        "Hackathon"
      ],
      "cover": "/img/posts/hackathon-faq/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "excerpt": "Answers to all the questions you ever wanted to ask about the AsyncAPI Hackathon 2021",
      "readingTime": 5
    },
    "content": "\nLast year was the first time we hosted the AsyncAPI Conference. This year, we're going to host our first AsyncAPI Hackathon. This article tries to address the many questions coming from our community. 😀\n\n### When is the Hackathon?\n\n1st - 31st of October, 2021.\n\nWe wanted you to have an entire month to complete your idea. This way, you don't have to stress and overwork yourself over the weekend. Instead, enjoy a relaxed month and remember it's about having fun! 🤩 \n\n### What is the main theme for the Hackathon?\n\nThe goal of the Hackathon is to provide MVP solutions that can help AsyncAPI Community in ways like:\n\n- Ease education and getting started with the project.\n- Bring new AsyncAPI-related solutions that can solve the existing challenges the community is facing with event-driven architectures.\n- Extend existing tools, reuse them for some scenarios, and add the extra implementation on top.\n\n### Do I need to register for the event?\n\nNo, you do not need to register for the event. 🙂\n\nAnybody can join the Hackathon, whenever they want! No pressure, in case you realize you can't deliver what you had originally planned.\n\n### Is it a team competition or only for individuals?\n\nBoth.\n\nYou can work solo or form a team if you want! Just keep in mind that if you win with a team, the prize is divided amongst the entire team.\n\n### I want to participate, but I don't have a good idea\n\nNo worries, look at the ideas that [community members are sharing in our public community discussion thread](https://github.com/asyncapi/community/discussions/categories/asyncapi-hack-2021-ideas-brainstorming); you can pick one of them and/or get some inspiration. \n\n### Can there be multiple submissions with the same idea?\n\nYes.\n\nWe do not set any limits here. The same idea can be done by multiple teams. Just keep in mind that if there are two excellent submissions for the same idea, I doubt judges will vote for both to let other ideas shine, although this is not an official rule.\n\n### What is the scope of the submission? What does finishing my solution on time really mean?\n\n- Your solution must be fully open-sourced and stored in a repository under your GitHub profile. Please do not use Bitbucket or GitLab as it will increase complexity for our community members that will review submissions.\n- Your repository must have [an open source](https://choosealicense.com/) license. If it helps, at AsyncAPI Initiative we always use Apache 2.0 :wink:.\n- It cannot integrate with a commercial solution that has no free tier.\n- You must submit it before the deadline. Evaluation of the solution will not take into account any commits pushed to the repository after the deadline.\n\n### How do I submit my task?\n\nCreate a new discussion item [here](https://github.com/asyncapi/community/discussions/categories/asyncapi-hack-2021-submissions). Make sure there is:\n- Overview of what the solution is about.\n- Screenshots/Video/Diagrams/Code snippets (`anyOf` :wink:) that helps judges to quickly understand the solution and encourage them for further review.\n- Link to the repository where the full solution can be found.\n\nIf you win, you get to present your idea at our upcoming 2021 [AsyncAPI Conference in November](http://conference.asyncapi.com/).\n\n### How will solutions be scored?\n\nA selected group that will represent the community will review all solutions. They will be obligated to only provide YES comments for ideas they liked the most and explain why. Each judge has 3 votes. \n\nSubmissions and scores are public, and we reserve the right for judges to not make public NO comments, for the respect of all involved parties.\n\nThe solution with the highest score wins! 😀\n\n### How do I get help? Who can help with further understanding of AsyncAPI and the entire tooling landscape?\n\n- Join one of `Contributor First` meetings. These will be streamed throughout the entire month of October, 2021. Add this calendar with [Google Calendar format](https://calendar.google.com/calendar/embed?src=tbrbfq4de5bcngt8okvev4lstk%40group.calendar.google.com) or [iCal format](https://calendar.google.com/calendar/ical/tbrbfq4de5bcngt8okvev4lstk%40group.calendar.google.com/public/basic.ics).  The `Contributor First` meetings will take place every Wednesday, twice a day, at 8AM UTC and 4PM UTC.\n- Join our [Slack](https://www.asyncapi.com/slack-invite). We are a very friendly and responsive community.\n- Create an issue in [one of the repositories](https://github.com/asyncapi/) and explain what help you need.\n\n### What prizes are there?\n\n$5000 for the winner, $3000 for the runner-up, and $1000 for 3rd place.\n\nThere will also be additional swag-packs for other participants.\n\n### How do I get the winning prize money or swag?\n\nAfter the AsyncAPI Conference, you must submit an expense to Open Collective [here](https://opencollective.com/asyncapi/events/asyncapi-hackathon-and-conference-2021-3156d7af) with an invoice that indicates the amount of money you have won.\n\nFor swags, we will ask you directly to share your postal address with us that we will share with the agency responsible for swag-pack production.\n\n### Who owns the intellectual property (IP)?\n\nAsyncAPI Initiative doesn't claim the IP of submitted solutions. Nevertheless, we welcome projects donations. Contact us if you want to continue working on your submission further after the Hackathon, and you want to do it under the GitHub organization owned by the AsyncAPI Initiative.\n\n> Photo by <a href=\"https://unsplash.com/@emilymorter?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Emily Morter</a> on <a href=\"https://unsplash.com/s/photos/question-marks?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>",
    "toc": [
      {
        "content": "When is the Hackathon?",
        "slug": "when-is-the-hackathon",
        "lvl": 3,
        "i": 0,
        "seen": 0
      },
      {
        "content": "What is the main theme for the Hackathon?",
        "slug": "what-is-the-main-theme-for-the-hackathon",
        "lvl": 3,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Do I need to register for the event?",
        "slug": "do-i-need-to-register-for-the-event",
        "lvl": 3,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Is it a team competition or only for individuals?",
        "slug": "is-it-a-team-competition-or-only-for-individuals",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "I want to participate, but I don't have a good idea",
        "slug": "i-want-to-participate-but-i-dont-have-a-good-idea",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Can there be multiple submissions with the same idea?",
        "slug": "can-there-be-multiple-submissions-with-the-same-idea",
        "lvl": 3,
        "i": 5,
        "seen": 0
      },
      {
        "content": "What is the scope of the submission? What does finishing my solution on time really mean?",
        "slug": "what-is-the-scope-of-the-submission-what-does-finishing-my-solution-on-time-really-mean",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "How do I submit my task?",
        "slug": "how-do-i-submit-my-task",
        "lvl": 3,
        "i": 7,
        "seen": 0
      },
      {
        "content": "How will solutions be scored?",
        "slug": "how-will-solutions-be-scored",
        "lvl": 3,
        "i": 8,
        "seen": 0
      },
      {
        "content": "How do I get help? Who can help with further understanding of AsyncAPI and the entire tooling landscape?",
        "slug": "how-do-i-get-help-who-can-help-with-further-understanding-of-asyncapi-and-the-entire-tooling-landscape",
        "lvl": 3,
        "i": 9,
        "seen": 0
      },
      {
        "content": "What prizes are there?",
        "slug": "what-prizes-are-there",
        "lvl": 3,
        "i": 10,
        "seen": 0
      },
      {
        "content": "How do I get the winning prize money or swag?",
        "slug": "how-do-i-get-the-winning-prize-money-or-swag",
        "lvl": 3,
        "i": 11,
        "seen": 0
      },
      {
        "content": "Who owns the intellectual property (IP)?",
        "slug": "who-owns-the-intellectual-property-ip",
        "lvl": 3,
        "i": 12,
        "seen": 0
      }
    ],
    "slug": "/blog/hackathon-faq",
    "filePath": "pages/blog/hackathon-faq.md"
  },
  {
    "meta": {
      "type": "Engineering",
      "cover": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-15.webp",
      "title": "AsyncAPI vs OpenAPI: Answers to Your Burning Questions About Two Leading API Specs",
      "date": "2021-09-08T05:00:00.000Z",
      "tags": [
        "Specification",
        "OpenAPI"
      ],
      "authors": [
        {
          "name": "Jesse Menning",
          "photo": "/img/avatars/jmenning.webp",
          "link": "https://linkedin.com/in/jmenning",
          "byline": "CTO Architect at Solace"
        }
      ],
      "readingTime": 7,
      "excerpt": "AsyncAPI and OpenAPI are different ways of defining application programming interfaces (APIs), also commonly known as API specs. Both API specs serve a crucial role in defining and governing distribut"
    },
    "content": "\nAsyncAPI and OpenAPI are different ways of defining application programming interfaces (APIs), also commonly known as API specs. Both API specs serve a crucial role in defining and governing distributed computing systems, but AsyncAPI and OpenAPI are used for different styles of integration, as seen here:\n\n![Figure 1: How API specs AsyncAPI and OpenAPI map to different interaction patterns](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-01.webp)\n\n> This post [AsyncAPI vs OpenAPI: Answers to Your Burning Questions About the Two Most Popular API Specs](https://solace.com/blog/asyncapi-vs-openapi/) appeared first on [Solace](https://solace.com).\n\nThis post answers the following common questions about AsyncAPI vs OpenAPI and APIs in general…\n\n# What are Application Programming Interfaces (APIs)?\nApplication programming interfaces, or simply “APIs”, are a key part of modern programming that make it easier to exchange information between applications. APIs tell you what information an application expects to receive, and what information an application sends, without needing to know what the internal details of an application.\n\n![Figure 2: APIs provide the gateway into an application, but hide the messy details](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-02.webp)\n\nAs long as the API doesn’t change, different teams can invoke the application’s functionality without worrying about the messy details underneath. Because of this, separate teams can work independently on implementations.\n\n![Figure 3: APIs give developer teams more independence](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-03.webp)\n\n# When did APIs start?\nAPIs have been around for a while. For instance, the painful Simple Object Access Protocol (SOAP) used APIs in the early 2000s, but they really started getting interesting when representational state transfer (REST) came along. REST, which used the ubiquitous HTTP protocol, was lightweight and fun to work with.\n\nDid REST solve all the problems of SOAP by being lightweight, fun, and easy? Not quite, because it was a little too lightweight in some cases.\n\n# What is Swagger and how does it relate to REST APIs?\nThere was no great way to tell people in your company or a partner what needed to be in REST requests, and what they could expect as a reply. Whether the request needed a PUT or a POST was a constant source of confusion, and without a standard way of describing REST APIs, you had to resort to emailing.\n\n![Figure 4: Lack of a standard spec made REST APIs difficult to use](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-04.webp)\n\nSomething needed to happen. Swagger and WADL to the rescue! The goal of these competing standards was to standardize a way of documenting what a REST API looked like that was both readable by humans (somewhat, anyway) and could programmatically validate incoming requests and generate code.\n\n![Figure 5: Swagger provided a standard way to describe REST APIs](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-05.webp)\n\n# What happened to Swagger? And what is OpenAPI?\nThe Swagger specification was renamed OpenAPI in 2016 when the Linux Foundation acquired it from the fine folks at SmartBear. Somewhat confusingly, Swagger lives on as a toolset for creating and manipulating OpenAPI specs.\n\n![Figure 6: Swagger becomes OpenAPI](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-06.webp)\n\nImplementing OpenTelemetry typically means instrumenting code so that it can emit monitoring information. This information is then aggregated in a backend system, either on-premises or through monitoring as a service provider.\n\n# Are REST API and OpenAPI the same thing?\nThey are related but different. OpenAPI describes and documents how a REST API operates in a standard way so that it can be shared widely.\n\n![Figure 7: OpenAPI describes a REST API](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-07.webp)\n\n# Why do Microservices Architecture and IoT benefit from  Asynchronous Communications?\nMicroservices architecture is the new, cool kid on the street. Its purpose is to split up huge globs of code into tiny, manageable pieces, so different teams can work on them simultaneously.\n\nTypically, if a company wants to create something new, it glues different combinations of microservices together using REST calls. This method for microservices architecture worked… to an extent. People eventually realized that REST wasn’t always the best glue, and recognized the need for a new kind of glue that facilitated asynchronous communication.\n\n![Figure 8: Microservice architecture decomposes huge applications into tiny services](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-08.webp)\n\nEstablishing asynchronous communication between microservices makes them more reliable, faster, easier to scale, and more agile to adopt.  [Here’s a great video explaining why.](https://solace.com/resources/solace-microservices-resources/enhancing-microservices-with-events-video)\n\nThe internet of things also changed things up. My [coffee cup](http://www.ember.com/) is connected to the Internet now. Which is fantastic. But internet connected gadgets like cars and stoves and refrigerators don’t always have solid internet connections. Again, asynchronous communication seemed like a better way to connect.\n\n![Figure 9: The Internet of Things connects devices to Internet](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-09.webp)\n\nWith asynchronous communication, if a device is inaccessible, the information can be stored until it comes back online. Asynchronous communication can also help handle the surge of data than can come from connected devices. For example, think about all the coffee mugs firing up at 7am in the morning…\n\n# Why do Microservices Architecture and IoT benefit from  Asynchronous Communications?\nYou may be wondering why OpenAPI struggles with asynchronous APIs. Well, prior to version 3.1*, OpenAPI assumed two things:\n\n1. There is a single client connecting to a single server or application.\n2. The client requests something from the other server or application.\n\n*_(OpenAPI 3.1 introduces some async capablities through the ability to define webhooks)_\n\nAs you can see here, that only covers about 25% of the ways that APIs can be implemented.\n\n![Figure 10: OpenAPI doesn’t address several use cases- modified from Microservice Patterns by Chris Richardson](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-10.webp)\n\nAsynchronous communications do not satisfy those assumptions in numerous ways, but two stand out:\n\n- Information is frequently shared with many consumers at the same time.\n- In the case of one-way notifications, there may not be a request at all. With event-driven architecture, applications proactively send notifications about things that have occurred without being asked for that information.\n\n# How does AsyncAPI describe asynchronous APIs?\nWithout diving too deep, AsyncAPI adapts many of the core structures of OpenAPI to the asynchronous world. Rather than assuming that information flows in a request-reply style between a single client and server pair, messages are assigned to “channels” that many applications can send messages to, or receive messages from. If you want to learn more, check out the [primer on the AsyncAPI website](https://www.asyncapi.com/docs/getting-started).\n\n![Figure 11: AsyncAPI describes asynchronous APIs](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-11.webp)\n\nWith the combination of OpenAPI and AsyncAPI, many more API possibilities are covered, as you can see in this diagram:\n\n![Figure 12- The combination of OpenAPI and AsyncAPI covers modern use cases](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-12.webp)\n\n\n# Can an API gateway be asynchronous?\nThere’s no reason it can’t be, which is one of the reasons many companies are focusing more on evented API products, along the lines of more traditional API products. Companies like Slack are already letting outsiders use evented APIs.\n\n# If REST is all about HTTP, what protocols does AsyncAPI use?\nOne of the cool things about AsyncAPI is that you can use a variety of different protocols that are defined by “bindings”. Right now, there are AsyncAPI bindings for over a dozen protocols including Apache Kafka, AMQP, IBM MQ, MQTT, SNS, WebSockets, and JMS.\n\n![Figure 13: AsyncAPI covers a wide array of asynchronous protocols](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-13.webp)\n\n# How can I create an Asynchronous API with AsyncAPI?\nIf you want to see examples of how AsyncAPI can help you create an asynchronous API, there’s a great series with [WebSockets examples](https://www.asyncapi.com/blog/websocket-part1), and you can check out this [code generation example from Solace](https://solace.com/blog/asyncapi-codegen-microservices-using-spring-cloud-stream/). If you’re looking for how to create an AsyncAPI API from scratch, the easiest way is with the [AsyncAPI playground](https://playground.asyncapi.io/?load=https://raw.githubusercontent.com/asyncapi/asyncapi/master/examples/2.0.0/simple.yml).\n\n# What's next for API specs?\nAsyncAPI and OpenAPI are now both part of the Linux Foundation, which means:\n\n- Both are well supported and have a stable future\n- Both will be open standards with community governance\n- Both should continue to be integrated with open-source tooling and commercial products\n\n![Figure 14: OpenAPI and AsyncAPI are now roommates at Linux Foundation](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-14.webp)\n",
    "toc": [
      {
        "content": "What are Application Programming Interfaces (APIs)?",
        "slug": "what-are-application-programming-interfaces-apis",
        "lvl": 1,
        "i": 0,
        "seen": 0
      },
      {
        "content": "When did APIs start?",
        "slug": "when-did-apis-start",
        "lvl": 1,
        "i": 1,
        "seen": 0
      },
      {
        "content": "What is Swagger and how does it relate to REST APIs?",
        "slug": "what-is-swagger-and-how-does-it-relate-to-rest-apis",
        "lvl": 1,
        "i": 2,
        "seen": 0
      },
      {
        "content": "What happened to Swagger? And what is OpenAPI?",
        "slug": "what-happened-to-swagger-and-what-is-openapi",
        "lvl": 1,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Are REST API and OpenAPI the same thing?",
        "slug": "are-rest-api-and-openapi-the-same-thing",
        "lvl": 1,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Why do Microservices Architecture and IoT benefit from  Asynchronous Communications?",
        "slug": "why-do-microservices-architecture-and-iot-benefit-from--asynchronous-communications",
        "lvl": 1,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Why do Microservices Architecture and IoT benefit from  Asynchronous Communications?",
        "slug": "why-do-microservices-architecture-and-iot-benefit-from--asynchronous-communications",
        "lvl": 1,
        "i": 6,
        "seen": 1
      },
      {
        "content": "How does AsyncAPI describe asynchronous APIs?",
        "slug": "how-does-asyncapi-describe-asynchronous-apis",
        "lvl": 1,
        "i": 7,
        "seen": 0
      },
      {
        "content": "Can an API gateway be asynchronous?",
        "slug": "can-an-api-gateway-be-asynchronous",
        "lvl": 1,
        "i": 8,
        "seen": 0
      },
      {
        "content": "If REST is all about HTTP, what protocols does AsyncAPI use?",
        "slug": "if-rest-is-all-about-http-what-protocols-does-asyncapi-use",
        "lvl": 1,
        "i": 9,
        "seen": 0
      },
      {
        "content": "How can I create an Asynchronous API with AsyncAPI?",
        "slug": "how-can-i-create-an-asynchronous-api-with-asyncapi",
        "lvl": 1,
        "i": 10,
        "seen": 0
      },
      {
        "content": "What's next for API specs?",
        "slug": "whats-next-for-api-specs",
        "lvl": 1,
        "i": 11,
        "seen": 0
      }
    ],
    "slug": "/blog/openapi-vs-asyncapi-burning-questions",
    "filePath": "pages/blog/openapi-vs-asyncapi-burning-questions.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Hackathon and Conference - Get Yourself Ready",
      "date": "2021-08-30T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Conference",
        "Hackathon"
      ],
      "cover": "/img/posts/events2021/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Dev Comm Keeper"
        }
      ],
      "excerpt": "It is official! October is an AsyncAPI Hacking Fest! and November 16-18 a 2nd online AsyncAPI Conference",
      "readingTime": 2
    },
    "content": "\nAsyncAPI Community organizes two important events in the second half of 2021:\n\n- Hackathon in October\n- Online conference on November 16-18\n\nWe do not have the website ready yet. \n\nWe do not have the call for proposals opened yet. \n\nDon't worry though, all logistics are in progress.\n\n## What we do know so far\n\nWe do know these events will take place for sure!\n\n- Hackathon will be month-long, and there will be a prize for winners. Its goal is to provide [MVP](https://en.wikipedia.org/wiki/Minimum_viable_product) solutions that can help AsyncAPI Community in different ways:\n  - Ease education and getting started with the project\n  - Bring new AsyncAPI-related solutions to challenges the community has with event-driven architectures.\n  - Extend existing tools, reuse them in some scenarios, add the extra implementation on top\n- Conference will be 3 days long. The first day we will have a contributors summit where:\n  - Current maintainers can showcase projects that they maintain and explain how to contribute\n  - Google Summer of Code participants will be invited to showcase their projects\n  - We will explain in detail how to become a contributor\n- Day 2 and 3 of the conference setup highly depends on the number of proposals, source (vendors, tooling providers, or end-users), and topics.\n\n## What you can do already\n\n- Join detailed [discussion](https://github.com/asyncapi/community/discussions/categories/asyncapi-hack-conf-2021-organization) about the event!\n- Start talking to your employer. **We need some cash from sponsors** to give it away to the community and spend some on event marketing.\n- Start working on a proposal for a conference talk. The call for proposals is not yet officially opened, but you can already draft the initial proposal.\n- Start brainstorming on your hackathon project as it's only one month left for the event:\n  - You want to be part of it? Feel free to [discuss your idea with others](https://github.com/asyncapi/community/discussions/categories/asyncapi-hack-2021-ideas-brainstorming) if you are not sure it makes sense, \n  - You don't have time? That is fine, at least [drop your ideas](https://github.com/asyncapi/community/discussions/categories/asyncapi-hack-2021-ideas-brainstorming), maybe others will pick them up\n\nThat's all for now folks. Stay tuned!\n\n> Photo by <a href=\"https://unsplash.com/@samuelpereira?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Samuel Pereira</a> on <a href=\"https://unsplash.com/s/photos/conference?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>",
    "toc": [
      {
        "content": "What we do know so far",
        "slug": "what-we-do-know-so-far",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "What you can do already",
        "slug": "what-you-can-do-already",
        "lvl": 2,
        "i": 1,
        "seen": 0
      }
    ],
    "slug": "/blog/events2021",
    "filePath": "pages/blog/events2021.md"
  },
  {
    "meta": {
      "title": "Using JSON Schema Beyond Validation",
      "date": "2021-08-03T11:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "Code Generation",
        "JSON Schema"
      ],
      "cover": "/img/posts/json-schema-beyond-validation/halgatewood-com-QM9yzAoX-GQ-unsplash.webp",
      "authors": [
        {
          "name": "Jonas Lagoni",
          "photo": "/img/avatars/jonaslagoni.webp",
          "link": "https://github.com/jonaslagoni",
          "byline": "AsyncAPI Maintainer"
        }
      ],
      "readingTime": 7,
      "excerpt": "What is JSON Schema, why is it important and why is it so hard to use beyond validation? \nFor those unfamiliar with Asyncapi we use a superset of JSON Schema as the default format for defining operati"
    },
    "content": "\nWhat is JSON Schema, why is it important and why is it so hard to use beyond validation? \n\nFor those unfamiliar with Asyncapi [we use a superset of JSON Schema](https://www.asyncapi.com/docs/specifications/2.0.0#schemaObject) as the default format for defining operation payloads, headers, channel parameter schemas, etc.\n\nEven though formats such as Avro, OpenAPI 3.x and Swagger 2.x, RAML schemas, etc, are allowed in its place, as soon as it hits the parser (which most tooling utilizes), said formats are converted to [JSON Schema draft 7](https://json-schema.org/specification-links.html#draft-7) to ensure a [common structure for tooling](https://github.com/asyncapi/parser-js/blob/826b36922260254ba23d162cda309fc72f552c49/lib/models/message.js#L20). \n\nHowever, in tooling, many times you do not want to validate data, but to represent the data in a structured manner so it is easier to interact with, such as classes that represent a message payload. How can you achieve this with validation rules?\n\n## Quick intro to JSON Schema\n\nLet's try and take a look at an example. Given the following, I have defined a schema representing the validation rules that the data should comply with. \n\n<figure>\n  <img src=\"../img/posts/json-schema-beyond-validation/json-schema-process.webp\" title=\"JSON Schema validation process\" alt=\"Shows the overall JSON Schema validation process of how a JSON Schema and some data is validated against each other.\"/>\n  <figcaption className=\"text-center text-gray-400 text-sm\">Displays the overall process of validating data using JSON Schema.</figcaption>\n</figure>\n\nThe JSON Schema defines that the JSON data should be an object, which requires a property called `someRequiredProperty` to always be present and an optional property called `someOptionalProperty`. `someRequiredProperty` should validate against an integer and `someOptionalProperty` against an arbitrary string. The schema also dictates that no additional properties (`\"additionalProperties\": false`) may be allowed. There is also some metadata defined, called `$id` and `$schema`, but they are not important for this example.\n\nIf we then take a look at the example data instances (below the JSON Schema in the figure), the first one contains the required property, and the second one has both the required and the optional property.\n\nThe data and the JSON Schema can then together, validate whether the data is an instance of the schema, i.e., validate if the data comply with the validation rules and give a simple true or false statement if they are compatible.\n\nJSON Schema is an extremely powerful tool that allows you to create complex validation rules for data and is the standard specification used in not only AsyncAPI but also OpenAPI, however it has its challenges in tooling when used beyond validation.\n\n## Challenges using JSON Schema for data definitions\n\nMany of the JSON Schema keywords are for [JSON instance validation](https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01), which means specifying validation rules that data should comply with. However, what if you wanted to know the definition of the data rather than what it should validate against? \n\nThis is currently not something the JSON Schema specification provides to you, even though it is such an important part of tooling. First, let me show you how to interpret data definition from the above example for then to move into a more complex JSON Schema. \n\nInterpreting data definition from a JSON Schema is not always complex. For our previous example, I can almost interpret it as is. If I wanted a class in TypeScript that represented the data, it could look something like this (gonna use TS syntax as examples throughout). Notice how the `$id` keyword is used to define the naming of the class.\n\n```ts\nclass SomeIdForSchema {\n  public someRequiredProperty: number;\n  public someOptionalProperty?: string;\n}\n```\n\nIn theory, I use the very same validation rules and interpret them, such that the output gives us the definition of what form the data may take. Sounds easy enough right? :sweat_smile:\n\nThe problem is that JSON Schema –which might seem simple on the surface— is complex underneath when you start to interpret the recursive keywords such as `not`, `if`, `then`, `else`, `allOf`, `oneOf`, etc. This causes the possibilities to be endless in terms of how the JSON Schema document can be structured (at least endless in principle).\n\nIdeally, all keyword possibilities MUST be supported with no restrictions. So let's take a look at a more complex example, that introduces the `not` keyword. We aren't interested in why one would define something like this, but merely the possibility of doing so.\n\n```json\n{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"$id\": \"SomeIdForSchema\",\n  \"additionalProperties\": false,\n  \"properties\": {\n    \"someOptionalProperty\": {\n      \"type\": [\"string\", \"number\"]\n    } \n  },\n  \"not\": {\n    \"properties\": {\n      \"someOptionalProperty\": {\n        \"type\": \"number\"\n      } \n    }\n  }\n}\n```\n**Take a moment and think about what data would you say is valid against this schema?**\n\nIn the very simplest form the JSON Schema could be converted to the following:\n```json\n{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"$id\": \"SomeIdForSchema\",\n  \"additionalProperties\": false,\n  \"properties\": {\n    \"someOptionalProperty\": {\n      \"type\": \"string\"\n    } \n  }\n}\n```\nWhere the property `someOptionalProperty` may only be of type `string`. But, let's try and break the complex schema down step by step, to show how the validation would work against the data:\n```json\n{\n  \"someOptionalProperty\": \"string\"\n}\n```\nNotice how the `not` keyword reverses the validation result of step 5, which is why the inner schema is validated before the keyword itself.\n```json\n{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\", \n  \"type\": \"object\",               //Step 1 \n  \"$id\": \"SomeIdForSchema\", \n  \"additionalProperties\": false,  //Step 2 \n  \"properties\": { \n    \"someOptionalProperty\": {     //Step 3\n      \"type\": [\"string\", \"number\"]//Step 4\n    } \n  },\n  \"not\": {                        //Step 6\n    \"properties\": {\n      \"someOptionalProperty\": { \n        \"type\": \"number\"          //Step 5\n      } \n    }\n  }\n}\n```\n\n1. Step: accept, as the input is of type object.\n2. Step: accept, as no additional properties have been defined.\n3. Step: accept, as the property exists.\n4. Step: accept, as the property is of type string.\n5. Step: reject, as the property is of type string and not number.\n6. Step: accept (negate step 5), as the validation of the inner schema is negated. \n\nWith the `not` keyword it means that it is not only a matter of interpreting what form the data may take but also which it may not. If we had to represent a class for this Schema it would be the following:\n```ts\nclass SomeIdForSchema {\n  public someOptionalProperty?: string;\n}\n``` \n## The interpretation of JSON Schema\n\nSo, how can we create an algorithm that will enable us to consistently and accurately represent the underlying data model for the JSON data? How can this be standardized across all versions of JSON Schema (as we might not stay on Draft 7 forever)? \n\nSome of the alternatives to JSON Schema is specification such as [TypeSchema](https://typeschema.org/) or [JTD](https://datatracker.ietf.org/doc/html/rfc8927), that instead of focusing on validation, you focus on the definition of data models. Using these as the standard definition for payloads would indeed solve the problem in terms of data definitions in tooling. However, doing so neglect many important features of JSON Schema that simply cannot be done by defining the models, and we are left with the very same problem of transforming `JSON Schema -> TypeSchema` or `JSON Schema -> JTD`, which to some extent is the process we are trying to figure out.\n\nIn terms of the algorithm, it is highly work in progress :smiley: For [Modelina](https://github.com/asyncapi/modelina) we have our own process, but... It is something we are trying to solve collectively (as AsyncAPI is not the only one with this problem, [OAI, IBM](https://github.com/OAI/OpenAPI-Specification/issues/2542), etc) in the JSON Schema organization. \n\nTherefore I started a [discussion](https://github.com/json-schema-org/community/discussions/18) to trigger some initial thoughts on the subject and a [JSON Schema SIG](https://t.co/n20GalaIkI?amp=1) has been formed to tackle this problem.\n<center>\n<TwitterTweetEmbed\n  tweetId='1420774687328583680' \n  options={{\n    cards: 'hidden'\n  }}\n/>\n</center>\n\nThis blog post is as much a call for help as it is to enlighten you about the problem of using JSON Schema beyond validation. If you want to help tackle this problem, test the process, review changes, or make some kick-ass documentation, just reach out, cause we want your help! \n\n> Photo by <a href=\"https://unsplash.com/@halacious?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">HalGatewood.com</a> on <a href=\"https://unsplash.com/s/photos/cable?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n  \n",
    "toc": [
      {
        "content": "Quick intro to JSON Schema",
        "slug": "quick-intro-to-json-schema",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Challenges using JSON Schema for data definitions",
        "slug": "challenges-using-json-schema-for-data-definitions",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "The interpretation of JSON Schema",
        "slug": "the-interpretation-of-json-schema",
        "lvl": 2,
        "i": 2,
        "seen": 0
      }
    ],
    "slug": "/blog/json-schema-beyond-validation",
    "filePath": "pages/blog/json-schema-beyond-validation.md"
  },
  {
    "meta": {
      "title": "Mistake Odyssey",
      "Subtitle": "Git, Github, VS Code and Markdown for non-programmers",
      "date": "2021-07-15T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Git",
        "GitHub"
      ],
      "cover": "/img/posts/mistake-odyssey/mistake-odyssey-carolinie-cavalli.webp",
      "authors": [
        {
          "name": "Barbaño González",
          "photo": "/img/avatars/barbano.webp",
          "link": "https://www.linkedin.com/in/barbano-gonzalez-moreno",
          "byline": "AsyncAPI Press"
        }
      ],
      "excerpt": "Experience with Git, GitHub, VS Code and Markdown for non-developers within AsyncAPI.",
      "readingTime": 5
    },
    "content": "The human being for many centuries delegated the responsibility of preserving a great part of their culture, of the most precious information, in the capacity of keeping in their memory the data, the names, the places, the details...\n\nIn the Ancient Greece, Homer was the first to leave written traces of what until then were only remembered words, poems heard and recited from generation to generation. All this with the invaluable help of the muses. What a relief! He must have thought. What enormous risk and stress must have been in the atmosphere of those times. What would happen if amnesia came, the sudden loss of information. To forget is human. To err is human.\n\n## The age of error\n\nUndoubtedly, in our time, a recurring nightmare that we have all had is the one in which, after having done a work on our computer, just when we have to present it, a failure in the system makes everything written in the last minutes disappear... sometimes hours. Re-writing a previously written text is a hard exercise of memory, between frustration and despair. It will never be the same. Muses hardly come to the rescue. We are not Homer.\n\n<p align=\"center\">\n  <img src=\"https://media.giphy.com/media/12qZzOj2MkY26A/giphy.gif\" alt=\"animated\" />\n</p>\n\nSuch suffering could be avoided in an ideal, utopian world where we would all keep backup copies of our documents every second. But the reality is that neither the obsession with saving versions in the cloud or on external disks is infallible. The danger of losing a moment of inspiration is part of all of us. Some say that we live in the age of error. Some of them made by us, others by the machines.\n\nFor a writer or content creator, this nightmare can be especially hurtful, since the ability to write good texts and communicate information does not imply being an expert in computers or in the operation of the software that serves as a platform on which to shape texts.\n\n## Getting out the comfort zone\n\nWhen we are trained, we learn tools for our profession that we tend to hold on to tightly. Our first jobs are usually done with those initial tools and little by little we discover new ones that open up a world of infinite possibilities. Of course, it is not always easy to let go of the everyday to tackle new challenges with different methods. Homer first learned to recite by heart... at some point he would learn to write... and to read verses.\n\nSometimes opportunities appear when you least expect them. Thus AsyncAPI appeared in my life and the opportunity to contribute to this project arose. Initially it was an exciting and challenging idea in a totally unknown sector for me, coming from the world of communication. I began to familiarize myself with the concepts and objectives covered by the project and little by little I started to get into it until I came across new tools and working methods that were new to me. Outside my comfort zone, an incomprehensible world was opening up before me. Are there maps for the desert? Who brought me here? Why learn something new if I have already internalized the mechanisms of my previous work?\n\n## Learning from mistakes\n\nAsyncAPI is an open, free and collaborative project so the community needs to work with tools that allow working from transparency and horizontality creating an agile system. We are talking about Git, GitHub and VS Code, three free and open source software tools. \n\nWhen it comes to writing, the project relies on plain text, specifically the use of Markdown. It is considered a language that has the purpose of allowing the creation of content in a simple way of writing, and that at all times maintains a readable design. VS Code is the text editor in which we will work with Markdown. And then Git and GitHub conform the system that allows to store the information and easily retrieve it in case of loss, failure or error, as well as to consult the changes and revert them at any time.\n\nEvidently my immersion in these programs was for weeks an odyssey through the vast ocean of ignorance, or what is the same, an odyssey through the purest science of trial and error in which, apparently, there were only errors. Empirical learning is hard.\n\nFortunately AsyncAPI has a community that works as a great team, in it I found people who help me to dispel my doubts and solve my mistakes. I take this opportunity to thank you from these lines, especially [@anbreaker](https://github.com/anbreaker/) for your patience 😅.\n\n## The end of a nightmare \n\nMultidisciplinarity is increasingly on the rise. It has been amply demonstrated that the convergence of different disciplines in the same project achieves a more successful and impactful result. This peculiarity makes us get closer and closer to disciplines that work with different tools than the ones we are used to. \n\nBeyond the mistrust or distrust derived from leaving our comfort zones, all this can be approached as an opportunity for learning. Ultimately, we discover new tools that make our work easier and more productive. A treasure hunt. An unexpected return to Ithaca. The odyssey comes to an end.\n\nThe stress generated by the loss of information when writing is over for me. There is no concept of \"unrecoverable text\" in my new work environment thanks to the copies made by Git. There is a map where there are traces of everything that was done before. The nightmare has come to an end. We Homer wannabes can finally rest peacefully... waiting for the muses to arrive in our dreams.\n\n> Photo by <a href=\"https://unsplash.com/photos/yFaK9jgQeb4\">Carolinie Cavalli</a> on <a href=\"https://unsplash.com/photos/yFaK9jgQeb4\">Unsplash</a>\n",
    "toc": [
      {
        "content": "The age of error",
        "slug": "the-age-of-error",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Getting out the comfort zone",
        "slug": "getting-out-the-comfort-zone",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Learning from mistakes",
        "slug": "learning-from-mistakes",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "The end of a nightmare",
        "slug": "the-end-of-a-nightmare",
        "lvl": 2,
        "i": 3,
        "seen": 0
      }
    ],
    "slug": "/blog/mistake-odyssey",
    "filePath": "pages/blog/mistake-odyssey.md"
  },
  {
    "meta": {
      "title": "June 2021 at AsyncAPI",
      "date": "2021-07-09T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/june-2021-at-asyncapi/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "excerpt": "2.1.0 spec released, GSoC started, CLI released, other tools under heavy development. June was a hell of a ride.",
      "readingTime": 6
    },
    "content": "\n> Read [May 2021 at AsyncAPI](/blog/may-2021-at-asyncapi) for the update from May.\n\n<iframe src=\"https://anchor.fm/asyncapi/embed/episodes/June-2021-at-AsyncAPI-Initiative-e144cup\" height=\"102px\" width=\"400px\" frameborder=\"0\" scrolling=\"no\"></iframe>\n\n## Specification 2.1.0 release\n\nThe eagle has landed. The new version of the AsyncAPI specification is here. For more details, read [AsyncAPI Spec 2.1.0 Release Notes](https://www.asyncapi.com/blog/release-notes-2.1.0).\n\nFor more details on security improvements introduced into the spec by [Dale Lane](https://github.com/dalelane), read [this interactive article](https://dalelane.co.uk/blog/?p=4409).\n\nFor more details on new properties in examples, check out the demo of the latest version of Microcks where [Laurent Broudoux](https://github.com/lbroudoux) shows them in action in the new release:\n\n<YouTube id=\"ksYrvrqj8NI\" />\n\nA significant side effect of the release is that we automated the process of publishing the specification. Now [AsyncAPI Website](https://www.asyncapi.com/docs/specifications/v2.1.0) always reflects the latest version of specification document from [the spec repository](https://github.com/asyncapi/spec/blob/master/spec/asyncapi.md). Thank you [Aayush Kumar Sahu](https://github.com/aayushmau5) for the hard work.\n\nThe next release is scheduled for September. It is not decided if it is going to be a major or minor. It depends on the changes in the spec. Patch releases will be automatically released as 2.1.1 etc.\n\n## Google Summer of Code (GSoC) kicked off\n\nBy courtesy of [Postman](https://www.postman.com/) that agreed to list AsyncAPI-related ideas on their list of [GSoC](https://summerofcode.withgoogle.com/) ideas, the AsyncAPI Initiative entered the event a big time.\n\nIn June, we started at GSoC with five different project!\n\n### Diff\n\n[Aayush Kumar Sahu](https://github.com/aayushmau5) started working on [the AsyncAPI Diff library](https://github.com/asyncapi/diff). It will show differences between two different AsyncAPI files as a list of breaking and non-breaking changes. \n\nLater it will be used in AsyncAPI CLI and Studio. It will be a standalone library, browser compatible, so the community can also integrate it in other use cases.\n\n### Optimizer\n\n[Khuda Dad Nomani](https://github.com/KhudaDad414) started working on [the AsyncAPI Optimizer library](https://github.com/asyncapi/optimizer/). It is meant to optimize your AsyncAPI documents, such as finding duplications that can be changed into references or removing unused components. Very useful, especially for use cases where the AsyncAPI document is generated from code. \n\nLater it will be used in AsyncAPI CLI and Studio. It will be a standalone library, browser compatible, so the community can also integrate it in other use cases.\n\n### App Relations Discovery\n\n[Arjun Garg](https://github.com/asyncapi/app-relations-discovery) started working on [the AsyncAPI App Relations Discovery library](https://github.com/asyncapi/app-relations-discovery). It can discover relations between different applications in the system. As input, you provide a set of AsyncAPI documents provided for multiple applications.\n\nExcept of default map of relations you will be able to also get a diagram of relations. Some ready examples based on [this flight system use case](https://github.com/amadeus4dev/amadeus-async-flight-status):\n\n<Figure\n  src=\"/img/posts/june-2021-at-asyncapi/mermaid.webp\"\n  className=\"text-center\"\n  widthClass=\"w-1/2\"\n  caption=\"Figure 1: Flow diagram using Mermaid syntax.\"\n/>\n\n<br/>\n\n<Figure\n  src=\"/img/posts/june-2021-at-asyncapi/plantuml.webp\"\n  className=\"text-center\"\n  widthClass=\"w-1/2\"\n  caption=\"Figure 2: Class diagram using PlantUML syntax.\"\n/>\n\n### Simulator aka Fluffy Robot\n\n[Nektarios Fifes](https://github.com/NektariosFifes) started working on [the AsyncAPI Simulator](https://github.com/asyncapi/fluffy-robot). It is a library that can simulate real traffic against your system basing on provided AsyncAPI documents and initial information of the traffic that should be generated. As a result, you will get a set of statistics.\n\n### ChatBot\n\n[Ace](https://github.com/AceTheCreator) started research on implementing a [ChatBot](https://github.com/asyncapi/chatbot) that could help new AsyncAPI users to create first AsyncAPI documents. Throughout a conversation with a bot, you would get a generated AsyncAPI document in return.\n\n## New CLI released\n\nThe initial version of the [AsyncAPI CLI](https://github.com/asyncapi/cli) is finally here :rocket:.\n\n[Jorge Aguiar Martín](https://twitter.com/jotamusik) finished his hard work on initial setup of the CLI with first initial feature for AsyncAPI documents validation:\n\n<Figure\n  src=\"/img/posts/june-2021-at-asyncapi/cli.webp\"\n  className=\"text-center\"\n/>\n\nThe next features are on their way. Feel free to join and work on it together with us.\n\n## Modelina supports Go\n\nOur model generation library is under heavy development. I want to explicitly mention one change among all the recent changes in [Modelina](https://github.com/asyncapi/modelina/releases). [Sergio Moya](https://github.com/smoya) enabled support for model generation for Go :muscle: It is a 4th language that is supported by the library.\n\n```js\nconst { GoGenerator} = require(\"@asyncapi/modelina\")\n\nconst generator = new GoGenerator();\n\nconst doc = {\n  $id: \"Address\",\n  type: \"object\",\n  properties: {\n    street_name:    { type: \"string\" },\n    city:           { type: \"string\", description: \"City description\" },\n    house_number:   { type: \"number\" },\n    marriage:       { type: \"boolean\", description: \"Status if marriage live in given house\" },\n    pet_names:      { type: \"array\", items: { type: \"string\" } },\n    state:          { type: \"string\", enum: [\"Texas\", \"Alabama\", \"California\", \"other\"] },\n  },\n  required: [\"street_name\", \"city\", \"state\", \"house_number\", \"state\"],\n};\n\nasync function generate() {\n  const models = await generator.generate(doc);\n  models.forEach(function (model) {\n    console.log(model.result);\n  }); \n}\n\ngenerate();\n\n//outputs\n\n/*\n// Address represents a Address model.\ntype Address struct {\n  StreetName string\n  City string\n  HouseNumber float64\n  Marriage bool\n  PetNames []string\n  State *State\n}\n// State represents an enum of string.\ntype State string\n*/\n```\n\nYou can also try out this code on [RunKit](https://runkit.com/derberg/runkit-npm-asyncapi-modelina).\n\n## React component vs HTML template and where are we\n\n[React component](https://github.com/asyncapi/asyncapi-react) is still under development towards 1.0.0 release. Keep in mind that we are already using release candidates in the [HTML template](https://github.com/asyncapi/html-template), and you can give it a try too:\n\n```\nnpm install --save @asyncapi/react-component@v1.0.0-next.11\n```\n\nIn June, a couple of release candidates were released. Most important to notice is a new standalone bundle that makes it super easy to reuse React component in [Angular](https://github.com/asyncapi/asyncapi-react/blob/next/docs/usage/angular.md) and [Vue](https://github.com/asyncapi/asyncapi-react/blob/next/docs/usage/vue.md) projects. In addition, we now provide not only **cjs** but also **esm** and **umd** modules. As a result, it is much easier to use React component with [Next.js](https://github.com/asyncapi/asyncapi-react/blob/next/docs/usage/nextjs.md) projects. In addition, the component supports the whole specification, except **discriminator**.\n\nFew more items left for the official 1.0.0 release:\n- Custom theming that is [right behind the corner](https://github.com/asyncapi/asyncapi-react/pull/374)\n- Components extensibility\n- New playground aka editor that will be available as a standalone package and used by use in a new AsyncAPI Studio (new AsyncAPI Playground)\n\nIf you are interested in more details, follow the [release milestone](https://github.com/asyncapi/asyncapi-react/milestone/20) and the work done by [Maciej Urbanczyk](https://github.com/magicmatatjahu).\n\n## Jobs\n\nIf you missed it, we have a [Jobs](/jobs) board on our website where different companies can share opportunities involving working with AsyncAPI. There are 4 open positions at the moment.\n\n<Figure\n  src=\"/img/posts/june-2021-at-asyncapi/jobs.webp\"\n  className=\"text-center\"\n/>\n\nWe also generate an [RSS feed](https://www.asyncapi.com/jobs/rss.xml), so you can subscribe for notifications on new jobs only.\n\n## Good learning materials\n\nJune was super rich in good learning content. Below you can find a list of all the articles and videos, but I'd like to explicitly point you to this [kids book about Kafka](http://www.gentlydownthe.stream/):\n\n- [Designing your APIs with AsyncAPI (Part 1)](https://www.asyncapi.com/blog/designing_your_apis_with_asyncapi_part_1)\n- [Simulating CloudEvents with AsyncAPI and Microcks](https://developers.redhat.com/articles/2021/06/02/simulating-cloudevents-asyncapi-and-microcks)\n- [AsyncAPI and Its Horizontal Working System](https://dzone.com/articles/asyncapi-and-its-horizontal-working-system)\n- [The journey of documenting a Socket.IO API (Pt 1)](https://dedouss.is/posts/2021-06-24-documenting-socketio-part-1.html)\n\n<YouTube id=\"PPeRnEaqBW8\" />\n\n> Photo by <a href=\"https://unsplash.com/@lazyartistgallery?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Rahul Pandit</a> on <a href=\"https://unsplash.com/s/photos/may?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "Specification 2.1.0 release",
        "slug": "specification-210-release",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Google Summer of Code (GSoC) kicked off",
        "slug": "google-summer-of-code-gsoc-kicked-off",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Diff",
        "slug": "diff",
        "lvl": 3,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Optimizer",
        "slug": "optimizer",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "App Relations Discovery",
        "slug": "app-relations-discovery",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Simulator aka Fluffy Robot",
        "slug": "simulator-aka-fluffy-robot",
        "lvl": 3,
        "i": 5,
        "seen": 0
      },
      {
        "content": "ChatBot",
        "slug": "chatbot",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "New CLI released",
        "slug": "new-cli-released",
        "lvl": 2,
        "i": 7,
        "seen": 0
      },
      {
        "content": "Modelina supports Go",
        "slug": "modelina-supports-go",
        "lvl": 2,
        "i": 8,
        "seen": 0
      },
      {
        "content": "React component vs HTML template and where are we",
        "slug": "react-component-vs-html-template-and-where-are-we",
        "lvl": 2,
        "i": 9,
        "seen": 0
      },
      {
        "content": "Jobs",
        "slug": "jobs",
        "lvl": 2,
        "i": 10,
        "seen": 0
      },
      {
        "content": "Good learning materials",
        "slug": "good-learning-materials",
        "lvl": 2,
        "i": 11,
        "seen": 0
      }
    ],
    "slug": "/blog/june-2021-at-asyncapi",
    "filePath": "pages/blog/june-2021-at-asyncapi.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Spec 2.1.0 Release Notes",
      "date": "2021-06-29T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Release Notes",
        "Specification"
      ],
      "cover": "/img/posts/release-notes-2.1.0/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "excerpt": "The eagle has landed! Check out all the changes the AsyncAPI specification introduces in the new v2.1.0 release",
      "readingTime": 4
    },
    "content": "\nThe last AsyncAPI release (2.0.0) took place on the 11th of September, 2019. In 2020 the focus went into growing community and adoption and stabilization of basic tooling for specification. This year was a year of \"formalizm\" 😃 aka getting into the foundation, setting up governance model and contribution guide to enable work on next spec release. We are good to go forward. The 2.1.0 release is out in the wild 🎉\n\n## Message examples object extended with additional fields\n\nThanks to work done by [Laurent Broudoux](https://github.com/lbroudoux), you can now clearly describe message examples. New properties **name** and **summary** are optional. These properties help not only to properly describe the example in documentation but make it easier to work with mocking and testing tools (like [microcks](https://microcks.io/)), so you can better identify what example to use for mocking and what it does.\n\nExample of new properties added to existing [WebSocket example for Gemini API](https://github.com/asyncapi/spec/blob/v2.1.0/examples/websocket-gemini.yml):\n\n<CodeBlock highlightedLines={[10,11,25,26]}>\n{`components:\n  messages:\n    marketData:\n      summary: Message with marked data information.\n      description: |\n        The initial response message will show the existing state of the order book. Subsequent messages will show all executed trades, as well as all other changes to the order book from orders placed or canceled.\n      payload:\n        $ref: '#/components/schemas/market'\n      examples:\n        - name: updateMessage\n          summary: Example of an update message that contains a change in price information.\n          payload:\n            type: update\n            eventId: 36902233362\n            timestamp: 1619769673\n            timestampms: 1619769673527\n            socket_sequence: 661\n            events:\n              - type: change\n                side: bid\n                price: '54350.40'\n                remaining: '0.002'\n                delta: '0.002'\n                reason: place\n        - name: heartbeatMessage\n          summary: Example of additional heartbeat message when you enable them. \n          payload:\n            type: heartbeat\n            socket_sequence: 1656`}\n</CodeBlock>\n\nRendering of new example properties in React component and HTML template:\n\n<Figure\n  src=\"/img/posts/release-notes-2.1.0/ui.webp\"\n/>\n\nFor more details, check out [this pull request](https://github.com/asyncapi/spec/pull/534).\n\n## New protocol bindings\n\nThe specification is now extended to support the following custom protocols through the bindings feature:\n- **Mercure**, thanks to [Kévin Dunglas](https://github.com/dunglas). At the moment, no specific bindings are necessary for this protocol. For more details, check out [this pull request](https://github.com/asyncapi/spec/pull/278) and [binding definition](https://github.com/asyncapi/bindings/tree/master/mercure).\n- **IBM MQ**, thanks to [Dale Lane](https://github.com/dalelane) and [Richard Coppen](https://github.com/rcoppen). For more details check out [this pull request](https://github.com/asyncapi/spec/pull/537) and [binding definition](https://github.com/asyncapi/bindings/tree/master/ibmmq).\n\n## Custom schema formats mandatory vs recommended\n\nSupport for Avro and OpenAPI schemas changed from mandatory to recommended through contribution from [Fran Mendez](https://github.com/fmvilas). For more details, check out [this pull request](https://github.com/asyncapi/spec/pull/289)\n\n## New security schemes\n\nThanks to [Dale Lane](https://github.com/dalelane), you can now describe secured Kafka clusters with SASL security schemes (**scramSha256**, **scramSha512**, **gssapi**). For more details, check out [this pull request](https://github.com/asyncapi/spec/pull/502).\n\n## Old new defaultContentType property in root object\n\nWe used and supported **defaultContentType** property to specify the default content type when encoding/decoding a message's payload. [Lucas Block](https://github.com/BlockLucas) spotted that we do not have it defined in the specification. For more details, check out [this pull request](https://github.com/asyncapi/spec/pull/419).\n\n## Tooling support\n\nThe following official AsyncAPI tools are already updated to support 2.1.0 version of the specification:\n- JSON Schema that supports validation of AsyncAPI documents is updated in [this](https://github.com/asyncapi/asyncapi-node) repository. Also **@asyncapi/specs** package has been updated on NPM to version 2.8.0, and it contains the 2.1.0 JSON Schema.\n- [JavaScript Parser](https://github.com/asyncapi/parser-js/) uses latest **@asyncapi/specs** package and can be used to parse and validate 2.1.0 documents. Upgrade to 1.7.0 version.\n- [AsyncAPI Generator](https://github.com/asyncapi/generator/) uses the latest **@asyncapi/parser** package, so while generating output, it can validate 2.1.0 documents. Upgrade to 1.8.0 version\n- [Generator filters](https://github.com/asyncapi/generator-filters) functions **getPayloadExamples** and **getHeadersExamples** support new message example properties. Upgrade to 2.0.0 version.\n- [React component](https://github.com/asyncapi/asyncapi-react/) supports rendering of new message example properties. Upgrade to v1.0.0-next.10 version.\n- [Markdown template](https://github.com/asyncapi/markdown-template) supports rendering of new message example properties. Upgrade to 0.14.0 version.\n- [HTML template](https://github.com/asyncapi/html-template) uses the latest **@asyncapi/react-component** package. Upgrade to 0.23.0 version.\n- [JavaScript Converter](https://github.com/asyncapi/converter-js/) enables conversion from any AsyncAPI version into the 2.1.0 version of the spec. Upgrade to 0.5.0 version.\n- [Modelina](https://github.com/asyncapi/modelina) now also accepts AsyncAPI documents valid against the 2.1.0 version of the spec. Upgrade to 0.16.0 version.\n\n\nLast but not least is the AsyncAPI Playground. Check new playground that uses latest HTML template and Markdown template with [this example](https://playground.asyncapi.io/?url=https://raw.githubusercontent.com/asyncapi/spec/v2.1.0/examples/websocket-gemini.yml).\n\nBig thanks to [Maciej Urbanczyk](https://github.com/magicmatatjahu) and [Jonas Lagoni](https://github.com/jonaslagoni/) for updating most relevant tooling.\n\nThis is not all! Not only official AsyncAPI tools are updated. Thanks to [Laurent Broudoux](https://github.com/lbroudoux) also [Microcks](https://microcks.io/) now supports version 2.1.0 and its new example's properties. Upgrade to 1.3.0 version.\n\n## Thank you\n\nI want to send a special thank you to [Aayush Kumar Sahu](https://github.com/aayushmau5), who helped us to automate the part of the release responsible for updating the specification Markdown document on the AsyncAPI website, right after triggering the release, even the release candidate. Thank you :bow:.\n\n> Photo by <a href=\"https://unsplash.com/@dougswinson?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Doug Swinson</a> on <a href=\"https://unsplash.com/s/photos/landing-eagle?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>",
    "toc": [
      {
        "content": "Message examples object extended with additional fields",
        "slug": "message-examples-object-extended-with-additional-fields",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "New protocol bindings",
        "slug": "new-protocol-bindings",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Custom schema formats mandatory vs recommended",
        "slug": "custom-schema-formats-mandatory-vs-recommended",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "New security schemes",
        "slug": "new-security-schemes",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Old new defaultContentType property in root object",
        "slug": "old-new-defaultcontenttype-property-in-root-object",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Tooling support",
        "slug": "tooling-support",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Thank you",
        "slug": "thank-you",
        "lvl": 2,
        "i": 6,
        "seen": 0
      }
    ],
    "slug": "/blog/release-notes-2.1.0",
    "filePath": "pages/blog/release-notes-2.1.0.md"
  },
  {
    "meta": {
      "title": "May 2021 at AsyncAPI",
      "date": "2021-06-22T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/may-2021-at-asyncapi/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "excerpt": "We have JSON Schemas for bindings and some great community tools, one that was donated to AsyncAPI Initiative",
      "readingTime": 4
    },
    "content": "\n> Read [April 2021 at AsyncAPI](/blog/april-2021-at-asyncapi) for the update from April.\n\n<center><iframe src=\"https://anchor.fm/asyncapi/embed/episodes/May-2021-at-AsyncAPI-Initiative-e1369a9\" height=\"102px\" width=\"400px\" frameborder=\"0\" scrolling=\"no\"></iframe></center>\n\n## JSON Schemas for the bindings\n\nAsyncAPI is protocol agnostic. It doesn't mean that you cannot specify some protocol-specific information in the AsyncAPI document. It is possible through a **bindings** feature. In different parts of the AsyncAPI document, you can provide specific details for Kafka, MQTT, and other protocols. Definitions of bindings are maintained separately from the main AsyncAPI specification in the [bindings repository](https://github.com/asyncapi/bindings).\n\nThe current challenge with bindings is that they are hard to validate because they are written in Markdown, human-readable form only. Support in tooling is also pretty limited because of this. We had to start maintaining the JSON Schema, as we do with the main AsyncAPI specification. \n\nThanks to a monumental effort from [Khuda Dad Nomani](https://github.com/KhudaDad414) I'm proud to say that all 15 bindings now have their JSON Schemas. So for example [Kafka binding](https://github.com/asyncapi/bindings/tree/master/kafka) has its [JSON Schemas](https://github.com/asyncapi/bindings/tree/master/kafka/json_schemas). The next step is to figure how to link these JSON Schemas with the main AsyncAPI specification JSON Schema and support it in parsers.\n\nFor more details, have a look at [this issue](https://github.com/asyncapi/spec/issues/507) and help us out to drive it further.\n\n> Bindings are getting more and more adoption and interest. Many interesting discussions are happening that are shaping the bindings feature. I highly recommend joining them, like, for example, the debate started by [Ian Cooper](https://github.com/iancooper) to get [consistency between protocol configurations using bindings](https://github.com/asyncapi/bindings/issues/62).\n\n## InfoQ Architecture and Design 2021\n\nI don't think I need to write more than you can spot in this tweet :smiley:. 2021 is very generous for AsyncAPI.\n\n<TwitterTweetEmbed\n  tweetId='1391701921312948227'\n  options={{\n    width: 500,\n    align: 'center'\n  }}\n/>\n\n## Assigning channels to servers\n\nI want to suggest you pay attention to the proposal from [Gerald Loeffler](https://github.com/GeraldLoeffler) that introduces a way to [assign a channel to a specific server](https://github.com/asyncapi/spec/pull/531). This proposal would enable you to have a single AsyncAPI document with multiple different servers supporting different protocols. You could specify that your application is subscribed to channel A on the Kafka server and that it publishes messages to Channel B on the MQTT server.\n\nIt is a feature that many asked for in the past. Please jump into the discussion. Even if you have no comments, then at least leave some emoji, so we know it was viewed and what people have an opinion.\n\n## VSCode Plugin\n\n[Iván García Sainz-Aja](https://github.com/ivangsa) donated to AsyncAPI Initiative the plugin he developed for the VSCode to enable you to preview AsyncAPI documents using our HTML template directly in the IDE. We need to do some cleanup and rebranding now, and then we will be ready with further development.\n\nAny help will be highly appreciated, so please check out [the repository](https://github.com/asyncapi/vs-asyncapi-preview).\n\n## New AsyncAPI-related tools\n\nWe have new tools on [our list](https://www.asyncapi.com/docs/community/tooling) of tools created by the AsyncAPI Community:\n- [EventBridge Atlas](https://github.com/boyney123/eventbridge-atlas) from [David Boyne](https://github.com/boyney123)\n> It parses AWS EventBridge schemas into documentation solutions, shows rules matched to your events, adds metadata to each event property, support slate, AsyncAPI, and docuowl output, and more...\n- [Asynction](https://github.com/dedoussis/asynction) from [ Dimitrios Dedoussis](https://github.com/dedoussis)\n> The purpose of Asynction is to empower a specification first approach when developing SocketIO APIs in Python\n\n## Tests coverage tracking in tooling\n\nTo increase the quality of our tools now and maintain it in the future, we started exploring tools for tracking test coverage. We integrated [Coveralls](https://coveralls.io/) with the [Modelina](https://github.com/asyncapi/modelina) project.\n\n<Figure\n  src=\"/img/posts/may-2021-at-asyncapi/coverage.webp\"\n  className=\"text-center\"\n/>\n\n[Jonas Lagoni](https://github.com/jonaslagoni) that actively maintains the library gave Coveralls a score of 8 out of 10. Now we need to roll it out to other projects. If you were looking for some good first issue to start contributing to AsyncAPI, then [this issue](https://github.com/asyncapi/.github/issues/30) is a good one.\n\n> Modelina is a data models generator that supports AsyncAPI and JSON Schema. Its goal is to make it easier to write code generators. Jonas released many improvements in May and still does, so it is best to try it out now and provide feedback.\n\n## Slack reorganization\n\nWe are growing fast, and it was the right time to do some reorg in our Slack workspace to get some structure, clean up, and properly structure discussions. In the end, yes, we are still using Slack because we got accepted as an exceptional organization and received **Standard** subscription for free :heart:.\n\nAll the official Slack channels are listed below:\n\n<Figure\n  src=\"/img/posts/may-2021-at-asyncapi/slack.webp\"\n  widthClass=\"w-1/2\"\n  className=\"text-center\"\n/>\n\nI think that actually, the most important thing is that we defined our first version of the [Slack etiquette](https://github.com/asyncapi/.github/blob/master/slack-etiquette.md).\n\n> Photo by <a href=\"https://unsplash.com/@lazyartistgallery?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Rahul Pandit</a> on <a href=\"https://unsplash.com/s/photos/may?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "JSON Schemas for the bindings",
        "slug": "json-schemas-for-the-bindings",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "InfoQ Architecture and Design 2021",
        "slug": "infoq-architecture-and-design-2021",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Assigning channels to servers",
        "slug": "assigning-channels-to-servers",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "VSCode Plugin",
        "slug": "vscode-plugin",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "New AsyncAPI-related tools",
        "slug": "new-asyncapi-related-tools",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Tests coverage tracking in tooling",
        "slug": "tests-coverage-tracking-in-tooling",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Slack reorganization",
        "slug": "slack-reorganization",
        "lvl": 2,
        "i": 6,
        "seen": 0
      }
    ],
    "slug": "/blog/may-2021-at-asyncapi",
    "filePath": "pages/blog/may-2021-at-asyncapi.md"
  },
  {
    "meta": {
      "title": "Designing your APIs with AsyncAPI (Part 1)",
      "date": "2021-06-01T11:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "Code Generation",
        "API Design"
      ],
      "cover": "/img/posts/jonaslagoni-miniseries-part1/blog-miniseries-cover.webp",
      "authors": [
        {
          "name": "Jonas Lagoni",
          "photo": "/img/avatars/jonaslagoni.webp",
          "link": "https://github.com/jonaslagoni",
          "byline": "AsyncAPI Maintainer"
        }
      ],
      "readingTime": 10,
      "excerpt": "How can you utilize code generation to speed up the development process and only focus on what is important - the business logic? In this miniseries, I will explore the ways AsyncAPI and code generati"
    },
    "content": "\nHow can you utilize code generation to speed up the development process and only focus on what is important - the business logic? In this miniseries, I will explore the ways AsyncAPI and code generation can work hand in hand beyond generating documentation.\n\nStructure of the miniseries:\n* **Part 1: Designing your APIs with AsyncAPI**\n* Part 2: Implementing your applications using code generation\n* Part 3: Black-box testing the applications using code generation\n* Part 4: Introducing new changes when using code generation\n* Part 5: The path to 1 billion players - Scaling the applications and finding bottlenecks with tooling\n\n> Don't see this blog post series as anything other than an example workflow. This is purely how I do it with my applications and how I use AsyncAPI and its tooling to my advantage. Use this as an inspiration to finding an approach that works for you.\n\n# Backstory\n\nBack in 2019 when I started contributing to the tooling of AsyncAPI, I was still in university studying for a master's in software engineering and had at that point been a student developer at a company called [EURISCO](http://eurisco.dk/), for about 3 years. Besides that, I have always had side projects that I worked on in my spare time, and it was one of these side projects that sparked my need for AsyncAPI. \n\nMy side project at that time was a [Rust](https://rust.facepunch.com/) game server plugin that collected in-game events, such as when a player farms resources, kills another player, loots a container, etc, and send them to a backend. Later these could be extracted by an API to display the player's progression and detailed account of what the player did on the game server. \n\nInitially, I used OpenAPI to describe the REST API, and the community tooling allowed me to generate clients and servers in different languages, which accelerated the implementation process.\n\nI soon encountered a use case that required me to push data to the game server, and solving this with REST was possible but cumbersome. So I started exploring different alternatives in terms of event-driven architecture. However, none could be described using OpenAPI removing tooling, so I had to find alternatives. \n\nThat was when I vaguely remembered a meeting in the company where AsyncAPI was mentioned. Around that time, we began to switch from a custom socket protocol to [NATS](https://nats.io/) and spend some time figuring out how to mainstream the process for both documenting and generating code for the APIs. This was where we had found AsyncAPI and started adopting the specification.\n\nSo I started to look into AsyncAPI for my project, which sparked my first ever contribution to an open-source project, but that is a story for another time, maybe.\n\nSo this blog post is a dedication to that experience, showcasing how I use AsyncAPI to document and generate code to speed up the development process and maybe spark your interest in helping us build the best tooling possible.\n\n# To that end\n\nExplaining something is always better with actual examples, therefore I will be creating a little system to show you how code generation can support the development process. \n<figure>\n  <img src=\"/img/posts/jonaslagoni-miniseries-part1/blog-miniseries-general-setup.webp\" title=\"General setup of the project\"/>\n  <figcaption className=\"text-center text-gray-400 text-sm\">The general setup of the project, with the two applications game server and processor. The round dot between \"some broker\" and the applications represent how others may grab/interact with the application, ergo its API.</figcaption>\n</figure>\n\nI will be creating a system of two applications, a **game server** and a **processor** using a micro-service architecture with no public-facing API. How a player interacts with the **game server** could be through a phone, a computer, Xbox, or PlayStation. I only care about the interaction between the **game server** and the **processor** in this blog post. \n\nThe **game server** will produce the following events: when players join the server, pick up items in-game, uses the chat, hit one another, and eventually disconnect. It will be implemented to simulate players at random intervals joins the server, perform the different actions, and eventually disconnect to provide a sense of realism. \n\nThe backend **processor** will be consuming these events to process them. In this series, I will not do anything particular with the data. The **Processor** will simply save the received events directly to a database.\n\nI will not get into the specifics of the stack for this system yet since it does not affect the writing of the API documents for the two applications.\n\n# Designing the APIs with AsyncAPI\n\nWhen starting designing the application APIs I always use the [design first principle](https://apisyouwonthate.com/blog/api-design-first-vs-code-first), even when we are talking about internal systems.\n## The game server\n\nI always start with the basics and define all the different channels for which the **game server** should produce events over.\n\n```yaml\nasyncapi: 2.0.0\ninfo: \n  title: \"Game server\"\n  version: \"0.0.1\"\nchannels: \n  game/server/{serverId}/events/player/{playerId}/item/{itemId}/pickup:\n    description: Channel used when a player picks up an item in-game\n  game/server/{serverId}/events/player/{playerId}/connect:\n    description: Channel used when a player joins (connect to) the game server\n  game/server/{serverId}/events/player/{playerId}/disconnect:\n    description: Channel used when a player leaves (disconnects from) the game server\n  game/server/{serverId}/events/player/{playerId}/chat: \n    description: Channel used when a player writes something in chat\n  game/server/{serverId}/events/player/{playerId}/hit: \n    description: Channel used when a player hit another player in-game\n```\n\nAsyncAPI channels have a different meaning based on the underlying setup. For brokers such as [Apache Kafka](https://kafka.apache.org/), this is referred to as `topics`. \n\nHowever, regardless of the underlying setup, channels must be defined as a [RFC 6570 URI template](https://www.asyncapi.com/docs/specifications/2.0.0#channelsObject). \n\nThe way I like to structure my channels is to utilize parameters to separate the action from information about the event, so it describes, on what server the event was performed `{serverId}`, by what player `{playerId}` and in case of **pickup**, what item `{itemId}` gets picked up. For the last part of the channel, I describe what event it was, **pickup**, **connect**, **disconnect**, etc.\n\nNext I define the actual definition of the channels, and here I will focus on explaining the channel `game/server/{server_id}/events/player/{player_id}/item/{item_id}/pickup`. The full AsyncAPI document can be found [here](https://github.com/jonaslagoni/asyncapi-miniseries/blob/master/AsyncAPI/GameServer.yaml).\n\n```YAML\n...\n  game/server/{serverId}/events/player/{playerId}/item/{itemId}/pickup:\n    description: Channel used when a player picks up an item in-game\n    parameters:\n      serverId: \n        description: The id of the server the action was performed on\n        schema: \n          type: string\n      playerId: \n        description: The id of the player who performed the action\n        schema: \n          type: string\n      itemId: \n        description: The id of item picked up\n        schema: \n          type: string\n    subscribe: \n      message:\n        payload:\n          type: object\n          properties:\n            pickupTimestamp:\n              type: string\n              format: date-time\n              description: The timestamp the item was picked up\n          $id: PlayerItemPickupPayload\n          additionalProperties: false\n...\n```\nFirst, I have the definition of **parameters** used in the channel. **serverId** tells us where the action originates from, the **playerId** tells us who performed the action, and the **itemId** tells us which item was picked up and should all validate against a value with type **string**.\n\n<figure>\n  <img src=\"/img/posts/jonaslagoni-miniseries-part1/blog-miniseries-gameserver-api.webp\" title=\"Game server setup\"/>\n  <figcaption className=\"text-center text-gray-400 text-sm\">Displays the game server API as it is described with AsyncAPI with version 2.0.0. The round dot between \"some broker\" and the game server represent how others may grab/consume the produced event from the game server.</figcaption>\n</figure>\n\nNext, we have the **subscribe** operation, which might not make much sense at first glance. I do want the **game server** to publish this event, right?\n\nAnd you would be correct, but this is how you currently define operations in AsyncAPI. You define the operation others may interact with. This means that the **game server** publishes on this channel and others may **subscribe** to it \\[[1](#view-property)\\]\\[[3](#clarify-view)\\]. If you want a more detailed explanation, I suggest reading Nic Townsend's post about [Demystifying the Semantics of Publish and Subscribe](https://www.asyncapi.com/blog/publish-subscribe-semantics). \n\nThe **payload** of the channel (is described using a super-set of JSON Schema draft 7) should validate against an **object** which contains the property **pickupTimestamp**, which should validate against a **string**. When **additionalProperties** is **false**, no extra properties may be added to the object (by default this is **true** in JSON Schema draft 7). The **$id** keyword is used as an identifier for that specific schema, in this case, I name the object schema **PlayerItemPickupPayload**.\n\n## The backend processor\n\nNext, I design the **processor** API, which contains all the same channels as the **game server**, but with a different operation keyword. \n\n<figure>\n  <img src=\"/img/posts/jonaslagoni-miniseries-part1/blog-miniseries-processor-api.webp\" title=\"Processor setup\"/>\n  <figcaption className=\"text-center text-gray-400 text-sm\">Displays the processor API as it is described with AsyncAPI with version 2.0.0. The round dot between \"some broker\" and the processor represent how others may grab/provide events that the processor subscribes to.</figcaption>\n</figure>\n\nThis is again because I need to define how others may interact with our **processor**. This means that instead of using the `subscribe` operation I use `publish` to tell others that they can publish to this channel since the backend **processor** is subscribing to it. The full AsyncAPI document for the **processor** can be found [here](https://github.com/jonaslagoni/asyncapi-miniseries/blob/master/AsyncAPI/Processor.yaml).\n\n```yaml\n...\n  game/server/{serverId}/events/player/{playerId}/item/{itemId}/pickup:\n    ...\n    publish: \n      ...\n...\n```\n\n## Introducing reusability\n\nAt the moment, each of the AsyncAPI documents contains its definition of the channels. But what if I were to add a new validation rule such as a new property to the **playerItemPickupPayload** schema? In this case, I would have to change this for both applications, which is way too much work :smile:\n\nTherefore, we can introduce **$ref** to separate the parameters and messages into smaller sections for reusability. I will be placing all separate components into a [\"components\" directory](https://github.com/jonaslagoni/asyncapi-miniseries/tree/master/AsyncAPI) in the same directory the AsyncAPI documents reside.\n\nJust a quick note, at the moment, it is not possible to reuse channels and operations directly between the two applications. Therefore we can only apply this to the parameters and message individually while keeping some duplicate information \\[[2](#channel-reusability)\\]. \n\nFirst, I separate the different parameters. For simplicity, I add all of them into the same file `./components/Parameters.yaml`.\n\n```yaml\nserverId:\n  description: The id of the server\n  schema: \n    type: string\nplayerId:\n  description: The id of the player who performed the action\n  schema: \n    type: string\nitemId:\n  description: The id of the item\n  schema: \n    type: string\n```\n\nAnd then change all the channel parameters to reference the external parameter definition.\n```yaml\n...\n  game/server/{serverId}/events/player/{playerId}/item/{itemId}/pickup:\n    description: Channel used when a player picks up an item in-game\n    parameters:\n      serverId: \n        $ref: \"./components/Parameters.yaml#/serverId\"\n      playerId: \n        $ref: \"./components/Parameters.yaml#/playerId\"\n      itemId: \n        $ref: \"./components/Parameters.yaml#/itemId\"\n    ...\n...\n```\n\nFor the messages, I add a new file per message instead of keeping everything in the same file as parameters. I use this approach since I find it easier to maintain and extend.\n\nWe add the message file `./components/messages/PlayerItemPickup.yaml`\n```yaml\npayload:\n  type: object\n  properties:\n    pickupTimestamp:     \n      type: string\n      format: date-time\n      description: The timestamp the item was picked up\n  $id: PlayerItemPickupPayload\n  additionalProperties: false\n```\n\nand alter the channel definition for the **game server** to:\n```yaml\n...\n  game/server/{serverId}/events/player/{playerId}/item/{itemId}/pickup:\n    description: Channel used when a player picks up an item in-game\n    parameters:\n      serverId: \n        $ref: \"./components/Parameters.yaml#/serverId\"\n      playerId: \n        $ref: \"./components/Parameters.yaml#/playerId\"\n      itemId: \n        $ref: \"./components/Parameters.yaml#/itemId\"\n    subscribe: \n      message:\n        $ref: './components/messages/PlayerItemPickup.yaml'\n...\n```\n\nThese changes are applied to the **processor** as well. You can find all the AsyncAPI files [here](https://github.com/jonaslagoni/asyncapi-miniseries/tree/master/AsyncAPI).\n# What's next\nNow, that the APIs are designed for two applications, we can move on to the fun part, implementing the applications using code generation.\n\n# Related issues\n\nIf you are interested in jumping into our discussions and being part of the community that drives the specification and tools, I have referenced some of the outstanding issues and discussions related to the different aspects I have referenced in the post.\n1. [Add a View property to the info section to change the perspective of subscribe and publish operations](https://github.com/asyncapi/spec/issues/390) <a name=\"view-property\"></a>\n2. [Reusing channel definitions across files is hard](https://github.com/asyncapi/spec/issues/415) <a name=\"channel-reusability\"></a>\n3. [Confusions with the Publish and Subscribe meaning/perspective](https://github.com/asyncapi/spec/issues/520) <a name=\"clarify-view\"></a>\n\n> Cover photo by [David Jakab](https://www.pexels.com/@david-jakab-283330?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels) from [Pexels](https://www.pexels.com/photo/galleon-ship-photo-under-the-cloudy-sky-1050656/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)\n  \n  \n\n",
    "toc": [
      {
        "content": "Backstory",
        "slug": "backstory",
        "lvl": 1,
        "i": 0,
        "seen": 0
      },
      {
        "content": "To that end",
        "slug": "to-that-end",
        "lvl": 1,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Designing the APIs with AsyncAPI",
        "slug": "designing-the-apis-with-asyncapi",
        "lvl": 1,
        "i": 2,
        "seen": 0
      },
      {
        "content": "The game server",
        "slug": "the-game-server",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "The backend processor",
        "slug": "the-backend-processor",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Introducing reusability",
        "slug": "introducing-reusability",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "What's next",
        "slug": "whats-next",
        "lvl": 1,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Related issues",
        "slug": "related-issues",
        "lvl": 1,
        "i": 7,
        "seen": 0
      }
    ],
    "slug": "/blog/designing_your_apis_with_asyncapi_part_1",
    "filePath": "pages/blog/designing_your_apis_with_asyncapi_part_1.md"
  },
  {
    "meta": {
      "type": "Engineering",
      "cover": "/img/posts/async_standards_compare/devops-specs_pic-01.webp",
      "title": "AsyncAPI, CloudEvents, OpenTelemetry: Which Event-Driven Specs Should Your DevOps Include?",
      "date": "2021-05-25T05:00:00.000Z",
      "tags": [
        "OpenTelemetry",
        "Specification",
        "EDA",
        "CloudEvents"
      ],
      "authors": [
        {
          "name": "Jesse Menning",
          "photo": "/img/avatars/jmenning.webp",
          "link": "https://linkedin.com/in/jmenning",
          "byline": "CTO Architect at Solace"
        }
      ],
      "readingTime": 7,
      "excerpt": "A decade ago, event-driven architecture was the wild west. Documentation? It’s in a spreadsheet somewhere. Where did the event go? Here’s a list of ten logs to search through. How do we make sure even"
    },
    "content": "\nA decade ago, event-driven architecture was the wild west. Documentation? It’s in a spreadsheet somewhere. Where did the event go? Here’s a list of ten logs to search through. How do we make sure events from System A can be understood by System B? Slap some headers on the message and hope that they make it across the event broker.\n\n> This post [AsyncAPI, CloudEvents, OpenTelemetry: Which Event-Driven Specs Should Your DevOps Include?](https://solace.com/blog/asyncapi-cloudevents-opentelemetry-event-driven-specs-devops/) appeared first on [Solace](https://solace.com).\n\nThankfully, the increased adoption of event-driven and distributed architectural patterns has meant increased attention to related open-source specifications. With solidifying specifications, standardized instrumentation and reusable tooling has emerged as well. Becoming event-driven today involves less guess work and more assurance of compatibility.\n\nBut which specifications matter? And how should they be used?\n\n![Figure 1- Progression from ad hoc solutions to event-driven/asynchronous standards](/img/posts/async_standards_compare/devops-specs_pic-01.webp)\n\nWithin the event-driven ecosystem, there are three major emerging specifications: CloudEvents, OpenTelemetry and AsyncAPI. Each of them map to phases of the DevOps lifecycle, and address a distinct challenge with event-driven development and/or implementation. Used together, they can make event-driven DevOps easier to implement.\n\n![Figure 2- High-level mapping of specifications to DevOps lifecycle](/img/posts/async_standards_compare/devops-specs_pic-02.webp)\n\nHere’s a summary of where each of the specifications fits, I will examine each more in depth later:\n\n![Table 1- Comparison Table](/img/posts/async_standards_compare/comparison_table.webp)\n\nIn addition to different portions of the DevOps lifecycle, the three specifications focus on different challenges and objects within the event-driven landscape:\n\nThere is some overlap between the three, particularly as the specifications mature and expand. There are areas where two specifications cover the same ground in different ways, so it’s up to architects to determine how best to allocate functionality.\n\n# Async API\n\nParticularly in API-first methodologies, the DevOps “Plan” phase revolves around defining the application programming interface (API). The API describes what messages an application can accept and emit. The APIs can then be used to build the application, advertise its capabilities to others and document its functionality.\n\nHowever, defining an interface requires having a standard way of describing it that can be 1) used by many different programming languages, 2) leveraged by multiple tools and 3) read (at least sort of) by humans. In the synchronous world, OpenAPI does this work. For event-driven applications, AsyncAPI tries to do the same thing. It offers a parallel to the OpenAPI specification, but with modifications to allow for asynchronous, event-driven behavior. You can see the parallel for yourself in the structure of the specifications:\n\n![Figure 3- OpenAPI vs AsyncAPI (via AsyncAPI](/img/posts/async_standards_compare/devops-specs_pic-03.webp)\n\nIn addition to the Plan phase, AsyncAPI also has emerging capabilities for other phases (shown in grey above):\n\n* **Code:** A [code-generator for Spring Cloud Stream](https://github.com/asyncapi/java-spring-cloud-stream-template) takes an AsyncAPI definition and creates skeleton code, reducing the need to laboriously create boilerplate code. More code generators are planned. And vice-versa, there are [code-first tools](https://www.asyncapi.com/docs/community/tooling#code-first-tools) at that will generate an AsyncAPI spec out of numerous popular languages.\n* **Test:** The [partnership between AsyncAPI and Postman](https://www.asyncapi.com/blog/asyncapi-partners-with-postman) highlights the increased ability to test async flows once they are well defined.\n* **Deploy:** Technology-specific [bindings](https://github.com/asyncapi/bindings/) defined within the spec can be used to establish connections and subscriptions to event brokers upon deployment.\n* **Operate:** Once messages are flowing at runtime, an AsyncAPI document can be used to ensure schema compliance with tools like [Node.js AsyncAPI Validator](https://github.com/WaleedAshraf/asyncapi-validator)\n\n# CloudEvents\n\nAs more technologies become event-driven, ensuring that they all communicate effectively becomes challenging.\n\nFor example: An equipment failure occurs at a manufacturing plant, generating an event. The attached IoT device publishes a message containing the alert event to an MQTT server. At the end of the journey, the event lands in a Kafka topic, is pushed to a websocket, and is sent to a function as a service using an HTTP webhook.\n\nContextual information about the event is crucial for all the consumers, but every consumer could expect it in a different place, with a different naming convention and a different format. Some producers might even choose not to include a key piece of metadata.\n\nTo resolve these challenges, enterprises have traditionally created their own custom envelope: standards about what meta information is included in messages and in what format. But many applications don’t comply, either because they are outside the organization, it’s a legacy app that’s too pricey to retrofit, or because they use a protocol that hasn’t been included in the standard.\n\nThe workaround is typically tedious and error-prone – manual mapping of metadata. This additional step can mean using data transformation software to enrich messages.  And in cases where information is missing, you either have messy data generation or make do without it.\n\n![Figure 5- CloudEvents focuses on event meta data interoperability.](/img/posts/async_standards_compare/devops-specs_pic-05.webp)\n\nCloudEvents aims to eliminate the metadata challenge by specifying mandatory metadata information (like event source and type of event) into what could be called a standard envelope. The fields are then mapped to individual messaging protocols like Kafka, MQTT and HTTP, so there’s no question about where the fields exist on each message. Most importantly, there’s wide support for different programming languages.\n\nThere is an overlap between CloudEvents and AsyncAPI, as noted by AsyncAPI’s founder. The metadata fields used by CloudEvents could be defined within an AsyncAPI schema. However, there is an advantage to using CloudEvents in addition to AsyncAPI. CloudEvent libraries are available for multiple programming languages for multiple protocols, which streamlines interoperability. For instance, a Java developer can utilize a CloudEvents SDK to publish CloudEvents compliant messages to Kafka, without having to worry about the underlying metadata implementation.\n\n![Figure 6- CloudEvents mapped to DevOps lifecycle. Less mature capabilities in grey](/img/posts/async_standards_compare/devops-specs_pic-06.webp)\n\nAnd as an evolving standard being used by major SaaS and cloud providers, CloudEvents is gaining both momentum and functionality. In addition to the Operate phase, now that the core specification has been released, the group’s focus has turned to several extensions that address other stages and address other event-driven challenges:\n\n* **Plan:** Discovery capability allows new and existing applications to query a catalog of services for available events using a standardized API.\n* **Deploy:** Subscription manager capability allows applications to subscribe to events using a standardized API.\n\n### OpenTelemetry\n\nIn contrast to AsyncAPI and CloudEvents, which address producing and consuming events themselves, OpenTelemetry focuses on end-to-end monitoring of those events. OpenTelemetry standardizes the creation and management of trace information, which can reveal the path of a single event through multiple applications, or show the aggregate metrics that combine multiple events.\n\n![Figure 7- Graphical representation of trace from OpenTelemetry backend](/img/posts/async_standards_compare/devops-specs_pic-07.webp)\n\nImplementing OpenTelemetry typically means instrumenting code so that it can emit monitoring information. This information is then aggregated in a backend system, either on-premises or through monitoring as a service provider.\n\nOnce completed, OpenTelemetry helps to answer the classic event-driven question “Where’s my event?” By including business-related fields in the trace, it’s possible to search by, say, the order number of the original event, and have its entire path through multiple applications revealed.\n\n![Figure 8 – OpenTelemetry mapped to DevOps lifecycle](/img/posts/async_standards_compare/devops-specs_pic-08.webp)\n\n### Conclusion\n\nIt’s a great time for event-driven architecture. Challenges that used to be overcome in different ways in every implementation are now being addressed by standard, open-source solutions. While OpenTelemetry, AsyncAPI and CloudEvents do have overlapping capabilities, they are distinct enough to all warrant a place in your DevOps processes.\n\nIf you have more questions or want to share your experience with these standards, you can let us know in the [AsyncAPI Slack](https://asyncapi.com/slack-inviteyou) or the [Solace Community Forum](http://solace.community/). \n",
    "toc": [
      {
        "content": "Async API",
        "slug": "async-api",
        "lvl": 1,
        "i": 0,
        "seen": 0
      },
      {
        "content": "CloudEvents",
        "slug": "cloudevents",
        "lvl": 1,
        "i": 1,
        "seen": 0
      },
      {
        "content": "OpenTelemetry",
        "slug": "opentelemetry",
        "lvl": 3,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Conclusion",
        "slug": "conclusion",
        "lvl": 3,
        "i": 3,
        "seen": 0
      }
    ],
    "slug": "/blog/async_standards_compare",
    "filePath": "pages/blog/async_standards_compare.md"
  },
  {
    "meta": {
      "title": "From API-First to Code Generation - A WebSocket Use Case",
      "date": "2021-05-19T05:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "WebSocket",
        "Code Generation"
      ],
      "cover": "/img/posts/websocket-part3/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "excerpt": "Learn how to go from API design to code generation. Create a WebSocket API for ChatBot. All supported by AsyncAPI",
      "readingTime": 20
    },
    "content": "\n>  This is the last article of WebSocket series. I recommend you read [WebSocket, Shrek, and AsyncAPI - An Opinionated Intro](/blog/websocket-part1) and [Creating AsyncAPI for WebSocket API - Step by Step](/blog/websocket-part2) first.\n\nIn my previous articles from the WebSocket series, I introduced you to WebSocket topic and explained how you would describe your WebSocket API using AsyncAPI specification.\n\nWhat was the point of doing it anyway? Why learning the specification?\n\n<Figure\n  src=\"/img/posts/websocket-part3/meme-newspec.webp\"\n  widthClass=\"w-1/2\"\n  className=\"text-center\"\n/>\n\nJust to document your API? Nah, that would be a huge waste of time. Like seriously, would you learn a new specification only to describe the API for documentation purposes? Please don't. You could do so much more with it.\n\nLook at the list of [all the tools](https://www.asyncapi.com/docs/community/tooling) built for AsyncAPI. There are many ahead of us, but the current list already explains what can be done with AsyncAPI. You can validate your messages in real-time in your application with [asyncapi-validator](https://github.com/WaleedAshraf/asyncapi-validator) or mock and test your application with [Microcks](https://microcks.io/). You can also generate code by picking one of [the official templates](https://github.com/asyncapi/generator#list-of-official-generator-templates). In this article, I will focus on the aspect of code generation.\n\n## API-First vs Code-First\n\nDesigning API first and then coding later is not an easy shift. For a coder, it is easier just to code and focus on code aspects. And this is just fine. That is how humans work. We do what we learned and focus on making things good and maintainable. Different tasks require different skills, and it is ok that not everybody has them. Designing API requires a different look on the subject, being more flexible and abstract. You need a wider perspective, forget about implementation details, and think about the user first.\n\nDo you need the specification to design API?\n\nNo, but specification makes the design process and feedback loop easier to handle and faster. If backed by good tools, of course.\n\nWhat is wrong with generating AsyncAPI from code?\n\nEven though I'm an author of many memes like those in this article, I'm actually far from judging. It all depends on your project, architecture, and even the work environment. \n\n<Figure\n  src=\"/img/posts/websocket-part3/meme-blame.webp\"\n  widthClass=\"w-1/2\"\n  className=\"text-center\"\n/>\n\nIn the end, I think there is a wrong assumption that if you generate spec from code, it means you did not think about API design and your users. \n\nEven AsyncAPI [tooling list](https://www.asyncapi.com/docs/community/tooling) stigmatize tools that allow you to generate spec from the code as code-first tools. Who said you couldn't do both things in parallel. \n\nI just realized this topic could continue and evolve into a dedicated article, so let me do a full stop here. \n\nMy goal is to educate you on:\n- Designing a WebSocket API with multichannel, with one message each. In other words, I want to show you something opposite to my previous articles where you could see a WebSocket API that has one channel but with multiple different messages.\n- Performing code generation that enables you to focus on business logic only.\n\nI'll try to come back into **API-First vs Code-First** topic in the summary of the article.\n\n## ShrekApp\n\nI know that in [this article](/blog/websocket-part1), I wrote that I would not try to model a Shrek application. Since the moment I wrote I will not do it, I immediately started thinking about doing it :smiley: So here I am, showing you a possible use case for AsyncAPI with WebSocket protocol basing on Shrek. I shamefully admit I do it mainly to make sure my head moves on and thinks about something other than Shrek :smiley:\n\n## Write AsyncAPI document\n\n> You can see entire AsyncAPI document [here](https://github.com/derberg/shrekapp-asyncapi-designed/blob/main/asyncapi.yaml)\n\nThere are several questions you need to ask yourself when designing an API:\n- What is the name of the API?\n- What is the purpose of the API?\n- What is the version of the API?\n- How user can connect with the API and over what protocol?\n- What messages can your user receive from and send to your API?\n- On what channels are these messages available?\n- What is the structure of these messages? What is the schema?\n\nThese are basic questions that can be reflected in the AsyncAPI document.\n\nIn case you didn't notice, these questions are user-oriented. Your AsyncAPI document must describe what users can do with your application and not what it does. It makes a difference.\n\n### Info\n\nI'm designing a **ShrekApp**, release under 1.0.0 version. Its purpose is to enable chat with a chatbot trained to behave like Shrek. I want to use [Wit.ai](https://wit.ai) as a platform for training the bot that gives me a REST API to talk to the bot.\n\n```yml\ninfo:\n  title: Shrek App\n  version: '1.0.0'\n  description: |\n    Purpose of this app is to have some fun with AsyncAPI and WebSocket and define an interface for ... Shrek.\n\n    ![](https://media.giphy.com/media/10Ug6rDDuG3YoU/giphy-downsized.gif)\n\n    You can use this API to chat with Shrek bot or to get updates about artifical travels to different locations.\n```\n\n### Servers\n\nThe communication with the application goes over the WebSocket protocol. For now, it is not publicly hosted. You can run it locally and therefore connect through **localhost** only.\n\n```yml\nservers:\n  swamp:\n    url: localhost\n    protocol: ws\n```\n\n### Channels\n\nThere are two separate entry points for the user to interact with the API:\n- `chat` where bi-directional communication is possible to enable real-time conversation with the bot\n- `travel/status` where user can subscribe for a stream of updates on different travels, like for example:\n    ```yml\n      destination: Far far away\n      distance: Beyond the seven mountains and seven forests\n      arrival: Pretty soon\n    ```\n\nExcept for basic information like the purpose of messages, pub/sub operations, and messages schema, it is good to specify **operationId** that is unique across the entire AsyncAPI document and helps to generate human-readable functions' names.\n\n> In the below example, you can see a usage of **components** section and schema definitions. I don't want to explain those sections in detail here as I did it already in the [Creating AsyncAPI for WebSocket API - Step by Step](/blog/websocket-part2) article.\n\n```yml\n#\n# Details about all the channels that user can listen to or send to messages\n#\nchannels:\n  /chat:\n    subscribe:\n      summary: Client can receive chat messages.\n      operationId: subChatMessage\n      message:\n        $ref: '#/components/messages/chatMessage'\n    publish:\n      summary: Client can send chat messages.\n      operationId: pubChatMessage\n      message:\n        $ref: '#/components/messages/chatMessage'\n  /travel/status:\n    subscribe:\n      summary: Client can receive travel info status.\n      operationId: subTravelInfo\n      message:\n        $ref: '#/components/messages/travelInfo'\n\n#\n# All reusable parts for readability and staying DRY\n#\ncomponents:\n  messages:\n    chatMessage:\n      summary: Message that you send or receive from chat\n      payload:\n        type: string\n    travelInfo:\n      summary: Message that contains information about travel status.\n      examples:\n        - payload:\n            destination: Far far away\n            distance: Beyond the seven mountains and seven forests\n            arrival: Pretty soon\n      payload:\n        type: object\n        properties:\n          destination:\n            description: Name of travel destination.\n            type: string\n          distance:\n            description: How much distance left to the target.\n            type: string\n          arrival:\n            description: Time left to get there.\n            type: string\n```\n\n### Final document\n\nYou can see the entire AsyncAPI document for ShrekApp always up to date [here](https://github.com/derberg/shrekapp-asyncapi-designed/blob/main/asyncapi.yaml)\n\nThe AsyncAPI document I just created is not very complicated as this way it will be easier to understand the generated code. Most important is for you to notice that all information about your application is expressed in the AsyncAPI document, and once you do it, options for the next steps are just endless.\n\n## Generate Code\n\nIt is time now to generate some code that enables you to focus just on the business logic.\n\n### AsyncAPI Generator\n\nThe AsyncAPI Initiative maintains the [AsyncAPI Generator](https://github.com/asyncapi/generator/), a tool that enables you to generate anything you want out of an AsyncAPI document. [Generator](https://www.asyncapi.com/generator) provides several features that make it much easier to provide so-called **templates**. The template is a standalone project that defines what files should be rendered by the Generator as a final output.\n\nWe have many templates on our [list](https://github.com/asyncapi/generator#list-of-official-generator-templates). Try out the project by following :point_down: instructions:\n\n<GeneratorInstallation />\n\n### Generate Server and Client\n\nThis article focuses on WebSocket therefore, I use our [Node.js WebSocket template](https://github.com/asyncapi/nodejs-ws-template) that is capable of generating server for WebSocket API and also a client that is aware of available channels.\n\n1. Create a new directory where you will work on the project:\n    ```bash\n    mkdir shrekapp && cd shrekapp\n    ```\n1. Trigger generation using the template:\n  ```bash\n  ag https://raw.githubusercontent.com/derberg/shrekapp-asyncapi-designed/main/asyncapi.yaml @asyncapi/nodejs-ws-template -o myapp -p server=swamp\n  ```\n1. Access generated folder and list all files from the directory. Notice that Node.js application is generated:\n  ```bash\n  cd myapp && ls\n  ```\n1. Install application dependencies\n  ```bash\n  npm i\n  ```\n1. Start the application\n  ```bash\n  npm start\n  ```\n\nThat is it. The basics are done. The application is ready, and all the basic logic is there. You can already interact with the application on **localhost** on port **80**. Now you need a client able to communicate with WebSocket protocol. For now, we will not explore the generated client.\n\n1. Get **websocat** (curl-like tool for WebSocket) by following [these instructions](https://github.com/vi/websocat#installation)\n1. Connect to one of the channels and notice that the server sent you a message to respond to established connection.\n  ```bash\n  websocat ws://localhost/travel/status\n\n  Message from the server: Implement here your business logic that sends messages to a client after it connects.\n  ```\n\nLogs in the running server should also indicate a new connection with the server:\n```bash\nListening on port 80\n/travel/status client connected.\n```\n\n## Code Walkthrough\n\nBefore writing some code, let's first go through the generated code:\n- For the generated server, we need to look into `src/api/routes.js` and `src/api/services`\n- For generated client, everything is in the `index.html`\n\n### Server Code\n\n#### Router\n\nBasing on the information provided in the AsyncAPI document about available channels, in the **src/api/routes.js** the following routes are generated:\n\n```js\nconst { subChatMessage, pubChatMessage } = require('./services/chat');\nconst { subTravelInfo } = require('./services/travel-status');\n\nrouter.ws('/chat', async (ws, req) => {\n  const path = pathParser(req.path);\n  console.log(`${yellow(path)} client connected.`);\n  await subChatMessage(ws);\n  ws.on('message', async (msg) => {\n    console.log(`${yellow(path)} message was received:`);\n    console.log(util.inspect(msg, { depth: null, colors: true }));\n    await pubChatMessage(ws, { message: msg, path, query: req.query });\n  });\n});\nrouter.ws('/travel/status', async (ws, req) => {\n  const path = pathParser(req.path);\n  console.log(`${yellow(path)} client connected.`);\n  await subTravelInfo(ws);\n});\n```\n\nIn the case of this particular template, routes are handled by [Express framework](https://expressjs.com/) and [express-ws](https://github.com/HenningM/express-ws) middleware.\n\nFirst let's have a look at **/travel/status** route:\n\n```js\nrouter.ws('/travel/status', async (ws, req) => {\n  const path = pathParser(req.path);\n  console.log(`${yellow(path)} client connected.`);\n  await subTravelInfo(ws);\n});\n```\n\nOnce the client establishes connection with the server, generated code invokes a function called **subTravelInfo**. Now look again at the AsyncAPI document:\n\n```yml\n  /travel/status:\n    subscribe:\n      summary: Client can receive travel info status.\n      operationId: subTravelInfo\n      message:\n        $ref: '#/components/messages/travelInfo'\n```\n\nThe name of the function maps to the **operationId**. The **/travel/status** channel supports only **subscribe** operation which means that client can only connect to the channel to listen for the messages, no messages are accepted. This is why the generated router doesn't react to any message sent to the channel. As oposite to the **/chat** channel:\n\n```js\nrouter.ws('/chat', async (ws, req) => {\n  const path = pathParser(req.path);\n  console.log(`${yellow(path)} client connected.`);\n  await subChatMessage(ws);\n  ws.on('message', async (msg) => {\n    console.log(`${yellow(path)} message was received:`);\n    console.log(util.inspect(msg, { depth: null, colors: true }));\n    await pubChatMessage(ws, { message: msg, path, query: req.query });\n  });\n});\n```\n\nThe **subChatMessage** function is invoked when client connects with the server. There is also a message listener generated that invokes **pubChatMessage** function whenever a message is sent from the client. Now look again at the AsyncAPI document:\n\n```yml\n  /chat:\n    subscribe:\n      summary: Client can receive chat messages.\n      operationId: subChatMessage\n      message:\n        $ref: '#/components/messages/chatMessage'\n    publish:\n      summary: Client can send chat messages.\n      operationId: pubChatMessage\n      message:\n        $ref: '#/components/messages/chatMessage'\n```\n\nThe client can not only listen to the messages incoming from `/chat` channel but, in this case, can also send messages. This way, there can be bi-directional communication established between the client and the chatbot.\n\n#### Services\n\nFunctions like, for example, **pubChatMessage** are generated in the **services** directory. All functions for single channel go into individual file. Have a look at **src/api/services/travel-status.js** file:\n\n```js\nconst service = module.exports = {};\n\n/**\n * Client can receive travel info status.\n * @param {object} ws WebSocket connection.\n */\nservice.subTravelInfo = async (ws) => {\n  ws.send('Message from the server: Implement here your business logic that sends messages to a client after it connects.');\n};\n```\n\nAs you can see, you are ready to provide your business logic by replacing the generated one:\n```js\nws.send('Message from the server: Implement here your business logic that sends messages to a client after it connects.');\n```\n\n### Client Code\n\nThe Node.js WebSocket template that I use for this article also generates **index.html** file to showcase that client generation is also possible using AsyncAPI document. As I mentioned in the beginning, with AsyncAPI and the AsyncAPI Generator, you can generate whatever you want.\n\nThe **index.html** contains a simple API that you can call from the browser's console to talk to the WebSocket API. Open the file in the browser and play with the API:\n\n<Figure\n  src=\"/img/posts/websocket-part3/client.webp\"\n/>\n\n## Add Business Logic\n\nThe Business logic goes only to generated services.\n\n### Add Travel Status Updates\n\nI don't have here any real travel status updates. I add some dummy data that are sent to the client every 1s, 100 times.\n\n1. Add **dummy-json** that makes it easier to provide mock data. I add it only to make sure the code is not overcomplicated\n  ```bash\n  npm i --save dummy-json\n  ```\n1. Imported the package in the **src/api/services/travel-status.js** file:\n  ```js\n  const dummyjson = require('dummy-json');\n  ```\n1. Modify **subTravelInfo** from the same file to send mock data to the client with **ws.send()** function:\n  ```js\n  service.subTravelInfo = async (ws) => {\n    (function myLoop (i) {\n      setTimeout(() => {\n        ws.send(generateResponse());\n        if (--i) myLoop(i);\n      }, 1000);\n    }(100));  \n\n    function generateResponse() {\n      const template = `{\n        \"destination\": \"{{city}}\",\n        \"arrival\": \"{{int 2 6}}h\",\n        \"distance\": \"{{int 18 65}}km\"\n      }`;\n      return dummyjson.parse(template);\n    }\n  };\n  ```\n\nThis is it. Now restart the server and check with previously installed **websocat** if after connecting to **travel/status** channel you are now regularly receiving a stream of messages:\n```bash\nwebsocat ws://localhost/travel/status\n\n{       \"destination\": \"Woodville\",       \"arrival\": \"4h\",       \"distance\": \"60km\"     }\n{       \"destination\": \"Denver\",       \"arrival\": \"3h\",       \"distance\": \"60km\"     }\n{       \"destination\": \"Fargo\",       \"arrival\": \"3h\",       \"distance\": \"42km\"     }\n{       \"destination\": \"Exeter\",       \"arrival\": \"2h\",       \"distance\": \"62km\"     }\n{       \"destination\": \"Bradford\",       \"arrival\": \"2h\",       \"distance\": \"55km\"     }\n{       \"destination\": \"Toronto\",       \"arrival\": \"6h\",       \"distance\": \"28km\"     }\n{       \"destination\": \"Durham\",       \"arrival\": \"5h\",       \"distance\": \"59km\"     }\n{       \"destination\": \"Canterbury\",       \"arrival\": \"4h\",       \"distance\": \"50km\"     }\n```\n\n### Add ChatBot Communication\n\nI chose Wit.ai as a platform that:\n- Makes is super easy to train the bot\n- Gives me access to API that enables integration with custom services, like the one that we just generated\n\nI encourage you to [give it a try](https://wit.ai/docs/quickstart) as it is pretty easy to use if it is your first time with ChatBots. It was my first time. \n\n1. To make it easier to talk to Wit.ai API I use **node-fetch** package:\n  ```bash\n  npm i --save node-fetch\n  ```\n1. Imported the package in the **src/api/services/chat.js** file:\n  ```js\n  const fetch = require('node-fetch');\n  ```\n1. Modify **subChatMessage** from the same file to send to the client message that connection is working:\n  ```js\n  service.subChatMessage = async (ws) => {\n    ws.send('Connection with Shrek established');\n  };\n  ```\n1. Modify **pubChatMessage** that is invoked when message from the client gets to the **/chat** channel:\n  ```js\n  service.pubChatMessage = async (ws, { message, path, query }) => {\n    const messageToShrek = message ? encodeURIComponent(message) : '';\n    const defaultAnswer = 'Shrek is out sorry. He\\'s busy rescuing the princess.';\n    let shrekAnswer = defaultAnswer;\n    let botAnswer;\n\n    try {\n        botAnswer = await fetch(`https://api.wit.ai/message?q=${messageToShrek}`, {\n            headers: { 'Authorization': `Bearer ${process.env.CHATBOT_TOKEN}` }\n        });\n    } catch (e) {\n        throw new Error(`Having issues communicating with the bot: ${e}`);\n    }\n\n    if (botAnswer) {\n        const wrongQuestionAnswer = 'Is it you Donkey!? Ask a better question!';\n        const answerObject = await botAnswer.json();\n        let firstTraitValue;\n        \n        for (const [, v] of Object.entries(answerObject.traits)) {\n          firstTraitValue = v[0].value;\n          break;\n        }\n\n        shrekAnswer = firstTraitValue ? firstTraitValue : wrongQuestionAnswer;\n    }\n    console.log(`Answered with: ${shrekAnswer}`)\n    ws.send(shrekAnswer);\n  };\n  ```\n\nThe most important part of this code is when the communication with the Wit.ai platform happens to send a message and get a response:\n```js\n      botAnswer = await fetch(`https://api.wit.ai/message?q=${messageToShrek}`, {\n          headers: { 'Authorization': `Bearer ${process.env.CHATBOT_TOKEN}` }\n      });\n```\n\nThis is it. Now restart the server and check with previously installed **websocat** if after connecting to **chat** channel you can send messages to chatbot and receive answers. You need to start the server with **CHATBOT_TOKEN** environment variable with the token: `CHATBOT_TOKEN=your-token npm start`. I cannot give you my token, sorry, you have to get yours from [Wit.ai](https://www.wit.ai) and train your chatbot:\n```bash\nwebsocat ws://localhost/chat\n\nConnection with Shrek established\n\nMe: Hi Shrek\nShrek: hey, do you know ogrs have layers?\nMe: Interesting\nShrek: are you mocking me?\nMe: Why would I? I like you\nShrek: Is it you Donkey!? Ask a better question!\nMe: No, not a donkey\nShrek: good\n```\n\nYou can also see logs on the server-side:\n```bash\nListening on port 80\n/chat client connected.\n/chat message was received:\n'Hi Shrek\\n'\nAnswered with: hey, do you know ogrs have layers?\n/chat message was received:\n'Interesting\\n'\nAnswered with: are you mocking me?\n/chat message was received:\n'Why would I? I like you\\n'\nAnswered with: Is it you Donkey!? Ask a better question!\n/chat message was received:\n'No, not a donkey\\n'\nAnswered with: good\n```\n\n## Summary\n\nIf you do not want to go through all the steps of getting the generated code, you can directly use [this project](https://github.com/derberg/shrekapp-asyncapi-designed). It contains everything mentioned in this article.\n\nAs you could see, the only coding part was just business implementation details, and the rest was generated. When I worked on this article, I focused first on the API. My main goal was to write the AsyncAPI document first, and the rest was easy.\n\nAre you convinced now that API-first is better than code-first?\n\n<Figure\n  src=\"/img/posts/websocket-part3/meme-redbuttons.webp\"\n  widthClass=\"w-1/2\"\n  className=\"text-center\"\n/>\n\nI'm an API-first person. I can go on and give you many arguments that support my view.\n\nI won't do it.\n\nInstead, I will honestly tell you what the problems are related to API-first and code generation. You judge what is the path you want to take.\n\n### AsyncAPI 2.0 Limitations\n\nAs I mention in this article and the previous ones on WebSocket, you write AsyncAPI document for your application from a client perspective. When you start designing your API, you ask yourself questions from the user's perspective.\n\nDon't get me wrong; I'm not saying that taking user perspective is wrong. It makes sense but also confusing for many. I recommend joining [this thread](https://github.com/asyncapi/spec/issues/520) for more details.\n\nConfusion between **subscribe** and **publish** is not the only problem. Once you understand that your application that publishes events must describe it as subscribe operation, the rest is trivial.\n\nThe real problem is with code generation. You describe the application from a user perspective, so client code generation is easy. What about generating code for your server? Have a look again at the **/travel/status** channel from ShrekApp:\n\n```yml\n  /travel/status:\n    subscribe:\n      summary: Client can receive travel info status.\n      operationId: subTravelInfo\n      message:\n        $ref: '#/components/messages/travelInfo'\n```\n\nI had to try hard to make sure the **summary** and **operationId** are as neutral as possible. My first version looked like this:\n\n```yml\n  /travel/status:\n    subscribe:\n      summary: You can listen to travel info status.\n      operationId: onTravelInfo #client code perspective, generated client reacts \"onTravelInfo\" incomming message \n      message:\n        $ref: '#/components/messages/travelInfo'\n```\n\nThen in **src/api/services/travel-status.js** file, I would have **onTravelInfo** instead of **subTravelInfo** with the following jsdoc:\n\n```js\n/**\n * You can listen to travel info status.\n * @param {object} ws WebSocket connection.\n */\nservice.onTravelInfo = async (ws) => {\n...\n```\n\nThis is a function responsible for sending messages to the Client once it connects with a given channel. Function name like **onTravelInfo** is misleading, not to mention the generated code description.\n\nI chose neutral descriptions. They are acceptable, I think, but not when it comes to user-facing documentation. Every technical writer will tell you that the best docs are the ones that are directed to a reader. You don't write \"what user can do with the API\" but \"what you can do with the API\".\n\nTherefore, all descriptions and even things like **operationId** should have two versions to satisfy both docs and code depending on the perspective. Otherwise, you need to make a sacrifice. You either make the developer that maintains the code happy or the technical writer that maintains docs happy.\n\n> Join the discussion around [operationId](https://github.com/asyncapi/spec/issues/538).\n\n### Keeping AsyncAPI in Sync With Code\n\nIn this article, I generated a server that was easy to extend, to showcase AsyncAPI capabilities. Using such projects is a way for building prototypes and quickly design architectures. You can even scaffold a server that later you can tune and use on production.\n\nYou did your work, you did API-first.\n\nWhat happens later? I mean later during further development of the application.\n\nLet's say you add a new channel to the server or modify the name of the old channel. \n\nWhere do you do it? AsyncAPI document or the code? You need to do it manually in both. You need to add a channel to the AsyncAPI document and add implementation for the channel in the code. You enter the land where your AsyncAPI document describes something different from your code at some point in time. You cannot regenerate the project with the template you used in the beginning, as your custom logic will be lost.\n\nThe AsyncAPI Generator provides support for Git. If you have a Git repository and unstaged files, the Generator warns you that your changes may be lost. Git support is definitely helpful. You can try code regeneration, but you need to review changes and manually ignore overrides after that. \n\nIt can be a cumbersome process, but you maintain sync between the AsyncAPI document and the code. There is no place for automation, though.\n\nThere must be a way to solve these challenges. Maybe some kind of markers.  One could use them in code to indicate that the generator must ignore a given part of the code. Another helpful solution could be a way to specify what template files should be ignored during generation. For example, regenerate only models built from messages' schemas. We need to figure it out.\n\nDon't give up, though. Technical challenges are not a good excuse for avoiding the API-first approach.\n\n<Figure\n  src=\"/img/posts/websocket-part3/meme-starwars.webp\"\n  widthClass=\"w-1/2\"\n  className=\"text-center\"\n/>\n\nIn my opinion, specification limitations and gaps in tooling support should not block you from choosing an API-first direction. The benefits are too big to resign that easily. Just join us and let us find solutions together. We want to help solve all those issues, but we just need some help from you too.\n\nThat would be it. Thanks for staying with me until the end. Don't forget to read my previous articles on AsyncAPI spec and WebSocket protocol. Share your feedback and connect with the AsyncAPI community in our [Slack workspace](https://www.asyncapi.com/slack-invite/).\n",
    "toc": [
      {
        "content": "API-First vs Code-First",
        "slug": "api-first-vs-code-first",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "ShrekApp",
        "slug": "shrekapp",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Write AsyncAPI document",
        "slug": "write-asyncapi-document",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Info",
        "slug": "info",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Servers",
        "slug": "servers",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Channels",
        "slug": "channels",
        "lvl": 3,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Final document",
        "slug": "final-document",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Generate Code",
        "slug": "generate-code",
        "lvl": 2,
        "i": 7,
        "seen": 0
      },
      {
        "content": "AsyncAPI Generator",
        "slug": "asyncapi-generator",
        "lvl": 3,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Generate Server and Client",
        "slug": "generate-server-and-client",
        "lvl": 3,
        "i": 9,
        "seen": 0
      },
      {
        "content": "Code Walkthrough",
        "slug": "code-walkthrough",
        "lvl": 2,
        "i": 10,
        "seen": 0
      },
      {
        "content": "Server Code",
        "slug": "server-code",
        "lvl": 3,
        "i": 11,
        "seen": 0
      },
      {
        "content": "Router",
        "slug": "router",
        "lvl": 4,
        "i": 12,
        "seen": 0
      },
      {
        "content": "Services",
        "slug": "services",
        "lvl": 4,
        "i": 13,
        "seen": 0
      },
      {
        "content": "Client Code",
        "slug": "client-code",
        "lvl": 3,
        "i": 14,
        "seen": 0
      },
      {
        "content": "Add Business Logic",
        "slug": "add-business-logic",
        "lvl": 2,
        "i": 15,
        "seen": 0
      },
      {
        "content": "Add Travel Status Updates",
        "slug": "add-travel-status-updates",
        "lvl": 3,
        "i": 16,
        "seen": 0
      },
      {
        "content": "Add ChatBot Communication",
        "slug": "add-chatbot-communication",
        "lvl": 3,
        "i": 17,
        "seen": 0
      },
      {
        "content": "Summary",
        "slug": "summary",
        "lvl": 2,
        "i": 18,
        "seen": 0
      },
      {
        "content": "AsyncAPI 2.0 Limitations",
        "slug": "asyncapi-20-limitations",
        "lvl": 3,
        "i": 19,
        "seen": 0
      },
      {
        "content": "Keeping AsyncAPI in Sync With Code",
        "slug": "keeping-asyncapi-in-sync-with-code",
        "lvl": 3,
        "i": 20,
        "seen": 0
      }
    ],
    "slug": "/blog/websocket-part3",
    "filePath": "pages/blog/websocket-part3.md"
  },
  {
    "meta": {
      "title": "April 2021 at AsyncAPI",
      "date": "2021-05-14T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/april-2021-at-asyncapi/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "excerpt": "AsyncAPI 2.1 release is scheduled. Is there anything else that could be more important.",
      "readingTime": 6
    },
    "content": "\n> Read [March 2021 at AsyncAPI](/blog/march-2021-at-asyncapi) for the update from March.\n\n<center><iframe src=\"https://anchor.fm/asyncapi/embed/episodes/April-2021-at-AsyncAPI-Initiative-e111lo9\" height=\"102px\" width=\"400px\" frameborder=\"0\" scrolling=\"no\"></iframe></center>\n\n## AsyncAPI specification release cadence\n\nI'm super happy to share that we removed the last roadblock for the next AsyncAPI release. Basing on some discussions during our public meetings and on [this](https://github.com/asyncapi/spec/issues/513) issue, the release schedule for the spec looks like this:\n* June 2021\n* September 2021\n* January 2022\n* April 2022\n* June 2022\n* September 2022\n* January 2023\n* April 2023\n* June 2023\n\nI hope you noticed a pattern. We do not want to do releases during the summer holidays and stay away from December :smiley:.\n\nIn June 2021, we will release 2.1.0 version of the specification. It is going to be the first release under [open governance model](https://github.com/asyncapi/.github/blob/master/CHARTER.md), under Linux Foundation and new [contribution guide](https://github.com/asyncapi/spec/blob/master/CONTRIBUTING.md). So many new things, a lot to organize around. It means we probably won't accept too many changes as logistics will consume a lot of time. We welcome any help. Join our [Slack](https://www.asyncapi.com/slack-invite/) for more details. \n\n## AsyncAPI use case at eBay\n\nIf you were looking for an AsyncAPI use case that shows some big tech using AsyncAPI in production, it is here. I highly recommend you read the article [AsyncAPI 2.0: Enabling the Event-Driven World](https://thenewstack.io/asyncapi-2-0-enabling-the-event-driven-world/) from [Shekhar Banerjee](https://www.linkedin.com/in/someshekhar-banerjee-66004617/) from eBay.\n\n## React component and HTML template merge\n\nAsyncAPI document can be rendered into documentation using two different tools maintained by the AsyncAPI Initiative:\n- You can use [React component](https://github.com/asyncapi/asyncapi-react), also bundled as Web Component, to render the AsyncAPI document on the client-side.\n- You can use [HTML template](https://github.com/asyncapi/html-template/tree/master) that is a docs generator compatible with the AsyncAPI Generator for a server-side generation.\n\nThese are two completely separate tools. People are contributing to both. There are some features supported in the first one but not in the other one, and vice-versa.\n\nIt is such a waste of time for contributors. We never liked it. [Maciej Urbanczyk](https://www.linkedin.com/in/maciej-urba%C5%84czyk-909547164/) took the effort to change it.\n\nSolution: Use React component as the core and HTML template to provide static output by rendering React during generation (you may know such approach from tools like Gatsby or Next.js).\n\nSounds simple, but there was a lot of work to do:\n- React component to use official AsyncAPI Parser (yes, we were a bit behind there)\n- Provide features from HTML template to React component (who likes functionality regression, right?)\n- Rework design of React component to match the HTML template\n\nThe result:\n- You need to try the new React component that is getting closer to the 1.0 release and join [the discussion](https://github.com/asyncapi/asyncapi-react/issues/265).\n  ```bash\n  npm install @asyncapi/react-component@next\n  ```\n- HTML template already uses this React release candidate under `0.21.1` version.\n\nDon't stay behind. Maciek is now entirely focused on the component. Now is the best time to push for your features :smiley:.\n\nYour favorite missing features like rendering of extensions and bindings are already there!\n\n[![Edit asyncapi-react-component-next-in-action](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/asyncapi-react-next-in-action-4en9x)\n\n## Intend-driven API for AsyncAPI Parsers\n\nOver the last couple of weeks [Jonas Lagoni](https://www.linkedin.com/in/jonas-terp-lagoni-85b027b9/) and [Sergio Moya](https://twitter.com/smoyac) worked on an idea to make the AsyncAPI JavaScript Parser, and in future other parsers, resilient to breaking changes in the AsyncAPI specification. \n\nWhy?\n\nThe current parser is bound to the structure of the AsyncAPI specification. The goal is to move away from such an approach into the API driven by the developer's intent. \n\nLearn more about the outcome of this tremendous effort from Sergio's article: [Designing a unified Intent-driven API for all AsyncAPI's parsers](/blog/intent-driven-api)\n\n## WebSocket\n\nSince we were getting more and more questions about using WebSocket with AsyncAPI, it was about time to provide some learning materials. We had no dedicated documentation nor examples, so I decided to spend few weeks on that subject, and as a result, we got:\n\n* Blog post on [WebSocket, Shrek, and AsyncAPI - An Opinionated Intro](https://www.asyncapi.com/blog/websocket-part1)\n* Blog post on [Creating AsyncAPI for WebSocket API - Step by Step](https://www.asyncapi.com/blog/websocket-part2)\n* And soon I'll release the last blog post on [From API-First to Code Generation - A WebSocket Use Case](https://github.com/asyncapi/website/pull/237) \n\nIn addition, you can have a look at [official WebSocket example](https://github.com/asyncapi/spec/blob/master/examples/2.0.0/websocket-gemini.yml).\n\nThere is also a [live stream](https://www.youtube.com/watch?v=8tFBcf31e_c) I did about this topic. I will also present at [EDASummit](https://edasummit.com/) on 19th of May and most probably at [APIOps Helsinki](https://www.meetup.com/Apiops-Helsinki/) someday around mid-June. Stay tuned.\n\n## Jobs\n\nIs your company looking for an AsyncAPI expert? Now you can share your job description on the AsyncAPI website to share it directly with the AsyncAPI community. In April, we had 300 individual users looking at Jobs view even though we do not actively promote it. Once the list of jobs grows, we will promote it more to increase the traffic and job offers visibility.\n\nHead on [here](https://www.asyncapi.com/jobs) and check out instructions on getting your job posting published. \n\nThis option to add custom job offers, including jobs filtering, was contributed by [Acebuild](https://twitter.com/_acebuild) :pray:.\n\n## RSS\n\nWe finally have an [rss feed](https://www.asyncapi.com/rss.xml) for our AsyncAPI blog. All thanks to [Mike Ralphson](https://twitter.com/PermittedSoc).\n\nIf you do not like feed readers, just like me, then use some service like [Blogtrottr](https://blogtrottr.com/) to get email notifications. I use it for a GitHub blog on the free plan, and I'm super happy.\n\n## AsyncAPI workshop aka training\n\nMore and more people learn about AsyncAPI. We need to make sure there are good learning materials for anyone. More important, we need a solution that is easy to scale.\n\nOur new initiative is to work on training materials that can be used for in-class workshops with trainers, but on the other hand, they need to be available on a platform that offers self-learning training. All discussions happen [here](https://github.com/asyncapi/training/discussions), and you can also join the #training channel in our [Slack](https://www.asyncapi.com/slack-invite/).\n\nWe need people that want to become trainers, trainees or help to work preparing training materials. All hands aboard :muscle:.\n\nWho knows, maybe once it grows to a proper size, we will start thinking about some official certification program?\n\n## AsyncAPI and Kafka\n\nThis year there were many sessions about AsyncAPI at [Kafka Summit](https://www.kafka-summit.org/events/kafka-summit-europe-2021/about). You need to have a look. If you want to work around the registration process, watch the below recording from [Dale Lane](https://twitter.com/dalelane) explaining how to use AsyncAPI with Kafka:\n\n<YouTube id=\"Ni5tCY9r0TY\" />\n\nDale has more content about AsyncAPI. For example, have a look at his work on the AsyncAPI [Node-RED](https://nodered.org/) plugin:\n\n<YouTube id=\"3B4O10V2PA0\" />\n\n## Interest growth\n\nI'm losing track here. It is growing so fast that we should expose some real-time metric that shows some aggregated data.\n\nFor example, on Twitter, we went up by 200 followers in April, up to 1900. Now, when I write this article, it is already over 2000. \n\nOn Slack, we are already over 1200, and on LinkedIn, over 1100.\n\n:rocket: :rocket: :rocket:\n\n> Photo by <a href=\"https://unsplash.com/@waldemarbrandt67w?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Waldemar Brandt</a> on <a href=\"https://unsplash.com/s/photos/april?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "AsyncAPI specification release cadence",
        "slug": "asyncapi-specification-release-cadence",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "AsyncAPI use case at eBay",
        "slug": "asyncapi-use-case-at-ebay",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "React component and HTML template merge",
        "slug": "react-component-and-html-template-merge",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Intend-driven API for AsyncAPI Parsers",
        "slug": "intend-driven-api-for-asyncapi-parsers",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "WebSocket",
        "slug": "websocket",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Jobs",
        "slug": "jobs",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "RSS",
        "slug": "rss",
        "lvl": 2,
        "i": 6,
        "seen": 0
      },
      {
        "content": "AsyncAPI workshop aka training",
        "slug": "asyncapi-workshop-aka-training",
        "lvl": 2,
        "i": 7,
        "seen": 0
      },
      {
        "content": "AsyncAPI and Kafka",
        "slug": "asyncapi-and-kafka",
        "lvl": 2,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Interest growth",
        "slug": "interest-growth",
        "lvl": 2,
        "i": 9,
        "seen": 0
      }
    ],
    "slug": "/blog/april-2021-at-asyncapi",
    "filePath": "pages/blog/april-2021-at-asyncapi.md"
  },
  {
    "meta": {
      "title": "Designing a unified Intent-driven API for all AsyncAPI's parsers",
      "date": "2021-05-07T05:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "API Design"
      ],
      "cover": "/img/posts/intent-driven-api/cover.webp",
      "authors": [
        {
          "name": "Sergio Moya",
          "photo": "/img/avatars/smoya.webp",
          "link": "https://twitter.com/smoyac",
          "byline": "Pilot at AsyncAPI Airlines"
        }
      ],
      "excerpt": "Afraid because of breaking changes? Learn how do we plan to reduce breaking changes in our tooling APIs by introducing a new design approach called Intent-driven.",
      "readingTime": 13
    },
    "content": "\nThe **Free and Open-Source Software** (FOSS) model, since its inception, has brought a flurry of libraries and applications available to everyone. \n\nThanks to the growth of the open-source community, we can now enjoy free software and, in most cases, generate profit from it.\n\nI believe there is no tech company that doesn't use open source in one way or another.\n\nFOSS has changed the way most developers operate: from coding all features from scratch to become consumers of libraries that implement most of the basic operation of an application. Sometimes even the core logic of the application is baked with free software.\n\nSo much so that I, as a developer, can't imagine having to implement a complex application from scratch. \n\nIf we go a step further, we won't talk only about libraries but also about APIs as services. For example, the fast adoption of the [Jamstack](https://jamstack.org) architecture, where the backend consists of different API services (primarily third-party), is pushing SaaS companies to make their private APIs public.\n\nIn short, applications worldwide depend on free libraries maintained by the community, which constantly deliver updates at a frenetic rate: new functionalities, fixes, or in many other cases, drastic changes that allow us to continue growing and maintaining those libraries or APIs.\n\nThe latter is, precisely, a problem for many developers. The feared 👻  **breaking changes** 👻.\n\n> Disclaimer: This post provides examples from the point of view of a software library API maintainer. However, the same principles apply to any other API, such as command-line tools, REST, Kernel modules, or peripheral drivers.\n\n# What is a breaking change?\n\n> A change in one part of a software system that potentially causes other components to fail; occurs most often in shared libraries of code used by multiple applications.\n>\n> Source: [https://en.wiktionary.org/wiki/breaking_change](https://en.wiktionary.org/wiki/breaking_change)\n\nBreaking changes are non-backward compatible changes in the public interface of an application, either a library, an API service, or even a command-line utility.\n\nUsers of such software are forced to alter their code if they want to use the latest version; otherwise, their code will be unusable.\n\nI propose a metaphor to better understand what a **breaking change** is. By the way, based on something that happened to me a few days ago. \nImagine that your preferred supermarket, the one you have been going to for several years, decides to restructure its interior completely. Where you could find the fruit, now you only find water and other drinks. At this point, I have three options:\n\n1. You adapt yourself to the new layout and changes made to the surface. It will take a few days or maybe weeks to know where each product is, but in return, you can continue shopping at your favorite supermarket.\n2. Seek another supermarket that does not make drastic changes. In case they want to make changes, changes to be less and communicated in advance.\n3. Decide that you will devote all your efforts to grow your vegetables, raise your cattle, ride a water purification plant, and everything it takes to not rely on any supermarket or store.\n\nI went for the first option. Today I still get lost when I go shopping, but at least pasta is still on the same shelf as it was!\n\nIn the software world, the first option would mean to update your code, so you avoid breaking changes.\n\nTherefore, the second option would be to look for another library or an API designed to avoid, as far as possible, these breaking changes. Building an API that meets this requirement is the primary purpose of this post.\n\nFinally, the third option would be to make zero use of FOSS. \n\nHow can we mitigate the impact on users when releasing a new [major](https://semver.org/#summary) version of our library or service API?\n\n# Designing APIs that are resilient to breaking changes\n\nAPIs solve user needs. \n\nHowever, I believe we do not listen to the final users that much. Instead, we tend to expose functionalities based on our own experience, biased by our position or the knowledge we own of the platform behind. Sometimes guided by preliminary research (Product-oriented) or lead with a not-so-clear goal in mind. At least I used to do it in that way.\n\nNot an easy journey, but I can promise you it is worth it.\nAs *Mark Dalgleish* once tweeted:\n\n<TwitterTweetEmbed\n  tweetId='1384127726861258756'\n  options={{\n    cards: 'hidden',\n    width: 500,\n    align: 'center'\n  }}\n/>\n\n## Be ready for what the user needs\n\nFocusing on what the user needs pulls away most of the overprint of any API: What is the user **intention** when asking for a particular action to happen?\n\nAn Intent represents a user intention of performing an action that solves a clear use case.\n\nContinuing with the metaphor presented in the previous paragraph, notice that my only intention was to **buy groceries for dinner**. In particular, I needed some avocados, tomatoes and a baguette.\n\nThe supermarket should provide a mechanism that lets me buy those items. How to get those, it's just the implementation detail and can be up to each supermarket to decide how to do it. \n\nFor example, my supermarket had shelves where customers can pick up fruits from, offers bags, a balance to know the weight of those, and a checkout place. However, after the last changes, fruits are weighted at checkout, and baguettes are no longer on the shelf. So you need to ask the baker. \n\nAs you can see, the interface didn't change: I still can buy the groceries. However, the implementation completely changed.\n\nBuilding APIs based on the implementation detail will nothing less than lead your users to suffer the (not-so-good) design choices made in the past. Furthermore, each change you make will penalize the user experience and force them to upgrade their code.\n\nLet's pick up another example, this time a more practical one. \n\nHere is a modified version of the [Streetlights tutorial](https://www.asyncapi.com/docs/tutorials/streetlights) document made for demo purposes:\n\n```yaml\nasyncapi: '2.0.0'\ninfo:\n  title: Streetlights mod API\n  version: '1.0.0-alpha'\nservers:\n  mosquitto:\n    url: mqtt://test.mosquitto.org\n    protocol: mqtt\nchannels:    \n  light/measured/changed:\n    subscribe:\n      summary: Receive an update every time a lighting condition changed.\n      operationId: onLightMeasureChanged\n      message: \n        $ref: \"#/components/messages/lightMessage\"\ncomponents:\n  messages:\n    lightMessage:\n      payload:\n        type: object\n        properties:\n          id:\n            type: integer\n            minimum: 0\n            description: Id of the streetlight.\n          lumens:\n            type: integer\n            minimum: 0\n            description: Light intensity measured in lumens.\n```\n\nBy the time of this post, there is only one implementation of the parser, which is written in Javascript. \n[Parser-js][parser-js] parses AsyncAPI spec documents and provides functions to work with them and access the different objects and their values.\n\nIn the hypothetical case a user wants to parse this document and *get all the messages a consumer of the application can consume*, this is needed: \n\n```jsx\ndoc.channels().filter(c => c.hasSubscribe()).map(c => c.subscribe().messages()).flat();\n```\n\nWe can observe that the [Parser-js][parser-js] API (`v1.x`) is completely coupled with the structure of the AsyncAPI spec (by the date of this post, `v2.0.0`) document. The API is just a layer on top of the JSON Schema parsed document with some helpers and extras, meaning you should know the document's structure to access any information.\n\nLet's emulate a possible breaking change. \n\nImagine **messages** are now independent of channels and **Operations** get moved from where they used to be (under the channel) to the root of the document. For instance:\n\n```yaml\nasyncapi: '99.99.99'\n# ...\noperations:\n  onLightMeasureChanged:\n    operationType: subscribe\n    summary: Receive an update every time a lighting condition changed.\n    message: \n      $ref: \"#/messages/lightMessage\"\n    channel:\n      $ref: \"#/channels/light/measured\"\nchannels:\n  light/measured:\n    description: Channel for updates on lightning conditions.\nmessages:\n  lightMessage:\n    # ...\n```\n\nNow the users of the [Parser-js][parser-js] that wanted to *get all the messages a consumer of the application can consume* will need to change their code so their app keeps working after the **breaking change** got introduced. For instance:\n\n```jsx\ndoc.operations().filter(o => o.isSubscribe()).map(o => o.message()).flat();\n```\n\n## Intent-driven design to the rescue\n\nWhat if I tell you that you could avoid most of the breaking changes on your APIs by following an Intent-driven design approach?\n\nLet's give a twist to the API by adding some user intents. In this particular case, a method that represents the intent:\n\n```jsx\nclientSubscribableMessages() : Message[]\n```\n\nSome naming clarification:\n\n- **client**: user wants to get messages from the point of view of a client/consumer of the application.\n- **subscribable**: user wants to get the messages they can consume.\n\nIt looks simple, right? We have just written down our first intent! 🎉\n\nFrom now on, users won't need to know in detail how the spec document is structured. The parser will reflect any change on the underlying document inside each function instead. Therefore, `doc.clientPublishableMessages();` will **always** be available as a method: it makes complete sense from a business model point of view for the AsyncAPI project. \n\nNew versions of the library will be out, but those will mostly be minor or patch versions, adding new features, or fixing bugs. Meaning the users will follow a fearless and simple upgrade process.\n\nThis approach also sets the foundations for creating backward compatibility APIs, among other features. For example, you can support several versions by executing one or another logic inside your intent functions.\n\n# Designing a unified Intent-driven API for all AsyncAPI's parsers\n\nThe idea behind the Intent-driven design approach is to first focus on getting what the user intents are by getting feedback from final users as much as possible. Sometimes users are nothing else than other libraries, so go and check how they use your API.\n\nOur goal was to design an API that could be implemented in any language, meaning others could create their parser but always following this API. For example, the [Parser-go](https://github.com/asyncapi/parser-go).\n\nHere is a summary of the steps we followed:\n\n## 1. Identify how users use the library\n\nWe first focused on identifying the intents behind our [generator templates][templates]. By doing some code analysis, we came out with [a list][issue-2] of *potential* intents that became the foundation of our API.\n\nFurthermore, we tried to think about potential users of the parsers. For example, [Slack](https://github.com/slackapi/slack-api-specs/blob/master/events-api/slack_events_api_async_v1.json) developers could use the parser for adding documentation to their UI, validating messages, among others. \n\nThat gave us another list of *potential* intents, most of them already covered by the list we got from the templates.\n\n## 2. Transform potential intents to actual intents\n\nIt is an important step, if not the most. It is one of the hardest as well.\n\nFor this step, we tried to abstract our minds and forget most of what we knew about the structure of an AsyncAPI document. We instead focused on the models and their **logical** (from a human point of view) relationship:\n\n- Messages flow through Channels\n- Messages can exist without channels.\n- Messages can be (or not) related to Operations\n- Etc\n\nWe then wrote down a draft of our first list of intents.\n\n## 3. Build a mock API\n\nAfter getting a list of intents to implement, we built a simple mock API in Javascript with that list. \n\nMethods were returning hardcoded data but were enough for getting an idea of how difficult it would be to create such API from the point of view of a maintainer.\n\nAt this point, we faced up some API design decisions, such as: \n\n- Shall we add getters for all properties?\n- Are we going to use singular or plural methods?\n- Are methods going to have any argument at all?\n- Etc\n\n## 4. Validate the intents and their UX\n\nWith the new API mock built-in Javascript, we chose some of the most used [generator templates][templates] and replaced all the calls made to the old [Parser-js][parser-js] API with the new ones.\n\nThis step made us realize that some of the intents we mocked up worked like a charm: We were pretty happy seeing how the code got simplified.\n\nHowever, we found some inconsistencies, such as missing intents and helpers required for simplicity purposes.\n\n## 5. Wrap up documentation\n\nThis step included writing down all our documentation around the new API in a new repository, where developers of AsyncAPI parsers will refer and follow the specification of the API. \n\nEven though each parser will now maintain an individual release cycle, changes to this API will force the individual parsers to update.\n\nIt follows [Semver](https://semver.org/) (as we do for all projects), so each parser will therefore maintain its compatibility matrix, making visible what version of the API specification they support. \n\nYou can find the new repository holding the new Parsers API specification [here][api], which at the moment of writing this post, it's still `v1.0.0-alpha`, as we are waiting for more feedback from the community.\n\n# What's next?\n\nEven though we do now have an alpha version of the new parser API, work is pending around implementation.\nWe are actively asking for feedback. Please submit yours via Github Discussions [here][api-discussions].\n\nOur next steps are going to be:\n\n1. To release a new version (alpha) of the [Parser-js][parser-js] that implements the new API specification.\n2. To use that new [Parser-js][parser-js] version in some of the [generator templates][templates]. That will help us to:\n    1. Validate that the [Parser-js][parser-js] behaves as expected.\n    2. Set an example of what kind of changes users will need to do on their codes to adopt the new API (We expect code will require no significant changes).\n3. To ask for feedback from the community, especially to maintainers and users of the [Parser-js][parser-js]. Reviewing the new API now becomes easier as there will be the specification, a new version of the [Parser-js][parser-js] and also examples to follow.\n4. Review feedback, apply suggestions, and do release a release-candidate or final version.\n\n# Related issues and links\n\nPlease find the outstanding issues related to the design process we went through here:\n\n- [Main issue for the API design process][issue-1]\n- [Collecting potential intents][issue-2]\n- [Emulating few breaking changes][issue-3]\n- [Figuring out how to do API versioning][issue-4]\n\nThe new Parser(s) API specification can be found [here][api]. Discussions take place [here][api-discussions].\n\n[issue-1]: https://github.com/asyncapi/shape-up-process/issues/90\n[issue-2]: https://github.com/asyncapi/shape-up-process/issues/84\n[issue-3]: https://github.com/asyncapi/shape-up-process/issues/93\n[issue-4]: https://github.com/asyncapi/shape-up-process/issues/95\n[parser-js]: https://github.com/asyncapi/parser-js\n[templates]: https://github.com/asyncapi/generator#list-of-official-generator-templates\n[api]: https://github.com/asyncapi/parser-api\n[api-discussions]: https://github.com/asyncapi/parser-api/discussions\n\n# Conclusion\n\nIntent-driven design helps to better understand your users by focusing on their intentions rather than technical details.\n\nIt is not an easy path in the short term; however, the benefits can be visible early, making the process a grateful experience.\n\nI firmly believe making a great user experience should always be a top priority, especially for publicly available projects. If we don't care about users then, who is going to use our software?\n\nI want to take this opportunity to express my gratitude to [Jonas Lagoni](https://github.com/jonaslagoni), who has been my partner along this journey. \nHours of figuring out small details, long backs and forths, and discussions around user experience were easy-going, thanks to this one.\n\nI hope you enjoyed reading this post as much as I did writing it 😃 \n\n> Cover photo by <a href=\"https://kaboompics.com/photo/20669/sharpened-colorful-pencils\">Karolina Grabowska</a> on <a href=\"https://kaboompics.com\">Kaboompics</a>\n",
    "toc": [
      {
        "content": "What is a breaking change?",
        "slug": "what-is-a-breaking-change",
        "lvl": 1,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Designing APIs that are resilient to breaking changes",
        "slug": "designing-apis-that-are-resilient-to-breaking-changes",
        "lvl": 1,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Be ready for what the user needs",
        "slug": "be-ready-for-what-the-user-needs",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Intent-driven design to the rescue",
        "slug": "intent-driven-design-to-the-rescue",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Designing a unified Intent-driven API for all AsyncAPI's parsers",
        "slug": "designing-a-unified-intent-driven-api-for-all-asyncapis-parsers",
        "lvl": 1,
        "i": 4,
        "seen": 0
      },
      {
        "content": "1. Identify how users use the library",
        "slug": "1-identify-how-users-use-the-library",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "2. Transform potential intents to actual intents",
        "slug": "2-transform-potential-intents-to-actual-intents",
        "lvl": 2,
        "i": 6,
        "seen": 0
      },
      {
        "content": "3. Build a mock API",
        "slug": "3-build-a-mock-api",
        "lvl": 2,
        "i": 7,
        "seen": 0
      },
      {
        "content": "4. Validate the intents and their UX",
        "slug": "4-validate-the-intents-and-their-ux",
        "lvl": 2,
        "i": 8,
        "seen": 0
      },
      {
        "content": "5. Wrap up documentation",
        "slug": "5-wrap-up-documentation",
        "lvl": 2,
        "i": 9,
        "seen": 0
      },
      {
        "content": "What's next?",
        "slug": "whats-next",
        "lvl": 1,
        "i": 10,
        "seen": 0
      },
      {
        "content": "Related issues and links",
        "slug": "related-issues-and-links",
        "lvl": 1,
        "i": 11,
        "seen": 0
      },
      {
        "content": "Conclusion",
        "slug": "conclusion",
        "lvl": 1,
        "i": 12,
        "seen": 0
      }
    ],
    "slug": "/blog/intent-driven-api",
    "filePath": "pages/blog/intent-driven-api.md"
  },
  {
    "meta": {
      "title": "Demystifying the Semantics of Publish and Subscribe",
      "date": "2021-05-05T23:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "Specification"
      ],
      "cover": "/img/posts/publish-subscribe-semantics/cover.webp",
      "authors": [
        {
          "name": "Nic Townsend",
          "photo": "/img/avatars/nictownsend.webp",
          "link": "https://twitter.com/nict0wnsend",
          "byline": "AsyncAPI user"
        }
      ],
      "excerpt": "Learn how to interpret publish and subscribe operations when reading an AsyncAPI specification, and why they might not mean what you expect.",
      "readingTime": 5
    },
    "content": "> This post originally appeared on [IBM Integration Community](https://community.ibm.com/community/user/integration/blogs/nic-townsend1/2021/04/01/publish-vs-subscribe-in-asyncapi-and-why-it-may-no)\n\nAs adoption of AsyncAPI increases, a frequent topic of conversation in the community is how to describe *publish* and *subscribe* semantics - both now and in future versions of the specification.\n\nIn this blog post I aim to introduce the discussion and set you on the right path to document your event driven APIs.\n\nOr in other words, what code would you expect to be generated for the publish operation in the following AsyncAPI document?\n```\n    asyncapi: 2.0.0 \n      info:                   \n        title: My Application\n        version: 1.0 \n    servers:\n      bootstrap:\n        url: mybroker.com:3514\n        protocol: kafka\n    channels:\n      myChannel:\n        publish:\n          message:\n            payload:\n              type: string\n```  \n\nIf you would be surprised to hear that this would result in a Kafka Consumer, then you should keep reading!\n\n![meme with phrase 'you keep using that word, I do not think you know what it means'](/img/posts/publish-subscribe-semantics/meme.webp)\n\n# In the beginning\n\nAsyncAPI started as an adaptation of OpenAPI - which describes synchronous *request/response* based APIs. In an OpenAPI world, you describe the application from the perspective of the client. Or in other words, the OpenAPI document describes how a client should interact with your application. The client and server communicate directly with each other.  \n  \n![server communicating with client](/img/posts/publish-subscribe-semantics/REST.webp)\n\nYou document that a GET endpoint exists to access data, a POST endpoint exists to create data, etc. In all cases, a client speaks to the application (server) that is serving these endpoints.\n\nIf you were implementing an application to honour the contract described in an OpenAPI document, you know to build route handlers that provide the documented endpoints for clients to access.\n\n> Callbacks and webhooks are asynchronous operations, but in OpenAPI they are still described from the perspective of the client – the client has to initiate/register with the server before the server will push data to the client.\n\n# What about AsyncAPI?\n\nIn an event driven architecture there is no client/server paradigm. Applications do not directly communicate with one another - instead, each application sends and receives events via communication channels provided by s messaging infrastructure such as a broker. The broker ensures that events sent to a channel are delivered to interested applications. It can be considered *fire and forget* - an application sends an event, but does not have any interest in whether other applications receive or make use of the event.\n\nAsyncAPI approaches this by describing an application as having two potential roles:\n\n*   If it sends messages to a channel, it's a “Publisher\".\n*   If it is interested in receiving messages from a channel, it is a “Subscriber\".\n\nAn application can have either one or both roles.\n\nWhat does the following AsyncAPI document describe?\n```\n    asyncapi: 2.0.0 \n      info:                   \n        title: My Application\n        version: 1.0 \n    servers:\n      bootstrap:\n        url: mybroker.com:3514\n        protocol: kafka\n    channels:\n      myChannel:\n        publish:\n          message:\n            payload:\n              type: string\n```\n\nIs *My Application* a Publisher or a Subscriber?\n\nAnswer... it's a Subscriber!\n\nLike with OpenAPI, an AsyncAPI documents an application from the *client* perspective. For a client to interact with *My Application*, it must publish an event to the myChannel channel on the Kafka broker hosted at mybroker.com:3514  \n  \n![clients communicating via a broker](/img/posts/publish-subscribe-semantics/BROKER.webp)\n\n> The exception to the rule is websockets - there is a client/server paradigm rather than a messaging infrastructure - so other applications will connect directly to the server. However, the semantics remain the same - you describe the server as an application from the *client* perspective. [See Lukasz's previous article for more details.](https://asyncapi.org/blog/websocket-part2) \n\n# Where's the confusion?\n\nAn AsyncAPI document can have multiple purposes. It can act as documentation for other developers to understand how to interact with the API. It can also act as documentation for developers to implement the API.\n\nIn OpenAPI, there is no ambiguity - if you implement the API your server must listen for incoming requests on the documented endpoints, and any clients know to make requests to the documented endpoints. A GET endpoint means the same thing to both client and server.\n\nIn AsyncAPI, the confusion has arisen because applications can both publish and subscribe - so **verbs become interchangeable depending on the perspective of the person reading the document.**\n\nWhen describing your architecture - a collection of applications communicating via channels - it can feel more familiar to describe what each application is doing (it publishes event *x* to channel *a* and subscribes to events from channel *b*).\n\nConversely, if you are intending on socialising your asynchronous API for use by other developers - it is a more familiar paradigm to describe how external developers can interact with the API. Ultimately, that was the decision for v2.0.0 of the AsyncAPI specification.\n\n# What does this mean for using the spec?\n\nThe [AsyncAPI generator project](https://github.com/asyncapi/generator) is designed to facilitate generation of various assets from an AsyncAPI document - including sample or mock applications. The application generators are primarily written to interpret the API as detailed in this blog post - so a `publish` will generate a Kafka consumer. However, some of the templates have added support for interpreting the document so that a `publish` generates a Kafka producer.  \n  \n\n*   [Java Spring Cloud Stream template](https://github.com/asyncapi/java-spring-cloud-stream-template#parameters) uses the parameter `view=provider` - (`provider` interprets the AsyncAPI document as describing the behaviours the application *provides*)\n*   [Java Spring template](https://github.com/asyncapi/java-spring-template#supported-parameters) use the parameter `inverseOperations=true`\n\n  \n# Summary\n\nAsyncAPI documents describe applications. When reading an AsyncAPI document:\n\n*   `publish` means *publish an event to the channel and this application will receive it*\n*   `subscribe` means *subscribe to this channel to receive events published by this application*\n\nThere is a [GitHub issue](https://github.com/asyncapi/spec/issues/520) raised for discussing these semantics moving forward into the next version of the AsyncAPI specification - please do get involved with the discussion!\n",
    "toc": [
      {
        "content": "In the beginning",
        "slug": "in-the-beginning",
        "lvl": 1,
        "i": 0,
        "seen": 0
      },
      {
        "content": "What about AsyncAPI?",
        "slug": "what-about-asyncapi",
        "lvl": 1,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Where's the confusion?",
        "slug": "wheres-the-confusion",
        "lvl": 1,
        "i": 2,
        "seen": 0
      },
      {
        "content": "What does this mean for using the spec?",
        "slug": "what-does-this-mean-for-using-the-spec",
        "lvl": 1,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Summary",
        "slug": "summary",
        "lvl": 1,
        "i": 4,
        "seen": 0
      }
    ],
    "slug": "/blog/publish-subscribe-semantics",
    "filePath": "pages/blog/publish-subscribe-semantics.md"
  },
  {
    "meta": {
      "title": "Creating AsyncAPI for WebSocket API - Step by Step",
      "date": "2021-04-21T05:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "WebSocket"
      ],
      "cover": "/img/posts/websocket-part2/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "excerpt": "Learn how to create a complex AsyncAPI document using WebSocket API as an example.",
      "readingTime": 23
    },
    "content": "\n>  This step-by-step guide is a continuation of a series of articles about WebSockets. I recommend reading [WebSocket, Shrek, and AsyncAPI - An Opinionated Intro](/blog/websocket-part1) first.\n\nIf you do not want to read this article, then watch the recording of the live stream about the same:\n<YouTube id=\"8tFBcf31e_c\" />\n\nAll roads lead to Rome, but all those roads are different. First, you need to identify where you are and what is the purpose of your journey. What is your goal? What do you want to use AsyncAPI for?\n\nYou may invest in using the specification for many different reasons, like for example:\n- documentation\n- testing\n- mocking\n- code generation\n- message validation\n\nDepending on your goal, you might need to take different roads to get there. If your only goal is documentation, you might take a different approach to writing an AsyncAPI file than you would take while thinking about code generation.\n\n## Choosing the right road to Rome\n\nLet's say AsyncAPI does not fully cover your use case. You are missing some extra property. You are disappointed that you cannot explicitly provide information that your production servers both support different channels. Server A supports channel AA and AB, while Server B supports channel BA and BB. It is not currently possible with the specification as the assumption is that your application communicates with servers that support the same channels.\n\nThere are two roads to Rome:\n\nRoad **docs-only**: You need AsyncAPI for docs generation only and have no intention of sharing the source document with anyone. It means you do not need to bother much about inventing some specification extension. You can just add missing information to the description of a given object.\n\nRoad **automation**: You need AsyncAPI for docs and code generation, which means that all details in your AsyncAPI document must be machine-readable. You can't just put unsupported information in the description.\n\n## Kraken API use case\n\nI'm going to guide you through the process of creating an AsyncAPI document. I'll use the example of Kraken API mentioned in my [previous article](/blog/websocket-part1).\n\nThe challenge I had here was that I'm trying to document an API basing on public docs with no access to a subject matter expert. I also have zero understanding of the cryptocurrency industry and still do not fully understand the vocabulary. \n\n> **Message to Kraken API developers and technical writers** <br/>\nIn case you want to continue the work I started on the AsyncAPI document for Kraken API, feel free to do that. I'm happy to help, just let me know. Reach me out in our [AsyncAPI Slack workspace](https://www.asyncapi.com/slack-invite/).\n\nMore interesting here are the technical challenges though, caused by the fact that Kraken's API:\n- has two production servers for non-secure and secure message exchange\n- some messages are supported only by the public and some only by a private server\n- has just one entry point for communication. You do not get specific messages from one of many endpoints. You get specific messages after first sending a subscription message. Meaning you have a request message and you get a reply message, so something that is not yet possible to describe with AsyncAPI in a machine-readable way\n\n## Writing a single AsyncAPI document\n\nBecause of all these different challenges, I took the **docs-only** road described in section [Choosing the right road to Rome](#choosing-the-right-road-to-rome). No worries though, I give tips for the **automation** road too.\n\n### Basic information about the API\n\nFirst, provide some basic information that every good AsyncAPI file should have:\n- What AsyncAPI version do you use?\n- What is the name of your API?\n- What version of the API you describe?\n- Do not underestimate the description. Optional != not needed. AsyncAPI supports markdown in descriptions. Provide long generic documentation for your API. Benefit from markdown features to structure it, so it is easier to read\n\n> In case you think using just one property to add overarching documentation for your API is very limiting, I agree with you :smiley: Join discussion [here](https://github.com/asyncapi/extensions-catalog/issues/11). I believe spec should have better support for docs, and we should first explore it with specification extensions. To be honest, I always thought documentation deserves its specification, but I don't want to bother you with my wicked visions now.\n\n\n```yaml\nasyncapi: 2.0.0\ninfo:\n  title: Kraken Websockets API\n  version: '1.8'\n  description: |\n    WebSockets API offers real-time market data updates. WebSockets is a bidirectional protocol offering fastest real-time data, helping you build real-time applications. The public message types presented below do not require authentication. Private-data messages can be subscribed on a separate authenticated endpoint. \n\n    ### General Considerations\n\n    - TLS with SNI (Server Name Indication) is required in order to establish a Kraken WebSockets API connection. See Cloudflare's [What is SNI?](https://www.cloudflare.com/learning/ssl/what-is-sni/) guide for more details.\n    - All messages sent and received via WebSockets are encoded in JSON format.\n    - All decimal fields (including timestamps) are quoted to preserve precision.\n    - Timestamps should not be considered unique and not be considered as aliases for transaction IDs. Also, the granularity of timestamps is not representative of transaction rates.\n    - At least one private message should be subscribed to keep the authenticated client connection open.\n    - Please use REST API endpoint [AssetPairs](https://www.kraken.com/features/api#get-tradable-pairs) to fetch the list of pairs which can be subscribed via WebSockets API. For example, field 'wsname' gives the supported pairs name which can be used to subscribe.\n    - Cloudflare imposes a connection/re-connection rate limit (per IP address) of approximately 150 attempts per rolling 10 minutes. If this is exceeded, the IP is banned for 10 minutes.\n    - Recommended reconnection behaviour is to (1) attempt reconnection instantly up to a handful of times if the websocket is dropped randomly during normal operation but (2) after maintenance or extended downtime, attempt to reconnect no more quickly than once every 5 seconds. There is no advantage to reconnecting more rapidly after maintenance during cancel_only mode.\n```\n\n### Provide server information\n\nDescribe how to connect to the API:\n- What is the URL of the server?\n- Is there any authorization in place?\n- What is the protocol requirement, is SSL connection required?\n\nThe Kraken API is an excellent example of how different WebSocket implementations can be and that there is never one way to design your architecture. It all depends on your requirements, the use cases that drive your product.\n\n#### Describing multiple servers\n\nBelow you can notice two different servers. These are not, as you might think, production and development servers. Here you have a clear division between publicly available data and private-only data. In other words, users use two different servers, not channels/paths/endpoints, to talk to the API.\n\n```yaml\nservers:\n  public:\n    url: ws.kraken.com\n    protocol: wss\n    description: |\n      Public server available without authorization.\n      Once the socket is open you can subscribe to a public channel by sending a subscribe request message.\n  private:\n    url: ws-auth.kraken.com\n    protocol: wss\n    description: |\n      Private server that requires authorization.\n      Once the socket is open you can subscribe to private-data channels by sending an authenticated subscribe request message.\n```\n\nYou can verify if above is true by connecting to **ws.kraken.com** and trying to subscribe to one of the event streams that require a token: \n```json\n{ \"event\": \"subscribe\",  \"subscription\": { \"name\": \"ownTrades\", \"token\": \"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\" } }\n```\n\nIn response you get an error:\n```json\n{\"errorMessage\":\"Private data and trading are unavailable on this endpoint. Try ws-auth.kraken.com\",\"event\":\"subscriptionStatus\",\"status\":\"error\",\"subscription\":{\"name\":\"ownTrades\",\"token\":\"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\"}}\n```\n\n> In the documentation, they also indicate beta servers like `beta-ws.kraken.com`. It is hard to understand their purpose, so I did not put them in the AsyncAPI document. For me, beta means something new, some upgrades, and I would consider writing a separate AsyncAPI document.\n\nIs it reasonable to describe API that has two different production servers in one AsyncAPI? As usual, it depends. For **docs-only** road described in section [Choosing the right road to Rome](#choosing-the-right-road-to-rome), you can \"workaround\" some AsyncAPI features if they do not support your use case. Check out, for example, what I had to do in section [Server security](#server-security) where I was not sure how to describe the specific security of the private server. Short answer: just extend the description.\n\nFor **automation** road described in [Choosing the right road to Rome](#choosing-the-right-road-to-rome) section, you need a machine-readable structure. In case you have messages that can be consumed only by the **private** server, you need a way to specify that the given message can be published only to the **private** server. It is exactly the case with Kraken API.\n\nImagine you want to read the AsyncAPI document in real-time in your server and validate all incoming messages. Take server **ws.kraken.com**. The only way to emit errors like `Private data and trading are unavailable on this endpoint. Try ws-auth.kraken.com` is by writing the code that handles validation manually. You can't generate that as the AsyncAPI file does not specif what messages can go to **ws.kraken.com** and what messages can't.\n\nWhy?\n\nAt the moment, in AsyncAPI, you don't have a way to \"wire\" a server with a message, operation, or a channel. There are no default properties that allow you to provide information that message with the name **ownTrades** can only be sent to `ws-auth.kraken.com` server.\n\nSolution?\n\nCreate two AsyncAPI documents. Treat those two servers as separate services that share messages and schemas. Use **$ref** feature to [cross-reference schemas](/blog/organizing-asyncapi-documents).\n\n#### Server security\n\nYou can use AsyncAPI also to describe the security of your API. You can describe in a machine-readable way the security mechanism that protects the server. Several [security schemes](https://github.com/asyncapi/spec/blob/master/spec/asyncapi.md#securitySchemeObject) are supported. In Kraken's case, I could not figure out what kind of security scheme they use from their docs.  They seem to have a non-standard set up for getting the authorization token, which is why the only option was to put a human-readable-only description there.\n\n```yaml\nservers:\n  public:\n    url: ws.kraken.com\n    protocol: wss\n    description: |\n      Public server available without authorization.\n      Once the socket is open, you can subscribe to a public channel by sending a subscribe request message.\n  private:\n    url: ws-auth.kraken.com\n    protocol: wss\n    description: |\n      Private server that requires authorization.\n      Once the socket is open, you can subscribe to private-data channels by sending an authenticated subscribe request message.\n\n      The API client must request an authentication \"token\" via the following REST API endpoint \"GetWebSocketsToken\" to connect to WebSockets Private endpoints. For more details, read https://support.kraken.com/hc/en-us/articles/360034437672-How-to-retrieve-a-WebSocket-authentication-token-Example-code-in-Python-3\n\n      The resulting token must be provided in the \"token\" field of any new private WebSocket feed subscription: \n      ```\n      {\n        \"event\": \"subscribe\",\n        \"subscription\":\n        {\n          \"name\": \"ownTrades\",\n          \"token\": \"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\"\n        }\n      }\n      ```\n```\n\n### Endpoints aka Channels\n\nI saw WebSocket APIs that provide different streams of messages on separate endpoints. It is often the case when you build the WebSocket API for the frontend only and design it for different UI views. In the case of Kraken API we have no endpoints. You connect to the root of the server.\n\nNo matter what setup you have, just remember you should use **channels** to describe it. In the case of connecting to the root, it is as simple as:\n\n```yaml\nchannels:\n  /:\n```\n\n### Multiple different messages on the same channel\n\nYou can have one or many different messages coming to your channel. Like in the case of Kraken API, you can even have multiple messages, incoming and outgoing. You can describe it using **oneOf** on **message** object as you can see below:\n\n```yaml\nchannels:\n  /:\n    publish:\n      operationId: sendMessage\n      message:\n        oneOf:\n          - $ref: '#/components/messages/ping'\n          - $ref: '#/components/messages/subscribe'\n          - $ref: '#/components/messages/unsubscribe'\n    subscribe:\n      operationId: processMessage\n      message:\n        oneOf:\n          - $ref: '#/components/messages/pong'\n          - $ref: '#/components/messages/heartbeat'\n          - $ref: '#/components/messages/systemStatus'\n          - $ref: '#/components/messages/subscriptionStatus'\n```\n\nHold on! Where did these **publish** and **subscribe** keywords came from. \n\nWhen we talk about WebSocket, we usually do not use words like subscribe and publish, as we do not think about producers and consumers. Just check out [the protocol RfC](https://tools.ietf.org/html/rfc6455). We are used to **sending** and **receiving** messages.\n\nLet me present to you an unofficial AsyncAPI vocabulary translator for WebSocket users :smiley:\n\nWebSocket term | AsyncAPI term | Meaning from API server perspective | Meaning from API user perspective\n---|---|---|---\nSend | Publish | The API server receives the given message. | The API user can send a given message to the API server.\nReceive | Subscribe | The API server sends a given message. | The API user can receive a given message from the API server.\n\n### Messages definition\n\nIn event-driven architectures (EDA) it's all about the event, right? The message passed in the system. You need to specify many details about the message, like its payload structure, headers, purpose, and many others. \n\nAbove all, always remember to have good examples. Please don't count on the autogenerated ones, as in most cases, they're useless. \n\n```yml\nmessages:\n  systemStatus:\n    description: Status sent on connection or system status changes.\n    payload:\n      $ref: '#/components/schemas/systemStatus'\n    examples:\n      - payload:\n          connectionID: 8628615390848610000\n          event: systemStatus\n          status: online\n          version: 1.0.0\n```\n\n### Describe responses - specification extensions\n\nDescribe responses? What responses? \n\nIt is EDA. Who cares about responses, right? Fire and forget rules!\n\nThe thing is that request and reply pattern is also used in EDA. This is also the case with Kraken API where communication goes through a single channel with multiple different messages. One message triggers another message in response.\n\nThe simplest example is the message **ping** that triggers a **pong** reply. The current AsyncAPI limitation is that you cannot specify that once the user sends (publish) message **ping**, the **pong** message is received in a reply. Look at this [thread](https://github.com/asyncapi/spec/issues/94) to participate in an ongoing discussion about request/reply pattern support in AsyncAPI.\n\nFor **docs-only** road from section [Choosing the right road to Rome](#choosing-the-right-road-to-rome), I would be lazy and just put such info in the description of both messages. Even though this is an error-prone approach, I would just make my life easier. For **automation** road I would choose to use a specification extension.\n\nWhat is specification extension?\n\nYou can extend every AsyncAPI object in the AsyncAPI document with extra properties. You only need to prefix them with `x-`. You can also share extensions or reuse extensions from others thanks to [extensions catalog](https://github.com/asyncapi/extensions-catalog).\n\nIn the below document, you will notice that for the request/reply pattern, I use AsyncAPI specification extensions called **x-response**.\n\n```yml\nmessages:\n  ping:\n    summary: Ping server to determine whether connection is alive\n    description: Client can ping server to determine whether connection is alive, server responds with pong. This is an application level ping as opposed to default ping in websockets standard which is server initiated\n    payload:\n      $ref: '#/components/schemas/ping'\n    x-response:\n      $ref: '#/components/messages/pong'\n```\n\nEven though the reference to another object is provided inside the extension that is not part of AsyncAPI, our parser will resolve it correctly. It means that under **x-response** property, I will have access to the entire message object.\n\n### Schemas vs JSON Schema\n\nBecause the message itself is most important in the entire EDA, you need to describe the message payload properly. \n\nAsyncAPI allows you to provide payload information in different schema formats. The default format is AsyncAPI Schema that is a superset of JSON Schema. You can use others too, like Avro, for example.\n\nFrom the AsyncAPI document point of view, the most important is that you can reuse schemas. In other words, instead of providing data directly to the **payload** object, you can **$ref** them from **components.schemas** or even an external document. Just DRY, right?\n\nThe rest, I would say, has nothing to do with AsyncAPI itself. How you structure schemas depends on you and the schema format that you use. It is why the next sections of my article describe something specific, not for the AsyncAPI itself but rather JSON Schema.\n\nSimplest example of schemas from Kraken API is a payload for **ping** message:\n\n```yml\nschemas:\n  ping:\n    type: object\n    properties:\n      event:\n        type: string\n        const: ping\n      reqid:\n        $ref: '#/components/schemas/reqid'\n    required:\n      - event\n  reqid:\n    type: integer\n    description: client originated ID reflected in response message.\n```\n\nYou can see that **ping** message is an object that has two properties where only one is required. One property is used across other messages, so is part of many different schemas, so better to keep its definition as a separate schema and reference where needed.\n\n### Schemas complexity\n\nSplitting schemas into reusable chunks with **$ref** usage is not something complex. It gets complex when messages are complex, when you get different message payload depending on system behavior.\n\nKraken API has a **subscriptionStatus** message where payload depends on the success of the subscription. In case of successful subscription, you get a message with **channelID** and **channelName** properties, but in case of failure, the message doesn't contain these properties but in exchange has **errorMessage**. In other words, some properties are mutually exclusive.\n\n```yml\n    subscriptionStatus:\n      type: object\n      oneOf:\n        - required:\n            - errorMessage\n          not:\n            required:\n                - channelID\n                - channelName\n        - required:\n            - channelID\n            - channelName\n          not:\n            required:\n                - errorMessage\n      properties:\n        channelID:\n          type: integer\n          description: ChannelID on successful subscription, applicable to public messages only.\n        channelName:\n          type: string\n          description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n        errorMessage:\n          type: string\n        event:\n          type: string\n          const: subscriptionStatus\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        status:\n          $ref: '#/components/schemas/status'\n        subscription:\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            maxratecount:\n              $ref: '#/components/schemas/maxratecount'\n            name:\n              $ref: '#/components/schemas/name'\n            token:\n              $ref: '#/components/schemas/token'\n          required:\n            - name\n      required:\n        - event\n```\n\nIt is what I call a complex schema, where good JSON Schema knowledge is needed. The problem with complex schemas is that not many tools support these kinds of schemas. By the time I write this article, our AsyncAPI tools for documentation rendering will fail to render the above schema correctly.\n\nIt is why you sometimes need compromises and adjusts schemas, so they get proper tooling support. Below you can see the same schema but structured in a more straightforward way supported by most tools.\n\n```yml\n    subscriptionStatus:\n      type: object\n      oneOf:\n        - $ref: '#/components/schemas/subscriptionStatusError'\n        - $ref: '#/components/schemas/subscriptionStatusSuccess'\n    subscriptionStatusError:\n      allOf:\n        - properties:\n            errorMessage:\n              type: string\n          required:\n            - errorMessage\n        - $ref: '#/components/schemas/subscriptionStatusCommon'\n    subscriptionStatusSuccess:\n      allOf:\n        - properties:\n            channelID:\n              type: integer\n              description: ChannelID on successful subscription, applicable to public messages only.\n            channelName:\n              type: string\n              description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n          required:\n            - channelID\n            - channelName\n        - $ref: '#/components/schemas/subscriptionStatusCommon'\n    subscriptionStatusCommon:\n      type: object\n      required:\n         - event\n      properties:\n        event:\n          type: string\n          const: subscriptionStatus\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        status:\n          $ref: '#/components/schemas/status'\n        subscription:\n          required:\n            - name\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            maxratecount:\n              $ref: '#/components/schemas/maxratecount'\n            name:\n              $ref: '#/components/schemas/name'\n            token:\n              $ref: '#/components/schemas/token'\n```\n\nI managed to get a structure that will be nicely rendered in the UI. Even code generation will work well. It is a bit more complex than initial structure, although this is rather subjective personal-taste-like opinion.\n\n### Let's have a look at the final document\n\nWebsocket protocol is very flexible, and therefore you can implement the server in many different ways. The path that Kraken API took is complex but not impossible to describe with the AsyncAPI document. Look at the document's final structure and keep in mind that it is not a complete document for Kraken API and the road that I chose to get to Rome was to focus on documentation rendering only. \n\nFor **automation** road described in section [Choosing the right road to Rome](#choosing-the-right-road-to-rome), the document should be split into two documents: one for private and one for public servers. Common parts, like common messages and schemas, should be stored in separate files and referred from these two AsyncAPI documents using **$ref**. Another solution would be to use specification extensions to describe relations between messages and servers.\n\n> You can open this document directly in Playground by clicking [this](https://playground.asyncapi.io?url=https://gist.githubusercontent.com/derberg/4e419d6ff5870c7c3f5f443e8bd30535/raw/5e9b733b80a0209ba5520e5f41ab18c2a112e0a9/asyncapi-websocket-kraken.yml) link. Compare it also with the [oryginal documentation](https://docs.kraken.com/websockets/).\n\n```yml\nasyncapi: 2.0.0\n\ninfo:\n  title: Kraken Websockets API\n  version: '1.8.0'\n  description: |\n    WebSockets API offers real-time market data updates. WebSockets is a bidirectional protocol offering fastest real-time data, helping you build real-time applications. The public message types presented below do not require authentication. Private-data messages can be subscribed on a separate authenticated endpoint. \n\n    ### General Considerations\n\n    - TLS with SNI (Server Name Indication) is required in order to establish a Kraken WebSockets API connection. See Cloudflare's [What is SNI?](https://www.cloudflare.com/learning/ssl/what-is-sni/) guide for more details.\n    - All messages sent and received via WebSockets are encoded in JSON format\n    - All decimal fields (including timestamps) are quoted to preserve precision.\n    - Timestamps should not be considered unique and not be considered as aliases for transaction IDs. Also, the granularity of timestamps is not representative of transaction rates.\n    - At least one private message should be subscribed to keep the authenticated client connection open.\n    - Please use REST API endpoint [AssetPairs](https://www.kraken.com/features/api#get-tradable-pairs) to fetch the list of pairs which can be subscribed via WebSockets API. For example, field 'wsname' gives the supported pairs name which can be used to subscribe.\n    - Cloudflare imposes a connection/re-connection rate limit (per IP address) of approximately 150 attempts per rolling 10 minutes. If this is exceeded, the IP is banned for 10 minutes.\n    - Recommended reconnection behaviour is to (1) attempt reconnection instantly up to a handful of times if the websocket is dropped randomly during normal operation but (2) after maintenance or extended downtime, attempt to reconnect no more quickly than once every 5 seconds. There is no advantage to reconnecting more rapidly after maintenance during cancel_only mode.\n\nservers:\n  public:\n    url: ws.kraken.com\n    protocol: wss\n    description: |\n      Public server available without authorization.\n      Once the socket is open you can subscribe to a public channel by sending a subscribe request message.\n  private:\n    url: ws-auth.kraken.com\n    protocol: wss\n    description: |\n      Private server that requires authorization.\n      Once the socket is open you can subscribe to private-data channels by sending an authenticated subscribe request message.\n\n      The API client must request an authentication \"token\" via the following REST API endpoint \"GetWebSocketsToken\" to connect to WebSockets Private endpoints. For more details read https://support.kraken.com/hc/en-us/articles/360034437672-How-to-retrieve-a-WebSocket-authentication-token-Example-code-in-Python-3\n\n      The resulting token must be provided in the \"token\" field of any new private WebSocket feed subscription: \n      ```\n      {\n        \"event\": \"subscribe\",\n        \"subscription\":\n        {\n          \"name\": \"ownTrades\",\n          \"token\": \"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\"\n        }\n      }\n      ```\n\nchannels:\n  /:\n    publish:\n      description: Send messages to the API\n      operationId: processReceivedMessage\n      message:\n        oneOf:\n          - $ref: '#/components/messages/ping'\n          - $ref: '#/components/messages/subscribe'\n          - $ref: '#/components/messages/unsubscribe'\n\n    subscribe:\n      description: Messages that you receive from the API\n      operationId: sendMessage\n      message:\n        oneOf:\n          - $ref: '#/components/messages/pong'\n          - $ref: '#/components/messages/heartbeat'\n          - $ref: '#/components/messages/systemStatus'\n          - $ref: '#/components/messages/subscriptionStatus'\n\ncomponents:\n  messages:\n    ping:\n      summary: Ping server to determine whether connection is alive\n      description: Client can ping server to determine whether connection is alive, server responds with pong. This is an application level ping as opposed to default ping in websockets standard which is server initiated\n      payload:\n        $ref: '#/components/schemas/ping'\n      x-response:\n        $ref: '#/components/messages/pong'\n    heartbeat:\n      description: Server heartbeat sent if no subscription traffic within 1 second (approximately)\n      payload:\n        $ref: '#/components/schemas/heartbeat'\n    pong:\n      summary: Pong is a response to ping message\n      description: Server pong response to a ping to determine whether connection is alive. This is an application level pong as opposed to default pong in websockets standard which is sent by client in response to a ping\n      payload:\n        $ref: '#/components/schemas/pong'\n    systemStatus:\n      description: Status sent on connection or system status changes.\n      payload:\n        $ref: '#/components/schemas/systemStatus'\n      examples:\n        - payload:\n            connectionID: 8628615390848610000\n            event: systemStatus\n            status: online\n            version: 1.0.0\n    subscribe:\n      description: Subscribe to a topic on a single or multiple currency pairs.\n      payload:\n        $ref: '#/components/schemas/subscribe'\n      examples:\n        - payload:\n            event: subscribe\n            pair:\n              - XBT/USD\n              - XBT/EUR\n            subscription:\n              name: ticker\n        - payload:\n            event: subscribe\n            subscription:\n              name: ownTrades\n              token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n      x-response:\n        $ref: '#/components/messages/subscriptionStatus'\n    unsubscribe:\n      description: Unsubscribe, can specify a channelID or multiple currency pairs.\n      payload:\n        $ref: '#/components/schemas/subscribe'\n      examples:\n        - payload:\n            event: unsubscribe\n            pair:\n              - XBT/EUR\n              - XBT/USD\n            subscription:\n              name: ticker\n        - payload:\n            event: unsubscribe\n            subscription:\n              name: ownTrades\n              token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n      x-response:\n        $ref: '#/components/messages/subscriptionStatus'\n    subscriptionStatus:\n      description: Subscription status response to subscribe, unsubscribe or exchange initiated unsubscribe.\n      payload:\n        $ref: '#/components/schemas/subscriptionStatus'\n      examples:\n        - payload:\n            channelID: 10001\n            channelName: ohlc-5\n            event: subscriptionStatus\n            pair: XBT/EUR\n            reqid: 42\n            status: unsubscribed\n            subscription:\n              interval: 5\n              name: ohlc\n        - payload:\n            errorMessage: Subscription depth not supported\n            event: subscriptionStatus\n            pair: XBT/USD\n            status: error\n            subscription:\n              depth: 42\n              name: book\n\n  schemas:\n    ping:\n      type: object\n      properties:\n        event:\n          type: string\n          const: ping\n        reqid:\n          $ref: '#/components/schemas/reqid'\n      required:\n        - event\n    heartbeat:\n      type: object\n      properties:\n        event:\n          type: string\n          const: heartbeat\n    pong:\n      type: object\n      properties:\n        event:\n          type: string\n          const: pong\n        reqid:\n          $ref: '#/components/schemas/reqid'\n    systemStatus:\n      type: object\n      properties:\n        event:\n          type: string\n          const: systemStatus\n        connectionID:\n          type: integer\n          description: The ID of the connection\n        status:\n          $ref: '#/components/schemas/status'\n        version:\n          type: string\n    status:\n      type: string\n      enum:\n        - online\n        - maintenance\n        - cancel_only\n        - limit_only\n        - post_only\n    subscribe:\n      type: object\n      properties:\n        event:\n          type: string\n          const: subscribe\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        subscription:\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            name:\n              $ref: '#/components/schemas/name'\n            ratecounter:\n              $ref: '#/components/schemas/ratecounter'\n            snapshot:\n              $ref: '#/components/schemas/snapshot'\n            token:\n              $ref: '#/components/schemas/token'\n          required:\n            - name\n      required:\n        - event\n    unsubscribe:\n      type: object\n      properties:\n        event:\n          type: string\n          const: unsubscribe\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        subscription:\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            name:\n              $ref: '#/components/schemas/name'\n            token:\n              $ref: '#/components/schemas/token'\n          required:\n            - name\n      required:\n        - event\n    subscriptionStatus:\n      type: object\n      oneOf:\n        - $ref: '#/components/schemas/subscriptionStatusError'\n        - $ref: '#/components/schemas/subscriptionStatusSuccess'\n    subscriptionStatusError:\n      allOf:\n        - properties:\n            errorMessage:\n              type: string\n          required:\n            - errorMessage\n        - $ref: '#/components/schemas/subscriptionStatusCommon'\n    subscriptionStatusSuccess:\n      allOf:\n        - properties:\n            channelID:\n              type: integer\n              description: ChannelID on successful subscription, applicable to public messages only.\n            channelName:\n              type: string\n              description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n          required:\n            - channelID\n            - channelName\n        - $ref: '#/components/schemas/subscriptionStatusCommon'\n    subscriptionStatusCommon:\n      type: object\n      required:\n         - event\n      properties:\n        event:\n          type: string\n          const: subscriptionStatus\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        status:\n          $ref: '#/components/schemas/status'\n        subscription:\n          required:\n            - name\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            maxratecount:\n              $ref: '#/components/schemas/maxratecount'\n            name:\n              $ref: '#/components/schemas/name'\n            token:\n              $ref: '#/components/schemas/token'\n    interval:\n      type: integer\n      description: Time interval associated with ohlc subscription in minutes.\n      default: 1\n      enum:\n        - 1\n        - 5\n        - 15\n        - 30\n        - 60\n        - 240\n        - 1440\n        - 10080\n        - 21600\n    name:\n      type: string\n      description: The name of the channel you subscribe too.\n      enum:\n        - book\n        - ohlc\n        - openOrders\n        - ownTrades\n        - spread\n        - ticker\n        - trade\n    token:\n      type: string\n      description: base64-encoded authentication token for private-data endpoints.\n    depth:\n      type: integer\n      default: 10\n      enum:\n        - 10\n        - 25\n        - 100\n        - 500\n        - 1000\n      description: Depth associated with book subscription in number of levels each side.\n    maxratecount:\n      type: integer\n      description: Max rate-limit budget. Compare to the ratecounter field in the openOrders updates to check whether you are approaching the rate limit.\n    ratecounter:\n      type: boolean\n      default: false\n      description: Whether to send rate-limit counter in updates (supported only for openOrders subscriptions)\n    snapshot:\n      type: boolean\n      default: true\n      description: Whether to send historical feed data snapshot upon subscription (supported only for ownTrades subscriptions)\n    reqid:\n      type: integer\n      description: client originated ID reflected in response message.\n    pair:\n      type: array\n      description: Array of currency pairs.\n      items:\n        type: string\n        description: Format of each pair is \"A/B\", where A and B are ISO 4217-A3 for standardized assets and popular unique symbol if not standardized.\n        pattern: '[A-Z\\s]+\\/[A-Z\\s]+'\n```\n\nStay tuned for more articles around WebSocket and AsyncAPI. Share your feedback and connect with the AsyncAPI community in our [Slack workspace](https://www.asyncapi.com/slack-invite/).\n",
    "toc": [
      {
        "content": "Choosing the right road to Rome",
        "slug": "choosing-the-right-road-to-rome",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Kraken API use case",
        "slug": "kraken-api-use-case",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Writing a single AsyncAPI document",
        "slug": "writing-a-single-asyncapi-document",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Basic information about the API",
        "slug": "basic-information-about-the-api",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Provide server information",
        "slug": "provide-server-information",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Describing multiple servers",
        "slug": "describing-multiple-servers",
        "lvl": 4,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Server security",
        "slug": "server-security",
        "lvl": 4,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Endpoints aka Channels",
        "slug": "endpoints-aka-channels",
        "lvl": 3,
        "i": 7,
        "seen": 0
      },
      {
        "content": "Multiple different messages on the same channel",
        "slug": "multiple-different-messages-on-the-same-channel",
        "lvl": 3,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Messages definition",
        "slug": "messages-definition",
        "lvl": 3,
        "i": 9,
        "seen": 0
      },
      {
        "content": "Describe responses - specification extensions",
        "slug": "describe-responses---specification-extensions",
        "lvl": 3,
        "i": 10,
        "seen": 0
      },
      {
        "content": "Schemas vs JSON Schema",
        "slug": "schemas-vs-json-schema",
        "lvl": 3,
        "i": 11,
        "seen": 0
      },
      {
        "content": "Schemas complexity",
        "slug": "schemas-complexity",
        "lvl": 3,
        "i": 12,
        "seen": 0
      },
      {
        "content": "Let's have a look at the final document",
        "slug": "lets-have-a-look-at-the-final-document",
        "lvl": 3,
        "i": 13,
        "seen": 0
      }
    ],
    "slug": "/blog/websocket-part2",
    "filePath": "pages/blog/websocket-part2.md"
  },
  {
    "meta": {
      "title": "WebSocket, Shrek, and AsyncAPI - An Opinionated Intro",
      "date": "2021-04-16T05:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "WebSocket"
      ],
      "cover": "/img/posts/websocket-part1/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "excerpt": "WebSocket is a protocol, an industry standard for building client applications that users love to use. What does AsyncAPI have to do with it?",
      "readingTime": 14
    },
    "content": "\nThis is a pretty subjective post. I'm sharing my perspective, taking into account years of experience building backend and frontend with user experience in mind. \n\nIf you do not want to read this article, then watch the recording of the live stream about the same:\n<YouTube id=\"8tFBcf31e_c\" />\n\n>  Everything we hear is an opinion, not a fact. Everything we see is a perspective, not the truth.\n― [Marcus Aurelius](https://www.politifact.com/factchecks/2019/sep/26/viral-image/no-marcus-aurelius-didnt-say-about-opinions-and-fa/)\n\nThis blog post is the first of a series of blog posts about WebSocket I'm working on.\n\n## What is WebSocket\n\nIt is a pretty old protocol used for duplex communication over TCP connection. It was standardized in 2011. Yes, ten years ago means it is old, super old. \n\nSo why do I even mention it in 2021? \n\nIt is very widely adopted and will not go away anytime soon because tooling support is excellent and serves its purpose well. Just remind yourself when HTTP/2 showed up and how many years it took everyone to migrate. It would not happen without the strong support and push from all the big players. \n\nSure, there is [HTTP/2 multiplexing](https://developers.google.com/web/fundamentals/performance/http2/#request_and_response_multiplexing) and protocols like [Mercure](https://mercure.rocks/docs/mercure) or [GraphQL Subscription](https://spec.graphql.org/June2018/#sec-Subscription). There is also [RFC8441](https://tools.ietf.org/html/rfc8441) for WebSocket and HTTP/2 and some tools already adopted it, like [Envoy](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/upgrades) or [Jetty](https://github.com/eclipse/jetty.project/issues/3537). Nevertheless, WebSocket is here to stay.\n\nAnyway, the future of WebSocket has nothing to do with this post. This post is for the AsyncAPI community looking into the AsyncAPI spec because of WebSockets now, no matter the protocol's future.\n\n## Websocket use case\n\n- Do you like to see in Slack that someone is typing a response? \n- Do you like it when a user interface updates without page refresh?\n- Do you like it when your client app knows there are updates available for display?\n\nThat is what WebSocket is for. You establish a long-living connection between client and server. Through such a connection, the client can send a stream of messages to the server, and this is possible the other way around at the same time.\n\nOne could say: _I don't need WebSocket to achieve that. I could just set up a data polling with REST API. Just ask the API every few seconds if there are updates._\n\nSadly this is not a joke. Engineers do it. Some engineers just take shortcuts, mostly because deadlines hunt them down.\n\nHTTP polling was presented very well in Shrek's famous _Are we there yet?_ scene.\n\n<YouTube id=\"basofea2UEs\" />\n\nDon't go that path. Do not perform unnecessary connections to your servers and create more and more traffic with more and more resource consumption. Wasting resources is bad and makes Shrek angry. WebSocket changes a lot there:\n\n<Figure\n  src=\"/img/posts/websocket-part1/websocket-shrek.webp\"\n  caption=\"Figure 1: HTTP Pull vs WebSocket vs Shrek.\"\n/>\n\n## Why AsyncAPI\n\nWhen building a WebSocket API on a server, you might have some additional needs:\n- Want to document the API for the team that writes a client app, Web UI, Desktop app, or Mobile app. \n- Want to have a way to specify the format of the messages that the server supports to validate them in the runtime.\n- Want to generate a server or/and a client? If not for final production use, then for sure for prototyping and testing.\n\nThese are just a few common needs. For WebSocket, you only establish a connection over HTTP protocol, and the rest goes over WS, so OpenAPI specification won't help you much here. WebSocket is one of the patterns in event-based systems. In the end, it is all about a stream of messages and asynchronous processing. Yes, it would be best to use AsyncAPI :smiley:\n\n## WebSocket described with AsyncAPI\n\nWhen I google for some public WebSocket API to play with, I find mostly currency trading products:\n- [Kraken WebSocket API](https://docs.kraken.com/websockets/)\n- [Gemini WebSocket API](https://docs.gemini.com/websocket-api/)\n- [CEXIO Websocket API](https://cex.io/websocket-api)\n\nCurrency trading is a topic I know nothing about :man_shrugging: but it feels interesting to explore more. Documentation of the 1st and 2nd API looks familiar from look&feel perspective. I think we can make a bet they are already using AsyncAPI, and Kraken most probably is still running on version 1. Let's release the Kraken then.\n\n> I'm sorry if you expected me to describe Shrek's API interface using AsyncAPI. It would be fun, but only fun, and I'd also like to teach you something.\n\nI will write an AsyncAPI document for Kraken API after playing with the API and basing it on the [current documentation](https://docs.kraken.com/websockets/).\n\n### Playing with WebSocket API\n\nThe best way to play with a WebSocket API is through a CLI. Who didn't hear about **curl** in the REST API world? For WebSocket, I would recommend **websocat**. Kraken's API is partially public without authorization which is just great because to play with it, you do not have to set up an account to get an authorization token.\n\n1. Install **websocat**. For other installation options, check out [this](https://github.com/vi/websocat#installation) list.\n  ```sh\n  brew install websocat\n  ```\n1. Establish connection with the API:\n  ```sh\n  websocat wss://ws.kraken.com\n    ```\n1. Ping the API to see if it responds. Just type the below message and hit Enter:\n  ```json\n  {\"event\": \"ping\"}\n  ```\n1. Now subscribe to the event **ticker** stream that sends messages with currency price. Just type the below message and hit Enter:\n  ```json\n  {  \"event\": \"subscribe\",  \"pair\": [    \"XBT/USD\",    \"XBT/EUR\"  ],  \"subscription\": {    \"name\": \"ticker\"  }}\n  ```\n1. You should now see a constant stream of data sent by the server. You do not have to ask the API every second for an update, as the update is pushed to you.\n  ```json\n  {\"event\":\"heartbeat\"}\n  [340,{\"a\":[\"45520.10000\",6,\"6.78103490\"],\"b\":[\"45520.00000\",0,\"0.00185230\"],\"c\":[\"45520.10000\",\"0.01643250\"],\"v\":[\"1397.95434819\",\"5589.12101024\"],\"p\":[\"44883.49461\",\"44062.07654\"],\"t\":[14350,66782],\"l\":[\"43607.60000\",\"42770.80000\"],\"h\":[\"45811.10000\",\"45811.10000\"],\"o\":[\"43659.30000\",\"44709.10000\"]},\"ticker\",\"XBT/EUR\"]\n  [340,{\"a\":[\"45520.10000\",5,\"5.84803490\"],\"b\":[\"45492.50000\",0,\"0.09374582\"],\"c\":[\"45492.50000\",\"0.00625418\"],\"v\":[\"1398.10526819\",\"5589.26685876\"],\"p\":[\"44883.56109\",\"44062.11477\"],\"t\":[14359,66790],\"l\":[\"43607.60000\",\"42770.80000\"],\"h\":[\"45811.10000\",\"45811.10000\"],\"o\":[\"43659.30000\",\"44709.10000\"]},\"ticker\",\"XBT/EUR\"]\n  {\"event\":\"heartbeat\"}\n  [340,{\"a\":[\"45503.80000\",1,\"1.00000000\"],\"b\":[\"45496.20000\",0,\"0.01426600\"],\"c\":[\"45496.20000\",\"0.00109400\"],\"v\":[\"1398.10636219\",\"5589.26295766\"],\"p\":[\"44883.56157\",\"44062.11447\"],\"t\":[14360,66788],\"l\":[\"43607.60000\",\"42770.80000\"],\"h\":[\"45811.10000\",\"45811.10000\"],\"o\":[\"43659.30000\",\"44709.90000\"]},\"ticker\",\"XBT/EUR\"]\n  {\"event\":\"heartbeat\"}\n  ```\n\nBoy, it is always such fun to do it. Like seriously, I always have fun playing with APIs, any APIs. Just making this API \"conversation\". I hope nothing is wrong with me :sweat_smile:\n\nNow you know how to interact with the Kraken API. Now let's try to describe it using AsyncAPI.\n\n### Describing API using AsyncAPI\n\nI'll explain, in detail, how to describe Websocket API with AsyncAPI in another blog post that will be part of the series. Why? I don't want to make this post super lengthy and discourage others from reading it. Let us learn step by step. \n\nFor now, I will throw here a full AsyncAPI document I created for the Kraken API. You can also open it up in the [AsyncAPI Playground](https://playground.asyncapi.io?url=https://gist.githubusercontent.com/derberg/4e419d6ff5870c7c3f5f443e8bd30535/raw/5e9b733b80a0209ba5520e5f41ab18c2a112e0a9/asyncapi-websocket-kraken.yml) and compare with their [current documentation](https://docs.kraken.com/websockets/)\n\nFamiliarize with below before you look at the AsyncAPI document:\n- AsyncAPI describes the API interface between the client and the server. In other words, the AsyncAPI document is for the user of the API. It does not describe what the server does but what the user can do with the API.\n- Kraken API is quite complex. It has some beta servers, some private messages, and messages closely related to vocabulary specific for currency trading. I dropped all of those from my research not to overcomplicate things. In other words, the AsyncAPI file that you can see below is not a complete document.\n- Websocket protocol is very flexible, and therefore you can implement the server in many different ways. There is no standard way of doing things, like there is no common way of doing things with AsyncAPI. We can only make some generic assumptions looking at existing implementations:\n  - Your server has one entry point, just one endpoint that you communicate with to gain access to the API. It can be a [path with some dynamic values](https://ik.imagekit.io/ably/s3/xchg_products/async_api_specs/000/000/019/original/weather.yaml), as some data id. It can also be nothing, no path at all, like in the case of below Kraken API. These entry points are **channels** in AsyncAPI document. Commonly, Websocket API has just one **channel** that user can send messages to and receive messages at the same time\n  - AsyncAPI publish and subscribe operations translates to **messages user can send to the API** and **messages user will receive from the API**. Depending on API complexity, sometimes you have an API that sends [only one message](https://ik.imagekit.io/ably/s3/xchg_products/async_api_specs/000/000/019/original/weather.yaml). You can also have a situation where you can send to the server multiple different messages, and also receive different messages in response. This is when you need to use **oneOf** as I did in document for Kraken API.\n- Current AsyncAPI limitation is that you cannot specify that once the user sends (publish) message **ping**, the **pong** message is a reply. Look at this [thread](https://github.com/asyncapi/spec/issues/94) to participate in an ongoing discussion about request/reply pattern support in AsyncAPI. In the below document, you will notice that for such a use case, I use AsyncAPI specification extensions (**x-response**).\n\n> **Message to Kraken API developers and technical writers** <br/>\nIn case you want to continue the work I started on the AsyncAPI document for Kraken API, feel free to do that. I'm happy to help, just let me know. Reach me out in our [AsyncAPI Slack workspace](https://www.asyncapi.com/slack-invite/).\n\n```yml\nasyncapi: 2.0.0\n\ninfo:\n  title: Kraken Websockets API\n  version: '1.8.0'\n  description: |\n    WebSockets API offers real-time market data updates. WebSockets is a bidirectional protocol offering fastest real-time data, helping you build real-time applications. The public message types presented below do not require authentication. Private-data messages can be subscribed on a separate authenticated endpoint. \n\n    ### General Considerations\n\n    - TLS with SNI (Server Name Indication) is required in order to establish a Kraken WebSockets API connection. See Cloudflare's [What is SNI?](https://www.cloudflare.com/learning/ssl/what-is-sni/) guide for more details.\n    - All messages sent and received via WebSockets are encoded in JSON format\n    - All decimal fields (including timestamps) are quoted to preserve precision.\n    - Timestamps should not be considered unique and not be considered as aliases for transaction IDs. Also, the granularity of timestamps is not representative of transaction rates.\n    - At least one private message should be subscribed to keep the authenticated client connection open.\n    - Please use REST API endpoint [AssetPairs](https://www.kraken.com/features/api#get-tradable-pairs) to fetch the list of pairs which can be subscribed via WebSockets API. For example, field 'wsname' gives the supported pairs name which can be used to subscribe.\n    - Cloudflare imposes a connection/re-connection rate limit (per IP address) of approximately 150 attempts per rolling 10 minutes. If this is exceeded, the IP is banned for 10 minutes.\n    - Recommended reconnection behaviour is to (1) attempt reconnection instantly up to a handful of times if the websocket is dropped randomly during normal operation but (2) after maintenance or extended downtime, attempt to reconnect no more quickly than once every 5 seconds. There is no advantage to reconnecting more rapidly after maintenance during cancel_only mode.\n\nservers:\n  public:\n    url: ws.kraken.com\n    protocol: wss\n    description: |\n      Public server available without authorization.\n      Once the socket is open you can subscribe to a public channel by sending a subscribe request message.\n  private:\n    url: ws-auth.kraken.com\n    protocol: wss\n    description: |\n      Private server that requires authorization.\n      Once the socket is open you can subscribe to private-data channels by sending an authenticated subscribe request message.\n\n      The API client must request an authentication \"token\" via the following REST API endpoint \"GetWebSocketsToken\" to connect to WebSockets Private endpoints. For more details read https://support.kraken.com/hc/en-us/articles/360034437672-How-to-retrieve-a-WebSocket-authentication-token-Example-code-in-Python-3\n\n      The resulting token must be provided in the \"token\" field of any new private WebSocket feed subscription: \n      ```\n      {\n        \"event\": \"subscribe\",\n        \"subscription\":\n        {\n          \"name\": \"ownTrades\",\n          \"token\": \"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\"\n        }\n      }\n      ```\n\nchannels:\n  /:\n    publish:\n      description: Send messages to the API\n      operationId: processReceivedMessage\n      message:\n        oneOf:\n          - $ref: '#/components/messages/ping'\n          - $ref: '#/components/messages/subscribe'\n          - $ref: '#/components/messages/unsubscribe'\n\n    subscribe:\n      description: Messages that you receive from the API\n      operationId: sendMessage\n      message:\n        oneOf:\n          - $ref: '#/components/messages/pong'\n          - $ref: '#/components/messages/heartbeat'\n          - $ref: '#/components/messages/systemStatus'\n          - $ref: '#/components/messages/subscriptionStatus'\n\ncomponents:\n  messages:\n    ping:\n      summary: Ping server to determine whether connection is alive\n      description: Client can ping server to determine whether connection is alive, server responds with pong. This is an application level ping as opposed to default ping in websockets standard which is server initiated\n      payload:\n        $ref: '#/components/schemas/ping'\n      x-response:\n        $ref: '#/components/messages/pong'\n    heartbeat:\n      description: Server heartbeat sent if no subscription traffic within 1 second (approximately)\n      payload:\n        $ref: '#/components/schemas/heartbeat'\n    pong:\n      summary: Pong is a response to ping message\n      description: Server pong response to a ping to determine whether connection is alive. This is an application level pong as opposed to default pong in websockets standard which is sent by client in response to a ping\n      payload:\n        $ref: '#/components/schemas/pong'\n    systemStatus:\n      description: Status sent on connection or system status changes.\n      payload:\n        $ref: '#/components/schemas/systemStatus'\n      examples:\n        - payload:\n            connectionID: 8628615390848610000\n            event: systemStatus\n            status: online\n            version: 1.0.0\n    subscribe:\n      description: Subscribe to a topic on a single or multiple currency pairs.\n      payload:\n        $ref: '#/components/schemas/subscribe'\n      examples:\n        - payload:\n            event: subscribe\n            pair:\n              - XBT/USD\n              - XBT/EUR\n            subscription:\n              name: ticker\n        - payload:\n            event: subscribe\n            subscription:\n              name: ownTrades\n              token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n      x-response:\n        $ref: '#/components/messages/subscriptionStatus'\n    unsubscribe:\n      description: Unsubscribe, can specify a channelID or multiple currency pairs.\n      payload:\n        $ref: '#/components/schemas/subscribe'\n      examples:\n        - payload:\n            event: unsubscribe\n            pair:\n              - XBT/EUR\n              - XBT/USD\n            subscription:\n              name: ticker\n        - payload:\n            event: unsubscribe\n            subscription:\n              name: ownTrades\n              token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n      x-response:\n        $ref: '#/components/messages/subscriptionStatus'\n    subscriptionStatus:\n      description: Subscription status response to subscribe, unsubscribe or exchange initiated unsubscribe.\n      payload:\n        $ref: '#/components/schemas/subscriptionStatus'\n      examples:\n        - payload:\n            channelID: 10001\n            channelName: ohlc-5\n            event: subscriptionStatus\n            pair: XBT/EUR\n            reqid: 42\n            status: unsubscribed\n            subscription:\n              interval: 5\n              name: ohlc\n        - payload:\n            errorMessage: Subscription depth not supported\n            event: subscriptionStatus\n            pair: XBT/USD\n            status: error\n            subscription:\n              depth: 42\n              name: book\n\n  schemas:\n    ping:\n      type: object\n      properties:\n        event:\n          type: string\n          const: ping\n        reqid:\n          $ref: '#/components/schemas/reqid'\n      required:\n        - event\n    heartbeat:\n      type: object\n      properties:\n        event:\n          type: string\n          const: heartbeat\n    pong:\n      type: object\n      properties:\n        event:\n          type: string\n          const: pong\n        reqid:\n          $ref: '#/components/schemas/reqid'\n    systemStatus:\n      type: object\n      properties:\n        event:\n          type: string\n          const: systemStatus\n        connectionID:\n          type: integer\n          description: The ID of the connection\n        status:\n          $ref: '#/components/schemas/status'\n        version:\n          type: string\n    status:\n      type: string\n      enum:\n        - online\n        - maintenance\n        - cancel_only\n        - limit_only\n        - post_only\n    subscribe:\n      type: object\n      properties:\n        event:\n          type: string\n          const: subscribe\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        subscription:\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            name:\n              $ref: '#/components/schemas/name'\n            ratecounter:\n              $ref: '#/components/schemas/ratecounter'\n            snapshot:\n              $ref: '#/components/schemas/snapshot'\n            token:\n              $ref: '#/components/schemas/token'\n          required:\n            - name\n      required:\n        - event\n    unsubscribe:\n      type: object\n      properties:\n        event:\n          type: string\n          const: unsubscribe\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        subscription:\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            name:\n              $ref: '#/components/schemas/name'\n            token:\n              $ref: '#/components/schemas/token'\n          required:\n            - name\n      required:\n        - event\n    subscriptionStatus:\n      type: object\n      oneOf:\n        - $ref: '#/components/schemas/subscriptionStatusError'\n        - $ref: '#/components/schemas/subscriptionStatusSuccess'\n    subscriptionStatusError:\n      allOf:\n        - properties:\n            errorMessage:\n              type: string\n          required:\n            - errorMessage\n        - $ref: '#/components/schemas/subscriptionStatusCommon'\n    subscriptionStatusSuccess:\n      allOf:\n        - properties:\n            channelID:\n              type: integer\n              description: ChannelID on successful subscription, applicable to public messages only.\n            channelName:\n              type: string\n              description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n          required:\n            - channelID\n            - channelName\n        - $ref: '#/components/schemas/subscriptionStatusCommon'\n    subscriptionStatusCommon:\n      type: object\n      required:\n         - event\n      properties:\n        event:\n          type: string\n          const: subscriptionStatus\n        reqid:\n          $ref: '#/components/schemas/reqid'\n        pair:\n          $ref: '#/components/schemas/pair'\n        status:\n          $ref: '#/components/schemas/status'\n        subscription:\n          required:\n            - name\n          type: object\n          properties:\n            depth:\n              $ref: '#/components/schemas/depth'\n            interval:\n              $ref: '#/components/schemas/interval'\n            maxratecount:\n              $ref: '#/components/schemas/maxratecount'\n            name:\n              $ref: '#/components/schemas/name'\n            token:\n              $ref: '#/components/schemas/token'\n    interval:\n      type: integer\n      description: Time interval associated with ohlc subscription in minutes.\n      default: 1\n      enum:\n        - 1\n        - 5\n        - 15\n        - 30\n        - 60\n        - 240\n        - 1440\n        - 10080\n        - 21600\n    name:\n      type: string\n      description: The name of the channel you subscribe too.\n      enum:\n        - book\n        - ohlc\n        - openOrders\n        - ownTrades\n        - spread\n        - ticker\n        - trade\n    token:\n      type: string\n      description: base64-encoded authentication token for private-data endpoints.\n    depth:\n      type: integer\n      default: 10\n      enum:\n        - 10\n        - 25\n        - 100\n        - 500\n        - 1000\n      description: Depth associated with book subscription in number of levels each side.\n    maxratecount:\n      type: integer\n      description: Max rate-limit budget. Compare to the ratecounter field in the openOrders updates to check whether you are approaching the rate limit.\n    ratecounter:\n      type: boolean\n      default: false\n      description: Whether to send rate-limit counter in updates (supported only for openOrders subscriptions)\n    snapshot:\n      type: boolean\n      default: true\n      description: Whether to send historical feed data snapshot upon subscription (supported only for ownTrades subscriptions)\n    reqid:\n      type: integer\n      description: client originated ID reflected in response message.\n    pair:\n      type: array\n      description: Array of currency pairs.\n      items:\n        type: string\n        description: Format of each pair is \"A/B\", where A and B are ISO 4217-A3 for standardized assets and popular unique symbol if not standardized.\n        pattern: '[A-Z\\s]+\\/[A-Z\\s]+'\n```\n\n> **Personal note** <br/>\nIf you can, if you are in a planning phase, new project, etc., then start designing your architecture with AsyncAPI. Don't do the mistake of coding first and then trying to figure out how to describe it with AsyncAPI :sweat_smile:\n\nStay tuned for the next blog post that guides you step by step through the above document :peace_symbol:\n\n> I recommend you also read another article from the series about WebSocket: [Creating AsyncAPI for WebSocket API - Step by Step](/blog/websocket-part2).",
    "toc": [
      {
        "content": "What is WebSocket",
        "slug": "what-is-websocket",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Websocket use case",
        "slug": "websocket-use-case",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Why AsyncAPI",
        "slug": "why-asyncapi",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "WebSocket described with AsyncAPI",
        "slug": "websocket-described-with-asyncapi",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Playing with WebSocket API",
        "slug": "playing-with-websocket-api",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Describing API using AsyncAPI",
        "slug": "describing-api-using-asyncapi",
        "lvl": 3,
        "i": 5,
        "seen": 0
      }
    ],
    "slug": "/blog/websocket-part1",
    "filePath": "pages/blog/websocket-part1.md"
  },
  {
    "meta": {
      "title": "March 2021 at AsyncAPI",
      "date": "2021-04-14T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status",
        "Linux Foundation",
        "Roadmap"
      ],
      "cover": "/img/posts/march-2021-at-asyncapi/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "excerpt": "AsyncAPI Initiative joined the Linux Foundation in March, but except of this, many other interesting things happened: new roadmap, google summer of code",
      "readingTime": 6
    },
    "content": "\n> Read [February 2021 at AsyncAPI](/blog/february-2021-at-asyncapi) for the update from February.\n\n> In case you do not have time to read this article, maybe take time to listen to the news. Let me know what you think about such an appraoch.\n\n<iframe title=\"March 2021 at AsyncAPI Initiative\" allowtransparency=\"true\" scrolling=\"no\" data-name=\"pb-iframe-player\" src=\"https://www.podbean.com/player-v2/?i=ufy2n-1009123-pb&from=pb6admin&download=1&share=1&download=1&rtl=0&fonts=Arial&skin=1&btn-skin=7\" width=\"100%\" height=\"150\"></iframe>\n\nQ1 2021 came to an end. Let me summarise our targets, revenue, and forecasts :smiley:\n\nThis month:\n- [Slack](https://www.asyncapi.com/slack-invite/) members up by around 100 (reached 1.1k)\n- [Twitter](https://twitter.com/AsyncAPISpec) followers up by around 100 (reached 1.7k)\n- [LinkedIn](https://www.linkedin.com/company/asyncapi) followers up by around 100 (reached 1k)\n- New [OpenCollective](https://opencollective.com/asyncapi) contributor, [Apideck](https://www.apideck.com/) + additional 100 USD every month\n\nForecast? Last months were as awesome as March, usually +100. Does it mean that we will have +1k members on all channels by the end of the year? :sweat_smile:\n\n<Figure\n  src=\"/img/posts/march-2021-at-asyncapi/ga.webp\"\n  caption= \"Figure 1: Comparison of Q1 2020 vs Q1 2021 visits to asyncapi.com\"\n/>\n\nLet's scale this party up!\n\n## AsyncAPI at Linux Foundation\n\nWe did it. AsyncAPI initiative joined Linux Foundation (LF). No more excuses for you not to join us. You're all welcome.\n\nI don't want to write about this too much as everything was described in different articles about us joining LF:\n- [AsyncAPI joins Linux Foundation](https://www.asyncapi.com/blog/asyncapi-joins-linux-foundation)\n- [Linux Foundation Will Host AsyncAPI to Support Growth and Collaboration for Industry's Fastest-Growing API Spec](https://www.linuxfoundation.org/en/press-release/linux-foundation-will-host-asyncapi-to-support-growth-and-collaboration-for-industrys-fastest-growing-api-spec/)\n- [The Linux Foundation Announces Hosting of AsyncAPI](https://www.infoq.com/news/2021/03/linux-foundation-hosts-asyncapi/)\n- [AsyncAPI Looks to Unify API Workflow under Linux Foundation](https://thenewstack.io/asyncapi-looks-to-unify-api-workflow-under-linux-foundation/)\n\n### FAQ\n\nLet me provide more context in FAQ style:\n\n#### Is Linux Foundation taking control over AsyncAPI\n\nNo. AsyncAPI Initiative runs under [open governance model](https://github.com/asyncapi/.github/blob/master/CHARTER.md) and is community-driven. LF assures the project's intellectual property (IP), and related assets do not belong to any company or individual. [Fran Mendez](https://twitter.com/fmvilas) does not retire. He only handed over rights to the project to the foundation to assure the community that it is completely safe for all to use the spec and its tooling.\n\nIt also means our [GitHub organization](https://github.com/asyncapi) is not going anywhere. Nothing changes.\n\n#### Do we need to sign some CLA now to contribute\n\nWe do not need a contributor license agreement (CLA) on repositories for our tools. We might need to set up [EasyCLA](https://easycla.lfx.linuxfoundation.org/#/) for the repository where we have the specification. We need to clarify it in the long run—nothing to worry about until we set it up. In the end, the only reason to set it up is to secure the community from a situation that some contributor (or their company) claims rights to some part of the specification they contributed to.\n\n#### How much money you need\n\nGlad you asked. We joined the foundation with an open governance model that favors active contributors over sponsors. As a result, we do not have a setup where we can assure significant income in exchange for voting rights. In other words, we do not have a financial founding associated with joining the foundation. We still need your financial support. Go to our [Open Collective profile](https://opencollective.com/asyncapi) and drop some coins. Let us know if I can help to preach about AsyncAPI in your company for some extra money.\n\n#### How can we help\n\nExcept for regular contributions, we need help setting up tooling for our open governance model. We need to:\n- Automate a process of collecting information about TSC members\n- Put information about current TSC members on the AsyncAPI website\n- Figure out tooling for the website\n- Setup CODEOWNERS and VOTING files in all the repositories\n\nEveryone with a different set of skills is welcome. [Just contact me](https://www.asyncapi.com/slack-invite/).\n\n### What is next\n\nWe are almost ready for the next releases of the specification. We already have a new, GraphQL-inspired contribution guide that explains how to introduce changes in the specification. What is left is a decision on how actually to decide that release will happen and when. Help us by:\n- Familiarize with [instruction](https://github.com/asyncapi/spec/blob/master/CONTRIBUTING.md) on how to introduce changes in the spec, pick [the idea](https://github.com/asyncapi/spec/issues) that you want to champion, and let us start improving the spec\n- Have a look at the [proposal on release cadence](https://github.com/asyncapi/spec/issues/513) and share your opinion, as comments or emojis\n\n## Vision and roadmap\n\nAsyncAPI creator, [Fran Mendez](https://twitter.com/fmvilas), published AsyncAPI Initiative's vision and roadmap for next years.\n\n> **tl;dr** <br/> AsyncAPI becomes the #1 API specification for defining and developing APIs. Any kind of APIs.\n\nGo to the [roadmap](/roadmap) view to check out what it means and what needs to be done to get there.\n\nWe need a lot of help to complete this roadmap. Without engagement and support of the community, all of this is just wishful thinking. All hands aboard, we're waiting [here](https://www.asyncapi.com/slack-invite/).\n\n## Google Summer of Code\n\nIn 2020, we decided to actively support [the Hacktoberfest](https://www.asyncapi.com/blog/hacktoberfest-summary-2020) to give back to the community by making it easier to make a first contribution in open-source and at the same time improve awareness about the AsyncAPI Initiative. We received a very positive feedback, and people referred us to [Google Summer of Code](https://summerofcode.withgoogle.com/) as a place where our engagement would be highly appreciated.\n\nWe applied this year to be part of the GSoC initiative.\n\nWe got rejected.\n\nIt is not easy to reject us, though :smiley:\n\n[Postman](https://www.postman.com/) that we partner with was accepted for GSoC and offered us to submit the list with [our ideas](https://docs.google.com/document/d/1F2RWY7wmexsv5KOPsH7T_XiITt8gDK1PPPoaCFf5Ua8/edit#)(ideas 7-13) as part of Postman application. We received many proposals and were contaced by many very motivated students (but not only students) who would like to join the AsyncAPI initiative and build great tools. \n\nHave a look at the list of ideas. We received proposals for all of them. It looks like soon, our tooling ecosystem will get many new useful tools. Stay tuned. Feel free to join us, share your use cases for the ideas and also help build those tools. A Majority of discussions happen [here](https://github.com/asyncapi/community/issues).\n\n## Bindings rendering in react component\n\nThanks to work done by [Swen Helge](https://github.com/195858) from [Solace](https://solace.com/), the React component supports rendering of information provided in bindings. Check release [0.21](https://github.com/asyncapi/asyncapi-react/releases/tag/v0.21.0) in the [playground for the React component](https://asyncapi.github.io/asyncapi-react/).\n\n## Messages validation in NodeJS template\n\nThanks to work done by [Khuda Dad Nomani](https://twitter.com/KhudaDadNomani), the NodeJS template that you can generate using the AsyncAPI Generator includes a message validator that enables real-time validation of all incoming and outgoing messages. Check out [this](https://github.com/asyncapi/nodejs-template#cli) short instructions to see it in action or watch the below recording.\n\n<TwitterTweetEmbed\n  tweetId='1376804212466712578'\n  options={{\n    cards: 'hidden',\n    width: 500,\n    align: 'center'\n  }}\n/>\n\n## About AsyncAPI in different languages\n\nAre you tired of reading about AsyncAPI only in English? Some articles in French and Spanish were released recently, have a look:\n- [Spanish](https://lignux.com/asyncapi-se-fusiona-con-la-fundacion-linux/)\n- [French](http://blog.ippon.fr/2021/04/09/asyncapi-comment-standardiser-les-api-asynchrones/)\n\nIf you want to see more content in different languages, let us know.  \n\nAlso, provide feedback to [Barbaño González](https://www.linkedin.com/in/barba%C3%B1o-gonz%C3%A1lez-moreno-02a724179/) that works on content for Spanish-speaking audience. Some help needed [here](https://docs.google.com/document/d/1Si6tGwmQ57Nd4jn-NnOgDHlli5fGVjz8/).\n\n> Photo by <a href=\"https://unsplash.com/@markusspiske?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Markus Spiske</a> on <a href=\"https://unsplash.com/s/photos/grow?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n  \n",
    "toc": [
      {
        "content": "AsyncAPI at Linux Foundation",
        "slug": "asyncapi-at-linux-foundation",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "FAQ",
        "slug": "faq",
        "lvl": 3,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Is Linux Foundation taking control over AsyncAPI",
        "slug": "is-linux-foundation-taking-control-over-asyncapi",
        "lvl": 4,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Do we need to sign some CLA now to contribute",
        "slug": "do-we-need-to-sign-some-cla-now-to-contribute",
        "lvl": 4,
        "i": 3,
        "seen": 0
      },
      {
        "content": "How much money you need",
        "slug": "how-much-money-you-need",
        "lvl": 4,
        "i": 4,
        "seen": 0
      },
      {
        "content": "How can we help",
        "slug": "how-can-we-help",
        "lvl": 4,
        "i": 5,
        "seen": 0
      },
      {
        "content": "What is next",
        "slug": "what-is-next",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Vision and roadmap",
        "slug": "vision-and-roadmap",
        "lvl": 2,
        "i": 7,
        "seen": 0
      },
      {
        "content": "Google Summer of Code",
        "slug": "google-summer-of-code",
        "lvl": 2,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Bindings rendering in react component",
        "slug": "bindings-rendering-in-react-component",
        "lvl": 2,
        "i": 9,
        "seen": 0
      },
      {
        "content": "Messages validation in NodeJS template",
        "slug": "messages-validation-in-nodejs-template",
        "lvl": 2,
        "i": 10,
        "seen": 0
      },
      {
        "content": "About AsyncAPI in different languages",
        "slug": "about-asyncapi-in-different-languages",
        "lvl": 2,
        "i": 11,
        "seen": 0
      }
    ],
    "slug": "/blog/march-2021-at-asyncapi",
    "filePath": "pages/blog/march-2021-at-asyncapi.md"
  },
  {
    "meta": {
      "title": "AsyncAPI joins Linux Foundation",
      "date": "2021-03-30T15:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Linux Foundation",
        "Announcement"
      ],
      "cover": "/img/posts/asyncapi-joins-linux-foundation.webp",
      "coverCaption": "Background vector created by starline.",
      "authors": [
        {
          "name": "Fran Méndez",
          "photo": "/img/avatars/fmvilas.webp",
          "link": "https://twitter.com/fmvilas",
          "byline": "AsyncAPI Founder"
        }
      ],
      "excerpt": "Today marks a delightful milestone for us at AsyncAPI: I'm proud to share with you that we're now a Linux Foundation project 🎉",
      "readingTime": 2
    },
    "content": "\nToday marks a delightful milestone for us at AsyncAPI: **I'm proud to share with you that we're now a Linux Foundation project** 🎉\n\nWhen a year ago, our Łukasz and I started having discussions on the best way to improve the open governance, we instantly agreed that AsyncAPI had to join a neutral home. But not just any neutral home. We needed to join a strong and trusted organization that would allow us to keep the project independent and community-driven. That's the Linux Foundation. The home of many other internet open-source industry standards.\n\nIt's been a year to remember. Amidst a pandemic, we organized the first AsyncAPI Conference. Lots of new folks joined our great community. Our tools started to get mature enough. And to put the cherry on the cake, [we partnered with Postman](/blog/asyncapi-partners-with-postman) to guarantee the continuity and growth of AsyncAPI for the next decade. What a ride!\n\n2021 looks no different so far. In less than 3 months, we're seeing an increasing amount of folks joining us to [change the EDA and API landscapes forever](/roadmap). We owed you this. We're joining the Linux Foundation to make sure AsyncAPI stays neutral and is [driven by those who dedicate their effort, time, and love to the project](/blog/governance-motivation).\n\nAnd that's what it is all about, my friends. Without you —yes, you too!–, AsyncAPI is nothing but an illusory fantasy in the heads of some dreamers. This step is indeed the culmination of years of hard work, but to me, this is just the beginning. Now is when the party is actually getting started. Drop some cool beats and grab some drinks. It's going to be a long night!\n\nLet's build the future, together 🚀\n",
    "toc": [],
    "slug": "/blog/asyncapi-joins-linux-foundation",
    "filePath": "pages/blog/asyncapi-joins-linux-foundation.md"
  },
  {
    "meta": {
      "title": "Building an asynchronous flight notification service using AsyncAPI, MQTT, Amadeus and Twilio",
      "date": "2021-03-24T05:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "Testing",
        "EDA",
        "Use Case"
      ],
      "cover": "/img/posts/building-async-flight-notification-service/event-driven-architecture.webp",
      "authors": [
        {
          "name": "Alvaro Navarro",
          "photo": "/img/avatars/anavarro.webp",
          "link": "https://twitter.com/alnacle",
          "byline": "Developer Relations at Amadeus for Developers"
        }
      ],
      "readingTime": 7,
      "excerpt": "Flight delays, cancelations and gate changes are among the most common headaches that travelers face. Now more so than ever, travelers need this information literally at hand to enjoy a stress-free tr"
    },
    "content": "\nFlight delays, cancelations and gate changes are among the most common headaches that travelers face. Now more so than ever, travelers need this information literally at hand to enjoy a stress-free trip.\n\nWith this in mind, we decided to build a small prototype to implement an asynchronous scheduling notification service. The prototype will be implemented following the microservices architecture paradigm with the following services and requirements in mind:\n\n- All services should communicate asynchronously via the [MQTT](https://mqtt.org/) protocol, a lightweight publish-subscribe messaging pattern. Messages should be correctly defined and documented following AsyncAPI specs. \n\n- A **Monitor service** receives and queues flight information and queries the REST API to detect changes. When it detects a change, it notifies subscribers. Flight schedule information is retrieved from the [Flight Status API](https://developers.amadeus.com/self-service/category/air/api-doc/on-demand-flight-status) from Amadeus for Developers.\n\n- A **Notifier service** receives the notifications and alerts the user via SMS. Alerts are sent using the [Twilio SMS API](https://www.twilio.com/docs/sms/api).\n\n- A **Subscriber service** provides a simple web interface so users can subscribe to flight status updates.\n\n## Defining messages with AsyncAPI \n\nFirst, we’ll define two messages to model the events managed by subscribers and publishers:\n\nA `flightQueue` message to queue a new flight to be monitored for status changes. This event is composed of two main schemas:\n\n- `user` – to model information about the user subscribing to the notifications (name and phone number): \n\n```yaml\ntype: object \nproperties: \n    userName: \n        type: string \n        minimum: 1 \n    phoneNumber: \n        type: string \n        description: phone number where notifications will be received.\n```\n\n- `flight` - to model  information about the flight being monitored (carrier code, flight number and departure date).\n\n```yaml\ntype: object \nproperties: \n    carrierCode: \n        type: string \n        description: 2 to 3-character IATA carrier code \n        example: \"LH\" \n    flightNumber: \n        type: integer \n        minimum: 1 \n        description: 1 to 4-digit number of the flight \n        example: \"193\" \n    scheduledDepartureDate: \n        type: string \n        format: date-time \n        description: scheduled departure date of the flight, local to the departure airport. \n        example: \"2020-10-20\" \n```\n\nA `flightStatus` message to notify about changes. When the service detects a change in flight status, it triggers a notification event to alert the user. The payload of the `flightStatus` message consists of the following structure:\n\n- `flight` and `user` schemas (the same as in the `flightQueue` message) to identify the flight emitting the event and the user receiving the notification.\n\n- Two `segment` schemas corresponding to the origin and destination. This lets us notify about changes to both departure and arrival. \n\n```yaml\ntype: object \nproperties: \n  iataCode: \n    type: string \n    description: 2 to 3-character IATA carrier code \n    example: \"MAD\" \n  scheduledDate: \n    type: string \n    format: date-time \n    description: scheduled datetime of the flight, local to the airport. \n    example: \"2020-10-20 19:15\" \n  gate: \n    type: string \n    description: departure gate\n    example: \"2D\" \n  terminal: \n    type: string \n    description: airport terminal \n    example: \"4\" \n```\n\nMessages are shared among services so it’s important to correctly organize the YAML definition files under a common folder. In our case, we call it common:\n\n        common/\n            messages/\n                flight_queue.yaml\n                flight_status.yaml\n            schemas/\n                flight.yaml\n                segment.yaml\n                user.yaml\n\nServices communicate through channels using the publish/subscribe pattern. Our architecture uses two different channels:\n\n- `flight/queue` to manage and queue the flights to be monitored.\n- `flight/update` to manage the notifications about flight updates.\n\nEach service contains an `asyncapi.yaml` file with the description of the service and server and channel information. Let's take a look to the final `asyncapi.yaml` file of the Subscriber service to see how the messages and channels are organized:\n\n```yaml\nasyncapi: '2.0.0'\ninfo:\n  title: Flight Subscriber Service\n  version: '1.0.0'\n  description: |\n     Allows users to subscribe events from a given flight\n  license:\n    name: Apache 2.0\n    url: 'https://www.apache.org/licenses/LICENSE-2.0'\nservers:\n  development:\n    url: mqtt://localhost:1883\n    protocol: mqtt\nchannels:\n  flight/queue:\n    description: |\n      queue flight in order to retrieve status\n    subscribe:\n      summary: Receive information about the flight that should be monitored for changes\n      message:\n        $ref: '#/components/messages/flightQueue'\ncomponents:\n  messages:\n    flightQueue:\n      $ref: '../common/messages/flight_queue.yaml'\n```\n\nWhen the user provides their flight information, the Subscriber service emits a `flightQueue` message that will be received by the Monitor service from the `flight/queue` channel. The Notifier service also receives the message and adds the payload to the list of flights to monitor.\n\nOnce the Monitor service detects a change in flight status (e.g. a change in boarding gate), it emits a `flightStatus` message to inform subscribers. The Notifier service, which is subscribed to the changes on the `flight/update` channel, notifies the end-user by SMS.\n\nThe AsyncAPI specification files for the [Monitor Service](https://github.com/amadeus4dev/amadeus-async-flight-status/blob/main/monitor/asyncapi.yaml) and [Notifier Service](https://github.com/amadeus4dev/amadeus-async-flight-status/blob/main/notifier/asyncapi.yaml) can be found on GitHub.\n\n## Monitoring flight status information \n\nThe Monitor service checks the status of the user’s flight by calling the On-Demand Flight Status API, which provides real-time flight schedule information like departure/arrival times, gate, or terminal. A simple cURL request to the API shows how the information is represented:\n\n> To get your own authorization token, follow [this](https://developers.amadeus.com/get-started/get-started-with-self-service-apis-335) guide.\n\n```sh\ncurl https://test.api.amadeus.com/v2/schedule/flights?carrierCode=KL&flightNumber=1772scheduledDepartureDate=2021-02-18 -H 'Authorization: Bearer dzh1cpJiFgAlE7iZS'\n```\n\nIn the JSON response, the schedule data of this example has one single segment (a leg of an itinerary, in airline jargon) with several `flightPoints`:\n\n```json\n\"flightPoints\": [  \n    {  \n        \"iataCode\": \"FRA\",  \n        \"departure\": {  \n            \"terminal\": {  \n                \"code\": \"1\"  \n            },  \n            \"gate\": {  \n                \"mainGate\": \"B20\"  \n            },  \n            \"timings\": [  \n                {  \n                    \"qualifier\": \"STD\",  \n                    \"value\": \"2020-11-05T18:20+01:00\"  \n                }  \n            ]  \n        }  \n    },  \n    {  \n        \"iataCode\": \"AMS\",  \n        \"arrival\": {  \n            \"terminal\": {  \n                \"code\": \"1\"  \n            },  \n            \"gate\": {  \n                \"mainGate\": \"A04\"  \n            },  \n            \"timings\": [  \n                {  \n                    \"qualifier\": \"STA\",  \n                    \"value\": \"2020-11-05T19:35+01:00\"  \n                }  \n            ]  \n        }  \n    }\n]\n```\n\nWe can see that:  \n\n- The flight is scheduled to depart from Terminal 1, Gate B22 of Frankfurt International Airport (FRA) at 18:20 (UTC+1). \n- It is scheduled to arrive at Terminal 1, Gate A04 of Amsterdam Schiphol Airport (AMS) at 19:35 (UTC+1). \n\nThe API is synchronous and therefore needs to be polled to monitor the flight status. This isn’t ideal and we need a solid strategy to avoid DDoSing the Amadeus backend, using up our free call quota or piling up a massive bill at the end of the month. \n\nTo solve this, we put the Monitor service on a separate thread. Every five minutes, the thread checks to see if it’s time to retrieve information from the API and update the status. The Monitor only calls the API if two conditions are met: \n\n- The current date is equal to the departure date. \n- The current time is within 4 hours of the departure time. \n\n## Subscribing to flight updates \n\nThe Subscriber service  lets users subscribe to the notifications. We built a simple HTTP server with Flask to let the user enter their name, phone number and flight information.\n\nOnce the Subscriber service gets a new user subscription, it emits a `flightQueue` message with that information in the payload to the broker, so that it can be received by the Monitor.\n\n## Sending notifications to users \n\nThe Notifier service receives flight status updates from the Monitor and uses the Twilio SMS API to notify the end. The service has a very simple implementation: when the Notifier receives a `flightStatus` message, it uses the message payload to build an SMS message:\n\n```python\nclient = twilio.Client(account_sid, auth_token)\n\nmsg = build_message(alert_msg['user'],\n                    alert_msg['departure'],\n                    alert_msg['arrival'])\n\ndestination_phone = alert_msg['user']['phoneNumber']\n\nmessage = client.messages.create(body=msg,\n                                 from_=twilio_phone,\n                                 to=destination_phone)\n```\n\n## Running the service \n\nThe [prototype](https://github.com/amadeus4dev/amadeus-async-flight-status) runs on four Docker containers – one per service plus another for the [MQTT broker](https://github.com/toke/docker-mosquitto) based on the Docker image maintained by the Eclipse Mosquitto project.\n\nTo avoid manually starting each service (plus the dependency of starting the broker first), we will use [Docker compose](https://docs.docker.com/compose/), a tool to run applications composed of multiple containers using a YAML file to define each container as well as their dependencies.\n\nWe start the service by executing:\n\n        docker network create my-network\n        docker-compose up --remove-orphans \n\nIn the browser, we go to http://localhost:5000 and enter information about the flight we want to monitor. The service will send us an alert once the flight information is updated: \n\n![call-to-action](/img/posts/building-async-flight-notification-service/notification-message.webp)\n\n## Conclusion\n\nOur prototype successfully implements our requirements but it’s still far from being ready to use in production. To do so, we’d need to implement authorization, an unsubscribe feature and improve the polling service’s performance, among other improvements.\n\nHowever, developing this prototype lets us learn how to specify and document event-driven architecture using AsyncAPI easily.\n\nYou can find the complete source code of the prototype on the GitHub [async-flight-status repository](https://github.com/amadeus4dev/amadeus-async-flight-status). Feel free to clone, modify and improve the implementation!\n\nHappy coding!\n",
    "toc": [
      {
        "content": "Defining messages with AsyncAPI",
        "slug": "defining-messages-with-asyncapi",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Monitoring flight status information",
        "slug": "monitoring-flight-status-information",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Subscribing to flight updates",
        "slug": "subscribing-to-flight-updates",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Sending notifications to users",
        "slug": "sending-notifications-to-users",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Running the service",
        "slug": "running-the-service",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Conclusion",
        "slug": "conclusion",
        "lvl": 2,
        "i": 5,
        "seen": 0
      }
    ],
    "slug": "/blog/building-async-flight-notification-service",
    "filePath": "pages/blog/building-async-flight-notification-service.md"
  },
  {
    "meta": {
      "title": "Understanding AsyncAPIs with a Practical Example",
      "date": "2021-03-18T05:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "Use Case",
        "EDA",
        "Microservices"
      ],
      "cover": "/img/posts/understanding-asyncapis.webp",
      "authors": [
        {
          "name": "Dunith Dhanushka",
          "photo": "/img/avatars/dunithd.webp",
          "link": "https://twitter.com/dunithd",
          "byline": "Engineer, Writer, Works @ WSO2. Editor of eventdrivenutopia.com"
        }
      ],
      "excerpt": "Learn how to map a real-world event-driven Microservices architecture into AsyncAPI specification",
      "readingTime": 10
    },
    "content": "\nEvent-driven applications are inherently distributed and loosely-coupled. That potentially leads to having many self-contained components in your architecture, managed by multiple teams.\n\nThe information exchanged between them must be documented and maintained consistently for everyone’s visibility. [AsyncAPI specification](https://www.asyncapi.com/) steps in to solve that gap.\n\nThis post explains how to map a simple event-driven application architecture into corresponding AsyncAPI specifications by walking you through an example.\n\n# The event-driven use case\nImagine you are designing a solution to the following use case.\n\nTwo event-driven microservices are communicating through a message broker in a publish/subscribe manner. The first service, the Account service, publishes the ***UserSignedUp*** event when a new user account is created. The second service, the Email service, subscribed to receive those events to send the new user a welcome email.\n\nWe can come up with a simple solution architecture as follows.\n\n![solution](/img/posts/understanding-asyncapis/solution.webp)\n\n# The problem\nNow we have a solution architecture in place. Should we go ahead and start building?\n\nNo! Not so fast. There are strong reasons behind not doing so.\n\nAccount and Email services are loosely coupled distributed services, potentially built, operated, and maintained by separated teams. Two services will have their own context boundaries defined. All teams must explicitly define any information exchanged across these boundaries. For example, all teams must maintain broker configurations, topics, and event formats in a central place. Otherwise, maintaining the solution will become a nightmare in the long run.\n\nIn our solution, the format of the ***UserSignedUp*** event must be consistent across two services. If one team makes a change, it has to be visible across the board.\n\nTherefore, a proper process must be in place to describe different components of an event-driven system and their interactions.\nAsyncAPI specification comes into play at this point.\n\n# AsyncAPI specification to the rescue\n\n> AsyncAPI is an open-source initiative that provides both a specification to describe and document your asynchronous applications in a machine-readable format and tooling (such as code generators) to make life easier for developers tasked with implementing them.\n>\n> \\- [Marc DiPasquale](https://www.asyncapi.com/blog/asyncapi_codegen_scst#defining-the-application-that-you-want-to-develop-the--asyncapi-document)\n\nAsyncAPI is built on the foundation of [OpenAPI specification](https://swagger.io/specification/). A brings in critical activities from the REST API world, from documentation to code generation, from discovery to event management. Most of the processes you apply to your REST APIs nowadays would apply to event-driven/asynchronous APIs.\n\nCurrently, the specification is at [version 2.0.0](https://www.asyncapi.com/docs/specifications/2.0.0).\n\n# Documenting the solution architecture\n\nLet’s try to document our solution as per the AsyncAPI specification. Our end goal is to share it with respective teams to generate the implementations, validators, and most importantly, the documentation.\n\nAn AsyncAPI document is a file that defines and annotates the different components of **a specific Event-Driven Application**. The file format must be JSON or YAML; however, only the subset of YAML that matches the JSON capabilities is allowed.\n\nFirst, we need to identify **Applications** in the solution.\n\n## Identify event-driven applications in the solution\n\nThe first step of documenting an event-driven architecture is to identify discrete components that produce or consume events. In AsyncAPI terms, they are commonly referred to as **Applications**.\n\nAs per the specification:\n\n> An application is any kind of computer program or a group of them. It MUST be a [producer](https://www.asyncapi.com/docs/specifications/2.0.0#definitionsProducer), a [consumer](https://www.asyncapi.com/docs/specifications/2.0.0#definitionsConsumer) or both. An application MAY be a microservice, IoT device (sensor), mainframe process, etc. An application MAY be written in any number of different programming languages as long as they support the selected [protocol](https://www.asyncapi.com/docs/specifications/2.0.0#definitionsProtocol). An application MUST also use a protocol supported by the server in order to connect and exchange [messages](https://www.asyncapi.com/docs/specifications/2.0.0#definitionsMessage).\n\nIn our solution, both Account service and Email service can be considered as applications as they produce and consume ***UserSignedUp*** events, respectively. Hence, both services will get their own AsyncAPI specification file.\n\nLet’s start with the Account service first.\n\n# Documenting the Account service\n\nCreate a file called **account-service.yaml** and add the following content to it.\n\n```\nasyncapi: 2.0.0\ninfo:\n  title: Account Service\n  version: '1.0.0'\n  description: |\n    Manages user accounts in the system.\n  license:\n    name: Apache 2.0\n    url: https://www.apache.org/licenses/LICENSE-2.0\n```\n\nThe first line of the specification starts with the document type, `asyncapi`, and the `version` (2.0.0). This line doesn’t have to be the first one, but it’s a recommended practice.\n\nThe `info` object contains the minimum required information about the application. It contains the `title`, which is a memorable name for the API, and the version. While it’s not mandatory, it is strongly recommended to change the version whenever you make changes to the API.\n\n## Adding servers\n\nOur solution has been designed around a message broker. Therefore, both Account and Email services MUST specify brokers’ necessary information such as URIs, protocols, and security configurations.\n\nWe can use the `servers` object to define that information for the Account service. In AsyncAPI terms, a server object defines a message broker, a server, or any other kind of computer program capable of sending or receiving data.\n\n\n\n![servers](/img/posts/understanding-asyncapis/servers.webp)\n\n\n\nAdd the following content to the same file. Here, we are using the test MQTT broker available at mosquitto.org. Apart from MQTT, AsyncAPI supports other protocols like AMQP and Kafka.\n\n```yaml\nservers:\n  production:\n    url: mqtt://test.mosquitto.org\n    protocol: mqtt\n    description: Test MQTT broker\n```\n\n## Adding channels, operations, and messages\n\nSo far, the Account service consumers know where they should connect to send or receive data. The next step is to define operations on the broker.\n\nAn operation maps to either **publish** or **subscribe** method/function in the application. Each operation exchanges one or more **messages**. Effectively, these messages define different events sent to and received from operations.\n\nOperations are bound to a particular **channel** in the server, along with the messages they exchange. A channel is an addressable component made available by the server for the organization of messages. Producer applications send messages to channels, and consumer applications consume messages from channels. You can think of channels as the interfaces for external parties to communicate with an application.\n\nThere can be many channel instances in a server, allowing messages with different content to be addressed to different channels. A channel is equivalent to topics, routing keys, event types, or paths based on the server implementation.\n\nThis relationship is illustrated in the following figure.\n\n\n\n![channels](/img/posts/understanding-asyncapis/channels.webp)\n\nIn our solution, both services publish and consume events on the same channel.\n\nAdd the following section to define a channel called **user/signedup**.\n\n```yaml\nchannels:\n  user/signedup:\n    subscribe:\n      operationId: emitUserSignUpEvent\n      message:\n        $ref : '#/components/messages/UserSignedUp'\n```\n\nThe Account service publishes ***UserSignedUp*** events to the broker. Hence, it is a publish operation. The **operationId** specifies the name of the method or function that emits the ***UserSignedUp*** event in the generated code.\n\nThe above operation uses a reference to specify the format of the message that publishes. We’ll get to the schema definitions shortly.\n\n## Defining messages and payload schema\n\nIn our solution, both services produce and consume the ***UserSignedUp*** event, which has the following format.\n\n```json\n{\n  \"firstName\" : \"John\",\n  \"lastName\" : \"Doe\",\n  \"email\" : \"aa@bb.cc\",\n  \"createdAt\" : \"2021-02-12 09:34:123\"\n}\n```\n\nThe publish operation of the ***user/signedup*** channel had a reference to the event payload’s schema. Now we need to define it properly. The schema definitions are done with AsyncAPI schema, which is 100% compatible with JSON Schema Draft 07. Refer to [this](https://www.asyncapi.com/docs/specifications/2.0.0#schemaObject) if you need to explore more on the AsynAPI schemas.\n\nMessage schemas, security schemes, and bindings are housed by ***Components*** object. All objects defined within the components object must be referenced from properties outside the components object.\n\nAfter adding the schemas, the final AsyncAPI definition for the Account service file should look like the following.\n\n```yaml\nasyncapi: 2.0.0\ninfo:\n  title: Account Service\n  version: '1.0.0'\n  description: |\n    Manages user accounts in the system.\n  license:\n    name: Apache 2.0\n    url: https://www.apache.org/licenses/LICENSE-2.0\n\nservers:\n  production:\n    url: mqtt://test.mosquitto.org\n    protocol: mqtt\n    description: Test MQTT broker\n\nchannels:\n  user/signedup:\n    subscribe:\n      operationId: emitUserSignUpEvent\n      message:\n        $ref : '#/components/messages/UserSignedUp'\n\ncomponents:\n  messages:\n    UserSignedUp:\n      name: userSignedUp\n      title: User signed up event\n      summary: Inform about a new user registration in the system\n      contentType: application/json\n      payload:\n        $ref: '#/components/schemas/userSignedUpPayload'\n\n  schemas:\n    userSignedUpPayload:\n      type: object\n      properties:\n        firstName:\n          type: string\n          description: \"foo\"\n        lastName:\n          type: string\n          description: \"bar\"\n        email:\n          type: string\n          format: email\n          description: \"baz\"\n        createdAt:\n          type: string\n          format: date-time  \n```\n\n\n\n# Documenting the Email service\n\nSimilar to the above, we can create the AsyncAPI specification for the Email service as follows.\n\n```yaml\nasyncapi: 2.0.0\ninfo:\n  title: Email Service\n  version: '1.0.0'\n  description: |\n    Sends emails upon certain events\n  license:\n    name: Apache 2.0\n    url: https://www.apache.org/licenses/LICENSE-2.0\n\nservers:\n  production:\n    url: mqtt://test.mosquitto.org\n    protocol: mqtt\n    description: Test MQTT broker\n\nchannels:\n  user/signedup:\n    publish:\n      operationId: onUserSignUp\n      message:\n        $ref : '#/components/messages/UserSignedUp'\n\ncomponents:\n  messages:\n    UserSignedUp:\n      name: userSignedUp\n      title: User signed up event\n      summary: Inform about a new user registration in the system\n      contentType: application/json\n      payload:\n        $ref: '#/components/schemas/userSignedUpPayload'\n\n  schemas:\n    userSignedUpPayload:\n      type: object\n      properties:\n        firstName:\n          type: string\n          description: \"foo\"\n        lastName:\n          type: string\n          description: \"bar\"\n        email:\n          type: string\n          format: email\n          description: \"baz\"\n        createdAt:\n          type: string\n          format: date-time\n          description: \"foo\"\n```\n\nNotice that the servers, channels, and payloads are the same. The only difference is in the **publish** operation, bound to the ***user/signedup*** channel. It says that messages published to this channel will be received by this service.\n\n# What’s next?\n\nNow we have completed writing AsyncAPI specifications for both Microservices. The next goal is to check-in them into a central location like Git and let both teams collaborate over the design. They can collaboratively edit the spec files to introduce new operations, parameters, versions, etc. Thanks to AsyncAPI, everything can be controlled from a central place, and every change will be visible across the board. I would say this is the pipe dream of an enterprise architect ;)\n\nBut our journey doesn’t stop here. The AsyncAPI project brings in a rich set of tools for the betterment of event-driven application building. You can find more information on this [here](https://www.asyncapi.com/docs/community/tooling).\n\n## Code generators\n\nApplication developers can speed up their work by automatically generating scaffoldings by specifying the specification file. This design-first strategy provides boilerplate code for dealing with brokers and marshaling/unmarshalling messages over the wire.\n\nGenerators are available for mainstream applications like Java, .NET, Javascript, etc. You can check out [this](https://github.com/asyncapi/generator) repo for more information.\n\n## Validators\n\nValidators validate a given message by comparing it with the specification. That is useful at the runtime for input validations.\n\n## Documentation generators\n\nThese generators generate human-readable documentation from an AsyncAPI document. Output formats are HTML, Markdown, and React (experimental)\n\n## Mocking and testing tools\n\nTools that take specification documents as input, then publish fake messages to broker destinations for simulation purposes. May also check that publisher messages are compliant with schemas.\n\n# Conclusion\n\nUse AsyncAPI specification to document your event-driven systems to maintain consistency, efficiency, and governance across different teams who own each architectural component.\n\nThe tooling ecosystem of AsyncAPI helps you speed up application development by automating tedious but necessary tasks such as code generation, documentation generation, validators, etc. Use them whenever you can.\n\nFinally, the AsyncAPI community is growing so fast. Your contribution to the community will be valuable in terms of making better event-driven applications.\n\nI hope you enjoyed this post.\n\n> Originally published at [https://medium.com/event-driven-utopia](https://medium.com/event-driven-utopia/understanding-asyncapis-with-a-practical-example-ee2b4be221d8)\n\n> Cover image by <a href=\"https://pixabay.com/users/silviarita-3142410/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2634391\">silviarita</a> from <a href=\"https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2634391\">Pixabay</a>\n",
    "toc": [
      {
        "content": "The event-driven use case",
        "slug": "the-event-driven-use-case",
        "lvl": 1,
        "i": 0,
        "seen": 0
      },
      {
        "content": "The problem",
        "slug": "the-problem",
        "lvl": 1,
        "i": 1,
        "seen": 0
      },
      {
        "content": "AsyncAPI specification to the rescue",
        "slug": "asyncapi-specification-to-the-rescue",
        "lvl": 1,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Documenting the solution architecture",
        "slug": "documenting-the-solution-architecture",
        "lvl": 1,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Identify event-driven applications in the solution",
        "slug": "identify-event-driven-applications-in-the-solution",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Documenting the Account service",
        "slug": "documenting-the-account-service",
        "lvl": 1,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Adding servers",
        "slug": "adding-servers",
        "lvl": 2,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Adding channels, operations, and messages",
        "slug": "adding-channels-operations-and-messages",
        "lvl": 2,
        "i": 7,
        "seen": 0
      },
      {
        "content": "Defining messages and payload schema",
        "slug": "defining-messages-and-payload-schema",
        "lvl": 2,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Documenting the Email service",
        "slug": "documenting-the-email-service",
        "lvl": 1,
        "i": 9,
        "seen": 0
      },
      {
        "content": "What’s next?",
        "slug": "whats-next",
        "lvl": 1,
        "i": 10,
        "seen": 0
      },
      {
        "content": "Code generators",
        "slug": "code-generators",
        "lvl": 2,
        "i": 11,
        "seen": 0
      },
      {
        "content": "Validators",
        "slug": "validators",
        "lvl": 2,
        "i": 12,
        "seen": 0
      },
      {
        "content": "Documentation generators",
        "slug": "documentation-generators",
        "lvl": 2,
        "i": 13,
        "seen": 0
      },
      {
        "content": "Mocking and testing tools",
        "slug": "mocking-and-testing-tools",
        "lvl": 2,
        "i": 14,
        "seen": 0
      },
      {
        "content": "Conclusion",
        "slug": "conclusion",
        "lvl": 1,
        "i": 15,
        "seen": 0
      }
    ],
    "slug": "/blog/understanding-asyncapis",
    "filePath": "pages/blog/understanding-asyncapis.md"
  },
  {
    "meta": {
      "title": "February 2021 at AsyncAPI",
      "date": "2021-03-16T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/february-2021-at-asyncapi-cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "excerpt": "We are getting close to joining a foundation. We started a few new initiatives. We are busy. In other words, this is a good time to join us and drive things together.",
      "readingTime": 7
    },
    "content": "\n> Read [January 2021 at AsyncAPI](/blog/january-2021-at-asyncapi) for the update from January.\n\nI enjoy monthly status over weekly one. It is not that I'm just happy I have more time for other things. Content size did not change. I think people do have other things to do than following AsyncAPI only :sweat_smile: Life in open-source runs slower, at least when you look at it from the outside. I have an impression, that more people pay attention to the status when it is once a month. I wonder what your view is on that.\n\n## Open governance model aka charter ready for the review\n\nIs an \"open governance model\" the same as a \"charter\"? No. Charter is a boring legal document that describes many rules that need to be followed when being under a foundation. One of the things the charter tackles is the general rules on how the project will operate and be governed. \n\nI think the most important thing to write here is that the AsyncAPI charter is a reality. It finally arrived and is ready for review. In the special blog post, we also explained what governance model we envision for the AsyncAPI Initiative in more human-friendly words. This content was released and communicated on Tuesday, 9th of March, and we will wait for your feedback until the 23rd of March. It looks like we will kick off April under the umbrella of the foundation :crossed_fingers:\n\nPlease take your time to:\n- Read [Finding a Good Open Governance Model for AsyncAPI](/blog/governance-motivation) to understand our motivation\n- Check out [this](https://github.com/asyncapi/.github/pull/37) pull request with the charter\n\n## Code generators activities\n\nWe had some significant traffic in the area of code generation templates in February.\n\n### PHP\n\n[Emiliano Zublena](https://github.com/emilianozublena) joined the AsyncAPI community big time by starting with donating [a new template for PHP](https://github.com/asyncapi/asyncapi-php-template). It is not yet released under **@asyncapi** scope on npm, but you can already play with it by using the AsyncAPI Generator with a direct GitHub link like:\n\n```bash\nag https://bit.ly/asyncapi https://github.com/asyncapi/asyncapi-php-template -o output`\n```\n\n### Go\n\nWe merged the initial pull request to the [Go template](https://github.com/asyncapi/go-template). The initial contributor was not able to continue working on the template, but the foundation was there. [Emiliano Zublena](https://github.com/emilianozublena) and [Takumi Sueda](https://github.com/puhitaku) will try to help to drive forward template development. This template is not yet released as we need to get some feedback from the community first. Give it a try with:\n\n```bash\nag https://bit.ly/asyncapi https://github.com/asyncapi/go-template -o output\n```\nLet us know what you think in the GitHub issues section. Thank you, [Jacob Poston](https://github.com/jposton96a) for your initial hard work on the template!\n\n### TypeScript and NATS\n\n[Jonas Lagoni](https://github.com/jonaslagoni/) regularly extends and polishes [the TypeScript template for NATS](https://github.com/asyncapi/ts-nats-template). It reached 0.3 release and is the first template that is already using a new AsyncAPI SDK for data types generation. Please go and check it out.\n\n## AsyncAPI CLI to rule them all\n\nWe always wanted to have a single CLI to do all the things related to AsyncAPI. In other words, one CLI to validate, generate, edit, create, and others. So far, we had a CLI for the AsyncAPI generator, and recently one of our community members, [Jorge Aguiar Martín](https://twitter.com/jotamusik), referred us to his CLI for AsyncAPI validation.\n\nWe all agreed that instead of working separately on different CLIs, it is better to work together on one CLI that everyone will love. The project kicked off! A repository has been created and we already discuss details on how the CLI interface should look like. [Join](https://github.com/asyncapi/cli/issues/1) the discussion.\n\n## Event gateway\n\nSounds big? It is :smiley:\n\nAn excellent engineer joined AsyncAPI, [Sergio Moya](https://twitter.com/smoyac/status/1361289838075539461). We felt like we need to start something big that should be built independently from any vendor together with the AsyncAPI community. The project got kicked off, and it is the best time to join. Have a look at the dedicated repository and our plans for [the Everest? AsyncAPI Gate? or maybe Eventide?](https://github.com/asyncapi/event-gateway) :smiley:\n\nShare your use cases. Please help us understand what you need. Sergio prepared an issue template that [helps with that](https://github.com/asyncapi/event-gateway/issues/new?assignees=&labels=use+case&template=use_case.md&title=%5BUSECASE%5D+).\n\n## Domain model generation\n\nAs mentioned in [the blog post about January](/blog/january-2021-at-asyncapi#next-major-feature-is-data-model-generation), February was all about data model generation that we wanted to use to speed up templates development for code generation. The library is [ready](https://github.com/asyncapi/generator-model-sdk), and we started trying it out. You can try it out too, and you do not even need our AsyncAPI Generator. It is a generic library and you only need a JSON Schema Draft 7 or an AsyncAPI document.\n\n```js\nimport { TypeScriptGenerator } from '@asyncapi/generator-model-sdk';\n\nconst DESCRIPTION_PRESET = {\n  interface: {\n    property({ property, content }) {\n      const desc = property.getFromSchema('description');\n      if (desc) {\n        return `// ${desc}\\n${content}`;\n      }\n      return content;\n    }\n  }\n}\n\nconst options = {\n  modelType: 'interface',\n  presets: [DESCRIPTION_PRESET],\n}\n\nconst generator = new TypeScriptGenerator(options);\n\nconst schema = {\n  $id: \"Address\",\n  type: \"object\",\n  properties: {\n    street_name:    { type: \"string\" },\n    city:           { type: \"string\", description: \"City description\" },\n    house_number:   { type: \"number\" },\n    marriage:       { type: \"boolean\", description: \"Status if marriage live in given house\" },\n    pet_names:      { type: \"array\", items: { type: \"string\" } },\n  },\n  required: [\"street_name\", \"city\", \"state\", \"house_number\", \"state\"],\n};\n\nconst interfaceModels = await generator.generate(schema);\n\n// generated interfaceModels[0].result should have the following shape:\nexport interface Address {\n  streetName: string;\n  // City description\n  city: string;\n  houseNumber: number;\n  // Status if marriage live in given house\n  marriage?: boolean;\n  petNames?: Array<string>;\n}\n```\n\nSome important resources to follow:\n- [How processing data from input works](https://github.com/asyncapi/generator-model-sdk/blob/master/docs/input_processing.md)\n- [How **generator-model-sdk** simplify JSON Schema](https://github.com/asyncapi/generator-model-sdk/blob/master/docs/simplification.md)\n- [How model generator works and how to write a new one](https://github.com/asyncapi/generator-model-sdk/blob/master/docs/generators.md)\n- [How presets (customization) works and how to write a custom preset](https://github.com/asyncapi/generator-model-sdk/blob/master/docs/customization.md)\n\n## Community continues to grow\n\nIn February we reached 1600 followers on Twitter.\n\n<TwitterTweetEmbed\n  tweetId='1362016089207635968'\n  options={{\n    cards: 'hidden',\n    width: 500,\n    align: 'center'\n  }}\n/>\n\nA great thing to see is that the community from [LinkedIn](https://www.linkedin.com/feed/update/urn:li:activity:6769647615823945728/) grew to 900, and our news shared there also get more visibility.\n\nWe are very noisy :sweat_smile:\n\n## Other features\n\n- Thanks to the support of [Daniel CHU](https://www.linkedin.com/in/daniel-chu-dc/) —who joined us during last Hacktoberfest— now the JavaScript parser also validates the examples of server variables. For more details, check out the [1.4](https://github.com/asyncapi/parser-js/releases/tag/v1.4.0) release.\n- Once again, thanks to [Ludovic Dussart](https://twitter.com/ldussart) from Ineat Lab, we have additional features, these time in HTML and Markdown template. Thanks to the new **version** parameter, you can overwrite the version of the application specified in the AsyncAPI file under **info.version**. Useful in CI/CD when your service version is not maintained in the AsyncAPI file but pom.xml or package.json\n- Thanks to [Mike Ralphson](https://twitter.com/PermittedSoc), we have a new **frontMatter** parameter in the Markdown template. It lets you specify an external file with a custom front-matter that should be included in the resulting Markdown during generation. Very useful for static site generators' users.\n\n  ```bash\n  # 1. Get AsyncAPI Generator\n  npm install -g @asyncapi/generator\n\n  # 2. Create a file with frontmatter\n  cat > ssg.yml << EOF\n  title: AsyncAPI Documentation\n  layout: asyncapi\n  permalink: /asyncapi-docs\n  EOF\n\n  # 3, Generate Markdown file that includes the frontmatter\n  ag https://bit.ly/asyncapi @asyncapi/markdown-template -o output -p frontMatter=ssg.yml\n\n  # 4. Check out the output\n  cat output/asyncapi.md\n  ```\n- [Maciej Urbanczyk](https://www.linkedin.com/in/maciej-urba%C5%84czyk-909547164/) and [I](https://twitter.com/derberq) (I mean me :smiley:) pushed some features to the AsyncAPI Generator:\n  - It supports the latest Node.js 15 and npm 7\n  - You can now install generator templates globally. For more details, read [this](https://github.com/asyncapi/generator/#global-templates-installed-with-yarn-or-npm) new section in the readme.\n  - It is now much easier to generate multiple files using the new React render engine. For more details, read [this](https://github.com/asyncapi/generator/blob/master/docs/authoring.md#react) or have a look at it [here](https://github.com/asyncapi/template-for-generator-templates/blob/master/template/schemas/schema.js#L10)\n  - Some parts of templates can be written in TypeScript. For more details, read [this](https://github.com/asyncapi/generator/blob/master/docs/authoring.md#typescript-support). We still cannot use TS in main template code. For more details read [this](https://github.com/asyncapi/generator-react-sdk/issues/3).\n\nCheck out all the [releases](https://github.com/asyncapi/generator/releases)\n\n## Good learning resources\n\n- Read this important [10 FAQs About Event-Driven APIs](https://duckster.medium.com/10-faqs-about-event-driven-apis-50ee9c94bbb8) from [Dakshitha Ratnayake](https://twitter.com/techieducky)\n- Great summary from Nordic APIs and [Vyom Srivastava](https://www.linkedin.com/in/vyomsrivastava/) on [8+ AsyncAPI Documentation Generators](https://nordicapis.com/8-asyncapi-documentation-generators/)\n- Fran Mendez was a part of Postman's live stream. Learn how to get from zero to AsyncAPI in just about 1h 30min. I hope it can be done faster, and Fran was just having too much small talk with Kevin and Kin :sweat_smile:\n<YouTube id=\"g2pqCIhXQ3k\" />\n\n> Photo by <a href=\"https://unsplash.com/@dnevozhai?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Denys Nevozhai</a> on <a href=\"/s/photos/traffic?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "Open governance model aka charter ready for the review",
        "slug": "open-governance-model-aka-charter-ready-for-the-review",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Code generators activities",
        "slug": "code-generators-activities",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "PHP",
        "slug": "php",
        "lvl": 3,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Go",
        "slug": "go",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "TypeScript and NATS",
        "slug": "typescript-and-nats",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "AsyncAPI CLI to rule them all",
        "slug": "asyncapi-cli-to-rule-them-all",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Event gateway",
        "slug": "event-gateway",
        "lvl": 2,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Domain model generation",
        "slug": "domain-model-generation",
        "lvl": 2,
        "i": 7,
        "seen": 0
      },
      {
        "content": "Community continues to grow",
        "slug": "community-continues-to-grow",
        "lvl": 2,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Other features",
        "slug": "other-features",
        "lvl": 2,
        "i": 9,
        "seen": 0
      },
      {
        "content": "Good learning resources",
        "slug": "good-learning-resources",
        "lvl": 2,
        "i": 10,
        "seen": 0
      }
    ],
    "slug": "/blog/february-2021-at-asyncapi",
    "filePath": "pages/blog/february-2021-at-asyncapi.md"
  },
  {
    "meta": {
      "title": "Finding a Good Open Governance Model for AsyncAPI",
      "date": "2021-03-08T05:00:00.000Z",
      "type": "Strategy",
      "tags": [
        "Governance",
        "Foundation"
      ],
      "cover": "/img/posts/governance-motivation-cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        },
        {
          "name": "Fran Méndez",
          "photo": "/img/avatars/fmvilas.webp",
          "link": "https://twitter.com/fmvilas",
          "byline": "AsyncAPI Founder"
        }
      ],
      "excerpt": "AsyncAPI can be successful if the initiative is community-driven. To be community-driven, we need the community to see it can drive things and make an impact. For that, we need a proper open governance model. What model would be the best?",
      "readingTime": 7
    },
    "content": "\n> tl;dr charter for the AsyncAPI Initiative open governance is ready for review. Leave your comments there in [this](https://github.com/asyncapi/.github/pull/37) pull request. We will wait two weeks for your feedback.\n\nDecember 2020 brought to AsyncAPI an important announcement, a [partnership with Postman](/blog/asyncapi-partners-with-postman). This huge milestone secured the AsyncAPI Initiative development efforts as few active community members moved to Postman. This move speeded up our work on transferring AsyncAPI to a foundation and forming an open governance model to assure the community that a single company does not control AsyncAPI Initiative.\n\nIt took us a lot of time to write down the initial charter for the initiative.\n\n> **Pro Tip**:\n[Charter](https://dictionary.cambridge.org/dictionary/english/charter) is not a person that creates charts :smiley:\nNobody's trying to be a smart ass here. We actually had to google that :smiley:\n\n## The vision\n\nWe started with a basic vision in our heads and studied governance models of many diverse communities, like NodeJS Foundation, OpenJS Foundation, GraphQL Foundation, Cloud Events, OpenAPI Initiative, and CNCF. We also got a charter template from Linux Foundation. That was a lot to handle. \n\n<center><img className=\"w-1/3\" src=\"https://media.giphy.com/media/5QMPpCzH6yxEqhev5A/giphy.gif\" /></center>\n\nIn the end, we just wanted to make sure the initiative is community-driven and leaves no one behind. We tried to figure out a governance model that:\n- is as democratic as possible\n- supports the asynchronous decision-making process\n- gives power to people that \"work\", not companies that \"pay\". In other words, it gives equal power to both individual and corporate contributors.\n\n### Vocabulary\n\nIn the AsyncAPI governance model, you can find two essential roles: contributor and committer. A contributor is a person that contributes to the project code, docs, or other artifacts. A committer is a person that contributes regularly and is invited by other committers to manage the repository, to have more privileges, and to approve pull requests.\n\nCommitter rules in the repository, but for topics that go beyond, there is a Technical Steering Committee (TSC). \n\nTSC consists of all committers. \n\nYes, not a dedicated group of people for now. Are you a committer? If yes, then it means you are a voting member of TSC (unless you do not want to). But more on that further in the blog post.\n\n### Single TSC for spec and tools\n\nSpec and tools will have different licenses, but there will not be two TSCs though. One TSC to handle both the specification and the tools.\n\nWhy?\n\n- start small, they say.\n- don't design processes and then work accordingly but better build a process that facilitates the way you work already.\n- we are a large community, but not large enough to handle two different charters, not now.\n\nThe other good reason for not splitting is that we believe the initiative should work on spec and tools to provide essential open-source tools that consistently support the latest version of the specification. In other words, when we release the newest version of the specification, you can already use it with official tools and do not have to wait for other tooling providers to catch up. We know big companies do not care much about basic tooling as they most probably write their own because it is much easier for them to work without unnecessary noise. Nevertheless, we need to think about the small ones too. Two TSCs sound like having two silos that work separately, and it is not good for the start. Nobody says, though, that the TSC can't organically grow into two separate groups in the future.\n\n\n### Value work more than money\n\nWe want to have a TSC consisting of all the active committers in the project, not people who are there because their company is a sponsor of the project. You are a TSC member because you work on the project, you code, write docs, maintain CI. You work, and therefore, you are a part of the initiative.\n\nWhy? Don't you like money?\n\nWe like money, don't get us wrong here :smiley: Money helps the project a lot, we can sponsor many good things with the money we obtain from you.\n\nNevertheless, we believe that it isn't good to run a project alone with lots of bucks in the pocket. \n\nWhat? We need a doctor here!\n\n:man_shrugging: We just prefer to work with a large group of people, from different cultures, from other parts of the world, with diverse experience and use cases in heads. That is just how you build great products by having many people around you to help and validate the ideas actively.\n\n\n### Respecting committers and the right to vote \n\nThe rule we want to follow is that the committer automatically gets a right to vote. \n\nWhy? \n\nVoting is always about essential things, essential for the entire initiative. Who else should have a right to vote if not people that are directly affected by the decisions of the ToC? The tricky situation here is that this approach can lead to a problem where one company hires most committers and, therefore, takes over project steering. This is something we actually have at the moment. The majority of folks working actively on the project are from Postman. Nothing terrible happened to the project for now, but this doesn't mean the whole community feels comfortable.\n\nWe had a tough brainstorming here about finding the right balance between respecting all contributors equally and still making sure that there is no risk that a company has most voters. That is why we have a rule that only 1/4 of voters can be affiliated with the same company. Or 1/3 in case we need to look for more maintainers to bring balance back to the force.\n\n### Work on all the tools under the AsyncAPI umbrella\n\nWe want AsyncAPI Initiative to be a place where AsyncAPI open source tools are developed, together, so we do not duplicate each other in the community with different variations of the same tool. So far, seven AsyncAPI tools resulted from different companies or individuals' work and moved to the AsyncAPI GitHub organization. We want this to become a standard in the community. \n\nThe governance model embraces this direction. How? \n\nIf you own a project, you created it. It means you are its committer. \n\nDo you see where We're getting?\n\nYes, it means that once you donate the project to the AsyncAPI Initiative, you do not only stay there as a committer but also become a voting member.\n\n### No meetings - async all the things\n\nWe hate to have too many meetings. Meetings suck out your blood. Meetings = schedule and schedule = leash. \n\nZero meetings? No, we will have something on the schedule, but it will not be mandatory. We will not make decisions during the meetings, so you do not have to rush to be there. You just need to watch the recording to learn if there is something relevant for you if there is a topic that needs voting. Decision-making should be asynchronous, and people should have time to make wise decisions.\n\nThe async decision-making process also assures that the number of voters can scale up easily, and we should be able to handle as many committers in the group as we have. We can automate many things here.\n\n### Wishful thinking\n\nWe hope that a side effect of such an open governance model will be that companies will have a better motivation to sponsor the initiative financially and assign employees to work on the spec and tooling regularly to become committers and become voting members of the TSC. \n\nHopefully, these companies will take shortcuts here that will open up new job opportunities for individual contributors.\n\nThat was not our initial goal, though. We just figured that this might happen, and we look forward to it. \n\nI hope this rough explanation makes it easier to digest the charter. Please share what you think. Use [Twitter](https://twitter.com/AsyncAPISpec), [Slack](https://www.asyncapi.com/slack-invite/), email. Write publicly or privately. We just care about the feedback and not how you pass it on. \n\nYou can also comment on [this](https://github.com/asyncapi/.github/pull/37) pull request with the charter. You can leave generic comments that we could reuse in official communication after we join the foundation.\n\nCheers :beers:\n\n> Photo by <a href=\"https://unsplash.com/@unitednations\">United Nations COVID-19 Response</a> on <a href=\"https://unsplash.com/photos/gMPsl1ez-Ts\">Unsplash</a>\n",
    "toc": [
      {
        "content": "The vision",
        "slug": "the-vision",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Vocabulary",
        "slug": "vocabulary",
        "lvl": 3,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Single TSC for spec and tools",
        "slug": "single-tsc-for-spec-and-tools",
        "lvl": 3,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Value work more than money",
        "slug": "value-work-more-than-money",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Respecting committers and the right to vote",
        "slug": "respecting-committers-and-the-right-to-vote",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Work on all the tools under the AsyncAPI umbrella",
        "slug": "work-on-all-the-tools-under-the-asyncapi-umbrella",
        "lvl": 3,
        "i": 5,
        "seen": 0
      },
      {
        "content": "No meetings - async all the things",
        "slug": "no-meetings---async-all-the-things",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Wishful thinking",
        "slug": "wishful-thinking",
        "lvl": 3,
        "i": 7,
        "seen": 0
      }
    ],
    "slug": "/blog/governance-motivation",
    "filePath": "pages/blog/governance-motivation.md"
  },
  {
    "meta": {
      "title": "January 2021 at AsyncAPI",
      "date": "2021-02-11T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/january-2021-at-asyncapi/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Dev Comm Keeper"
        }
      ],
      "excerpt": "I always thought January is a month of a slow start of a new year. I could not have been more wrong. No time to rest, no slow down here.",
      "readingTime": 8
    },
    "content": "\nA new year always comes with New Year's resolution, right? Folks from [Bump.sh](https://bump.sh/) came up with the best idea you could get this year. Don't you dare to fail this time :smiley:\n\n<TwitterTweetEmbed\n  tweetId='1346374069877428225'\n  options={{\n    cards: 'hidden',\n    width: 500,\n    align: 'center'\n  }}\n/>\n\n## Foundation and open governance model\n\nAs part of recently [announced](/blog/asyncapi-partners-with-postman) partnership with Postman, most core AsyncAPI maintainers joined Postman as employees. This change made it clear that now it is even more important what we planned in the past.\n\nAsyncAPI must go into a \"neutral ground\" aka independent foundation that, among other things, will take over the AsyncAPI intellectual property. \n\nJoining a foundation also means setting up an open governance model to ensure a single company's lack of dominance over the specification and its tools. \n\nAs communicated during our public meetings on [2nd of February](https://www.youtube.com/watch?v=vAcTtr__CwU) or [19th of January](https://www.youtube.com/watch?v=14I-l-TCgI4), or our official [Twitter account](https://twitter.com/AsyncAPISpec/status/1351895870636220418), Fran and I treat this topic as priority number 1.\n\nAt the moment, we are trying to figure out a governance model that:\n- is as democratic as possible\n- supports asynchronous decision-making process\n- gives power to people that \"work\", not companies that \"pay\". In other words, it gives equal power to both, individual and corporate contributors\n\nNow we spend a lot of time reading and reaching out to similar communities that went this path and know what booby traps to avoid to stay healthy. We hope to share something more concrete in the next update, in March.\n\n## New bronze sponsor\n\nWe kicked off this year with a new bronze sponsor. Thanks a lot to Bump.sh and their trust in the AsyncAPI Initiative, and being among the first ones adopting the AsyncAPI specification in their product.\n\n<TwitterTweetEmbed\n  tweetId='1357262834200117250'\n  options={{\n    cards: 'hidden',\n    width: 500,\n    align: 'center'\n  }}\n/>\n\n## Community continues to grow\n\nMy [last post](/blog/2020-summary) that summarizes the year 2020 was pretty clear that the community's size grew a lot. Well, it is January, and we see that not much has changed. We keep growing:\n- we went over 1k users on Slack. [Join now](https://www.asyncapi.com/slack-invite/)\n- we went over 1.5k followers on Twitter. [Follow us](https://twitter.com/AsyncAPISpec/) to be up to date with the latest news in the project\n- we went over 1.4k stars on GitHub. If you like the project, [express it](https://github.com/asyncapi/asyncapi/stargazers)\n- we had several issues solved by the community members from different companies, including few new features. For more details, read [Feature releases and community-driven changes](#feature-releases-and-community-driven-changes) section\n\nLast but not least, we beat the record of people joining our public meetings :rocket:\n\n<TwitterTweetEmbed\n  tweetId='1356949862449893376'\n  options={{\n    width: 500,\n    align: 'center'\n  }}\n/>\n\n## RapidAPI Developer Survey\n\nRapidAPI released the results of their [developer survey](https://rapidapi.com/developer-survey/). Reading it at the beginning of the year is like drinking a strong coffee in the morning - you get a good kick of positive energy for the rest of the year.\n\nSpoiler alert -> number of developers using AsyncAPI in production tripled in 2020.\n\n## Feature releases and community-driven changes\n\n- [Pavel Bodiachevskii](https://twitter.com/PBodiachevskii) continues his hard work on **asyncapi-java**. Wait, it is finally not **asyncapi-java** anymore. Thanks to a suggestion from [James Higginbotham](https://twitter.com/launchany) it is all about [jasyncapi](https://github.com/asyncapi/jasyncapi/) now. Maven, Gradle and IntelliJ plugins are not published as a preview release under official AsyncAPI accounts. Please give them a try and share your feedback.\n- React component:\n  - shows [required flag for required props](https://github.com/asyncapi/asyncapi-react/releases/tag/v0.18.0) thanks to [c-pius](https://github.com/c-pius) from [SAP](https://twitter.com/SAP)\n  - we have better [DX in Web component](https://twitter.com/AsyncAPISpec/status/1352565434181177344) thanks to [Viacheslav Turovskyi](https://github.com/aeworxet)\n- Playground now shows [much detailed errors](https://twitter.com/AsyncAPISpec/status/1354728263705366528) thanks to [Jorge Aguiar Martín](https://github.com/jotamusik) from [Lean Mind - es](https://twitter.com/leanfulness_es)\n- HTML template:\n  - [CSS size decreased and introduction of Tailwind 2.0](https://twitter.com/AsyncAPISpec/status/1357648468798504965) thanks to [Julian Schafer](https://twitter.com/ju_schaefer)\n  - [CorrelationId rendering](https://twitter.com/AsyncAPISpec/status/1356289864984096768) thanks to [Ludovic Dussart](https://github.com/M3lkior) from [IneatLab](https://twitter.com/IneatLab)\n\n## TypeScript NATS template\n\nWe have a [new template](https://github.com/asyncapi/ts-nats-template) available. You can use this template to generate [NATS](https://nats.io/) client based on the AsyncAPI document for Node.js. Interesting fact: it is already using the new [React render engine](https://github.com/asyncapi/generator/blob/master/docs/authoring.md#react) from the AsyncAPI Generator.\n\n## Next major feature is data model generation\n\nWe again invest big-time in the Generator. This time, it is all about making it super easy to generate a data model for templates, so the template developer doesn't waste much time on templating it and can focus on the template's main logic. In other words, it is all about enabling faster template development. Our [progress](https://shapeup.asyncapi.io/cycles/6301193) looks good, and it seems like at the end of February, we should already have something that you can start using.\n\nFeel free to share your thoughts in [this](https://github.com/asyncapi/shape-up-process/issues/43) issue.\n\n## Refactoring of our CI/CD\n\nGitHub Actions is what powers our CI/CD. It is a great tool that you configure through a file stored in a repository. Things are just getting more complex when you want to use them in an organization with around 40 repositories (and growing). This is not a post about our internal organizational challenges and GitHub Actions limitations, so I will not bother you with details. The most important is to share that we are managing our GitHub workflows like a pro and if you are interested in more details, contact us.\n\nSo what changed that is meaningful for our community:\n- We have two new channels in Slack workspace:\n  - #github-releases where you get information about all the releases from all the repositories\n  - #github-new-issues-prs where you get information about all new issues and PRs\n- Whenever we have a major or a minor release in any repository, our bot automatically tweets about it\n- All pull requests are now tested against Linux, MacOS, and Windows. For you, this means that we fixed a lot of bugs in tests and configurations that were blocking Windows users from smooth contributions\n- Not used to Conventional Commits specification? now all pull requests have a dedicated check that lints your pull request titles and gives hints what you should fix\n- You contributed something to the JavaScript Parser, and you wonder what you have to do to see the change in the Generator? No need to wonder. Now, when we release any package, we also bump its version in all the other packages that depend on it. AsyncAPI bot is a super busy bot :robot:\n\n## The future of API specifications\n\nWorking with specifications is not easy because there are many of them. How do you know when to use which one? Just look at the concept of microservices architecture. Did you think that monitoring, scaling, and tracing is a challenge? What about specifications:\n- you need a different spec for your backend that exposes GraphQL API to your frontend\n- you need another spec to describe how a user can interact with your service using asynchronous communication\n- you need a different spec to define how a user can interact with your service with REST\n\nWhat about specs for describing your data model? What about if you use RPC and Protobuf? What if you use Avro? or maybe you only use JSON Schema. \n\nWhy do you have to define the same things over and over using different specs...\n\n![](https://media.giphy.com/media/lQCV6K36nJfJYNxXbC/giphy.gif)\n\nSomething went wrong down the road, and we need to do something to save the chicken. \n\nWatch Fran's presentation on the future of API specification. And don't stop there. We don't want only to admit we know about the problem and expect someone solves it. We want to fix it. Join us!\n\n<YouTube id=\"z3nA_2Wu91A\" />\n\n## Public meetings\n\nFor notes and links to recordings, look into the below references:\n- [Jan 5 2021](https://github.com/asyncapi/asyncapi/issues/472)\n- [Jan 19 2021](https://github.com/asyncapi/asyncapi/issues/474)\n\nSpoiler alert -> leading topic during the meetings was [the status of AsyncAPI](#foundation-and-open-governance-model).\n\nNext meeting is scheduled for [Feb 16 2021](https://github.com/asyncapi/asyncapi/issues/497) for [8AM UTC](https://everytimezone.com/s/2f3eb2cc). Feel free to suggest a topic or such join to say hello.\n\n## Google Summer of Code\n\nThis month we want to apply for [Google Summer of Code](https://summerofcode.withgoogle.com/). We found two volunteers that agreed to mentor participants to work on some good stuff for the AsyncAPI tooling space. January was when we collected all the possible ideas that we would work on together with students. The [list of ideas](https://docs.google.com/document/d/11g0ezAvrZGRYhe5NEV4fOq4zAnLQPmOow0egxgSokUs/edit?usp=sharing) is completed. There are many good proposals there, and most of them won't make it to the event, so feel free to let us know if you want to work on them under the AsyncAPI umbrella. \n\n## Good read\n\n- [AsyncAPI and OpenAPI: an API Modeling Approach](https://engineering.salesforce.com/asyncapi-and-openapi-an-api-modeling-approach-db9873695910) by [Antonio Garrote](https://twitter.com/antoniogarrote)\n- [API adoption is on the rise across all industries](https://www.helpnetsecurity.com/2021/02/05/api-adoption-2021/)\n- [How Microcks Can Speed-Up Your AsyncAPI Adoption - Part 2](/blog/microcks-asyncapi-part2) by [Laurent Broudoux](https://twitter.com/lbroudoux)\n- [Simplify code generation with React](/blog/react-as-generator-engine) by [Jonas Lagoni](https://www.linkedin.com/in/jonas-terp-lagoni-85b027b9/) and [Maciej Urbańczyk](https://www.linkedin.com/in/maciej-urba%C5%84czyk-909547164/)\n\nThat was an exhausting month, but looking at what is happening around the project, you feel it was worth it. Let us see what February brings.\n\n> Photo by <a href=\"https://unsplash.com/@nhoizey?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Nicolas Hoizey</a> on <a href=\"https://unsplash.com/s/photos/start?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "Foundation and open governance model",
        "slug": "foundation-and-open-governance-model",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "New bronze sponsor",
        "slug": "new-bronze-sponsor",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Community continues to grow",
        "slug": "community-continues-to-grow",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "RapidAPI Developer Survey",
        "slug": "rapidapi-developer-survey",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Feature releases and community-driven changes",
        "slug": "feature-releases-and-community-driven-changes",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "TypeScript NATS template",
        "slug": "typescript-nats-template",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Next major feature is data model generation",
        "slug": "next-major-feature-is-data-model-generation",
        "lvl": 2,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Refactoring of our CI/CD",
        "slug": "refactoring-of-our-cicd",
        "lvl": 2,
        "i": 7,
        "seen": 0
      },
      {
        "content": "The future of API specifications",
        "slug": "the-future-of-api-specifications",
        "lvl": 2,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Public meetings",
        "slug": "public-meetings",
        "lvl": 2,
        "i": 9,
        "seen": 0
      },
      {
        "content": "Google Summer of Code",
        "slug": "google-summer-of-code",
        "lvl": 2,
        "i": 10,
        "seen": 0
      },
      {
        "content": "Good read",
        "slug": "good-read",
        "lvl": 2,
        "i": 11,
        "seen": 0
      }
    ],
    "slug": "/blog/january-2021-at-asyncapi",
    "filePath": "pages/blog/january-2021-at-asyncapi.md"
  },
  {
    "meta": {
      "title": "Simplify code generation with React",
      "date": "2021-01-25T23:07:00.000Z",
      "type": "Engineering",
      "tags": [
        "Code Generation",
        "Docs Generation",
        "React",
        "Nunjucks"
      ],
      "cover": "/img/posts/react-as-generator-engine.webp",
      "authors": [
        {
          "name": "Jonas Lagoni",
          "photo": "/img/avatars/jonaslagoni.webp",
          "link": "https://github.com/jonaslagoni",
          "byline": "AsyncAPI Core Team Member"
        },
        {
          "name": "Maciej Urbańczyk",
          "photo": "/img/avatars/maciejurbanczyk.webp",
          "link": "https://github.com/magicmatatjahu",
          "byline": "AsyncAPI Core Team Member"
        }
      ],
      "readingTime": 8,
      "excerpt": "React permanently changed the way how developers write web-apps. Personally, we love React and knew it would solve many pain points we faced with Nunjucks. Therefore in the last cycle we integrated it"
    },
    "content": "\nReact permanently changed the way how developers write web-apps. Personally, we love React and knew it would solve many pain points we faced with Nunjucks. Therefore in the last [cycle](https://github.com/asyncapi/shape-up-process/issues/1) we integrated it as a template rendering engine into our [Generator](https://github.com/asyncapi/generator). This post is a short introduction for developers who write or plan to write templates for AsyncAPI specification using React. It also includes a comparison with the default Nunjucks renderer.\n\n## Getting started\n\nYour React template requires [@asyncapi/generator-react-sdk](https://github.com/asyncapi/generator-react-sdk) as a dependency. You need it to access the **File** component required as a root component responsible for rendering a file. Furthermore, it provides some common components to make your development easier, like **Text** or **Indent**.\t\n\nLet's consider a basic React template file as the one below called **MyTemplate.js**:\n\n<CodeBlock language=\"javascript\" highlightedLines={[5,6,7]}>\n{`import { File, Text } from \"@asyncapi/generator-react-sdk\";\\n\nexport default function({ asyncapi, params, originalAsyncAPI }) {\n  return (\n    <File name=\"asyncapi.md\">\n      <Text>Some text that should render as is</Text>\n    </File>\n  );\n}`}\n</CodeBlock>\n\nThe exported default function returns the **File** component as a root component that the [Generator](https://github.com/asyncapi/generator) uses to figure out what file it should generate. In the example above, we overwrite the default functionality of saving the file as **MyTemplate.js**, and we set **asyncapi.md** as the filename. Using the **Text** component, we specify what content should be rendered inside the file. The content of the resulting file is: `Some text that should render as is\\n`. Notice the **\\n** character at the end. It is automatically added after the **Text** component.\n\n> For further information about components and their props, see the [Generator React SDK](https://github.com/asyncapi/generator-react-sdk).\t \n\nThe [Generator](https://github.com/asyncapi/generator) doesn't use React renderer by default. You need to specify in the template configuration that your template is based on React. For that, change the **renderer** field of **generator** object inside the template's **package.json** file:\n\n```json\n{\n  ...\n  \"generator\": {\n    \"renderer\": \"react\",\n    ...\n  }\n}\n```\n\nYou can find more information about the Generator configuration [here](https://github.com/asyncapi/generator/blob/master/docs/authoring.md#configuration-file).\t \n\n## How it works\n\nThe process of creating content from React components consists of two steps: transpile and render.\t \n\nThe SDK has a custom transpiler which ensures that any directory in template's **template** folder are transpiled using [Rollup](https://www.npmjs.com/package/rollup). Rollup helps bundling all dependencies and transpile them into CommonJS modules. This is required because this library will be used through NodeJS (by AsyncAPI Generator) which does not understand these new modules natively and we do not want to limit the developer in which syntax they prefer nor how they want to separate code.\n\nAlso, SDK has its own reconciler. It traverses through each element in the template structure and transforms it into a pure string. Prop `children` is always converted to a regular string and stored in the `childrenContent` prop in each component. Check the below example, to see how it works. In addition, you can also see how to apply the composition to templates using components:\n\n```js\nimport { Text, Indent, IndentationTypes, render } from '@asyncapi/generator-react-sdk';\n\nclass ClassComponent extends React.Component {\n  constructor(props) { \n    super(props);\n  }\n\n  render() {\n    // In `childrenContent` prop is stored `text wrapped by custom component\\n\\n`.\n    // The content of the `children` prop is transformed to string and saved to the `childrenContent` prop.\n    return this.props.childrenContent;\n  }\n}\n\nfunction FunctionComponent() {\n  return (\n    <Indent size={3} type={IndentationTypes.TABS}>\n      indented text\n      <ClassComponent>\n        <Text newLines={2}>\n          text wrapped by custom component\n        </Text>\n      </ClassComponent>\n    </Indent>\n  );\n}\n\n// content will be `\\t\\t\\tindented text text wrapped by custom component\\n\\n`\nconst content = render(<FunctionComponent />);\n```\n\nThere are some restrictions:\n\n- React hooks feature is not allowed.\n- HTML tags are not supported.\n- React internal components like `Fragments`, `Suspense`, and others are skipped.\n\n## Comparison with Nunjucks\n\nThe AsyncAPI generator still uses [Nunjucks](https://mozilla.github.io/nunjucks/) as a default render engine. It's a templating language, heavily focused on string literals, filters (similar to bash pipes), and partials called macros.\t\n\nThe next sections compare how you can accomplish certain things in Nunjucks and React. For more complex examples, see the [template-for-generator-templates](https://github.com/asyncapi/template-for-generator-templates) repository with examples based on React and compare those with [nunjucks](https://github.com/asyncapi/template-for-generator-templates/tree/nunjucks) branch.\n\n### Creating reusable parts\n\nIt may sound obvious, but when writing any code, even a template, a programmer wants to create reusable parts that separate repeating logic.\n\nIn Nunjucks, you can reuse parts of the template using **macros**, in React, using **components**. Imagine that you are writing a template that produces Markdown content. You need to create a reusable macro/component that renders a list from an array of strings.\n\nUsing Nunjucks you can write the code below:\n\n```njk\n{% macro list(data, type = \"-\") %}\n{% for item in data %}\n{{type}} {{item}}\n{% endfor %}\n{% endmacro %}\n\n{% from \"partials/list.njk\" import list %}\n{{ list([\"one\", \"two\", \"three\"]) }}\n```\n\nUsing React you can write the code below:\n\n```js\nfunction List({ list = [], type = \"-\" }) {\n  return list.map(item => `${type} ${item}\\n`);\n}\n\n// use `List` component in another component\nexport function SimpleList() {\n  return (\n    <List list={[\"one\", \"two\", \"three\"]} />\n  );\n}\n```\n\nLooking at both examples we see that in Nujucks we operate on string literals, it means that when passing data to a macro, you always need to know what type of data the macro takes. In React we operate on JS objects/variables. By this, your IDE should always inform you what value, of what type, you must pass to component. Additionally, you must place Nunjucks's macro inside the **partials** folder of the template. Using React, you can put your components wherever you want.\n\n### Using third party packages\n\nUsing helper functions from third-party packages, in Nunjucks you must apply them as [filters](https://github.com/asyncapi/generator/blob/master/docs/authoring.md#filters). For example, you want to use one function from [Underscore.string](https://github.com/esamattis/underscore.string) library like **cleanDiacritics**, which replaces diacritic characters with closest ASCII equivalents. To do this, you must create a function inside **filters** folder to convert the function to Nunjucks's filter:\n\n```js\n// filters/cleanDiacritics.js\nconst cleanDiacritics = require('underscore.string/cleanDiacritics');\nconst filter = module.exports;\nfilter.cleanDiacritics = cleanDiacritics;\n```\n\nAnd then you can use this function inside your template/macro:\n\n```njk\n{{ Urbańczyk | cleanDiacritics }} # will be Urbanczyk\n```\n\nThe main problem with this solution is that it creates an unnecessary boilerplate - you must create a function in a separate file. Another problem is that you operate on the name of this helper function which means you must always remember what filters you have included in your template.\n\nIn opposite, in React you can use `Underscore.string` directly in your template:\n\n```js\nimport cleanDiacritics from 'underscore.string/cleanDiacritics';  \n\nfunction MyComponent() {\n  return cleanDiacritics('Urbańczyk'); // will be Urbanczyk\n}\n```\n\nIt is worth mentioning that when using packages in this way, you always operate on the reference to the function, not on its name, so you know what functions you have in the file's scope.\n\n## Cons & Pros\n\nLike any solution, React has its advantages as well as disadvantages.\n\n### Advantages\n\n- Using React, you use JS directly. You don't need to learn custom Nunjuck's syntax, only how React works under the hood.\n- It provides better debugging functionality that is not possible with Nunjucks.\n- It provides better error stack traces.\n- Better tools support development. You write templates in JavaScript, you use a reference to functions/variables, and therefore your IDE can tell you what you can use in a given scope.\t\n- Provides better support for separating code into more manageable chunks/components. You don't need to create **partials** folder. You can create React component wherever you want, also next to the template's source code.\n - You can easily test your components. It is difficult with Nunjucks. You can split template file into separate chunks and test them in separate test cases.\n\n### Disadvantages\n\n- Common pain when writing templates with React is related to indentations and new lines. However, we have several helpers in SDK to make your life easier, like [`Indent`](https://github.com/asyncapi/generator-react-sdk/blob/master/src/components/Indent.tsx) or [`Text`](https://github.com/asyncapi/generator-react-sdk/blob/master/src/components/Text.tsx) components.\n- Some people don't like to mix logic inside template files, so probably React won't be friendly for them.\n- HTML tags at the moment are not supported. The developer must write them as a string literal, like [here](https://github.com/asyncapi/template-for-generator-templates/blob/main/components/ListChannels.js#L18).\n\n## Resources\n\nWe use React render engine already in three official AsyncAPI templates:\n\n- [template-for-generator-templates](https://github.com/asyncapi/template-for-generator-templates) template showcases features of [the AsyncAPI Generator](https://github.com/asyncapi/generator), including the React renderer. It shows how to write templates, reusable parts (components), what are the recommended patterns. It has simple and complex examples. You can also check how the same things could be done using Nunjucks in [this](https://github.com/asyncapi/template-for-generator-templates/tree/nunjucks) branch.\n- [markdown-template](https://github.com/asyncapi/markdown-template) is written using React. It generates documentation into a Markdown file.\n- [ts-nats-template](https://github.com/asyncapi/ts-nats-template/) is re-written using React to generate a TypeScript NATS client.\n\nIf you want to check the source code of React renderer, go to the [official repository](https://github.com/asyncapi/generator-react-sdk).\n\n## Summary\n\nThere is a long way ahead of us to stabilize React as a render engine. We know about problems that make it unpleasant to write templates using React, such as indents or new lines, but we will work on that. Additionally, we have a couple of improvements on our list that will allow things like [File Templates](https://github.com/asyncapi/generator-react-sdk/issues/10) to be simplified in the Generator. We also plan to support [TypeScript](https://github.com/asyncapi/generator-react-sdk/issues/3).\n\nWe are waiting for your feedback.\n\nHappy coding!\n\n> Cover photo is from [`Drunken Master`](https://www.imdb.com/title/tt0080179/) movie.\n",
    "toc": [
      {
        "content": "Getting started",
        "slug": "getting-started",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "How it works",
        "slug": "how-it-works",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Comparison with Nunjucks",
        "slug": "comparison-with-nunjucks",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Creating reusable parts",
        "slug": "creating-reusable-parts",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Using third party packages",
        "slug": "using-third-party-packages",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Cons & Pros",
        "slug": "cons--pros",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Advantages",
        "slug": "advantages",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Disadvantages",
        "slug": "disadvantages",
        "lvl": 3,
        "i": 7,
        "seen": 0
      },
      {
        "content": "Resources",
        "slug": "resources",
        "lvl": 2,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Summary",
        "slug": "summary",
        "lvl": 2,
        "i": 9,
        "seen": 0
      }
    ],
    "slug": "/blog/react-as-generator-engine",
    "filePath": "pages/blog/react-as-generator-engine.md"
  },
  {
    "meta": {
      "title": "How Microcks Can Speed-Up Your AsyncAPI Adoption - Part 2",
      "date": "2021-01-06T23:07:00.000Z",
      "type": "Engineering",
      "tags": [
        "Testing",
        "Mocking",
        "Strimzi",
        "Kafka"
      ],
      "cover": "/img/posts/microcks-asyncapi-part2/microcks-kafka-distribs.webp",
      "authors": [
        {
          "name": "Laurent Broudoux",
          "photo": "/img/avatars/lbroudoux.webp",
          "link": "https://twitter.com/lbroudoux",
          "byline": "Microcks.io Founder"
        }
      ],
      "readingTime": 8,
      "excerpt": "On our first AsyncAPI blog post we have introduced Microcks 1.0 General Availability (GA) as a unique milestone for mocking and testing event-driven API like any other APIs through the support of Asyn"
    },
    "content": "\nOn our [first AsyncAPI blog post](/blog/microcks-asyncapi-part1) we have introduced [Microcks 1.0 General Availability (GA)](https://microcks.io/blog/microcks-1.0.0-release/) as a unique milestone for mocking and testing event-driven API like any other APIs through the support of AsyncAPI specification.\n\nIn case you missed it, we have already released [version 1.1.0](https://microcks.io/blog/microcks-1.1.0-release/) in the meantime. This release includes some nice enhancements related to the topic of the day: **Microcks + AsyncAPI use cases using Apache Kafka**. This post will show you how Microcks is leveraging the AsyncAPI specification on Kafka in a very pragmatic and powerful approach: way beyond documentation or code generation! We will also go through the different business use-cases implemented by users integrating Microcks in their asynchronous API toolchain.\n\nWhen we are talking about Kafka we mean all Kafka distributions translated into *the choice is yours*: from vanilla Apache upstream distribution, to enterprise products and also cloud providers’ managed distributions!\n\n![microcks-kafka-distribs](/img/posts/microcks-asyncapi-part2/microcks-kafka-distribs.webp)\n\n> By the way, we will be happy to have some QA [contributors and reports](https://github.com/microcks/microcks/blob/master/CONTRIBUTING.md) on more brokers and AsyncAPI supported protocols :wink:\n\nBefore diving into AsyncAPI on Apache Kafka, let first see why simulating producers is a key project success factor.\n\n## Why simulating producers is a key project success factor?\n\nAs good developers, we are lazy - in a very good way :wink: - and hate to restart from scratch our beautiful code implementations due to misunderstanding with Product Owners. However, nowadays Product Owners adopted and love the [Fail-Fast Principle](https://www.forbes.com/sites/danpontefract/2018/09/15/the-foolishness-of-fail-fast-fail-often/). We can't rely on functional implementations to start beta testing with consumers, we should fail fast and make them change requirements before we start implementation.\n\nApart from generating frustrations, this above situation is also very inefficient from a cost and time to market point of view for the organization. \n\nThe contract-first approach is a wonderful way to create strong and efficient agreements between functional / business / product owners and developers! But it represents only a partial answer to the above situation\n\n![time-money-quality](/img/posts/microcks-asyncapi-part2/time-money-quality.webp)\n\nTo avoid unnecessary work from developers and speed-up feedback gathering from consumers, simulation is the second part of the answer. That is why Microck's first use case and the killer feature is mocking!\n\nThese are some of the reasons why the way to do mocking with Microcks is highly scalable: \n* We rely 100% on Product Owners contracts \n* We rely 100% on standards and specifications to describe contracts\n* We automatically generate all APIs mocks from contracts: no code!\n* We publish APIs mocks like real implementations using specifications examples \n* We centralize all contracts and are the single point of trust\n* We are always in sync with your repositories: no drift anymore!\n* We provide sandbox at scale. You can heavily stress tests your business rules. Remember, we are Kubernetes-native!\n\nThis is why Microcks is the ultimate way to test, iterate and speed-up your APIs validations before asking developers to code the real implementation! And this certainly applies to asynchronous API on Kafka too: thanks to [AsyncAPI specification](https://www.asyncapi.com/docs/specifications/2.0.0).\n\nNow let’s start with first feature: mocking asynchronous API.\n\n## Mocking asynchronous API on top of Apache Kafka\n\nThis is how Microcks value proposition of accelerating Kafka asynchronous API simulation looks like:\n\n![microcks-kafka-mocking](/img/posts/microcks-asyncapi-part2/microcks-kafka-mocking.webp)\n\nIn a very pragmatic approach, Microcks uses your AsyncAPI specification as the source of truth for your simulation. As soon as it is imported into Microcks, it manages to create a topic for your API version on the connected Kafka broker and starts publishing mock messages. Messages are published at a configured frequency and thus consumers immediately start receiving event messages as if it is published by a real application. Thanks to Microcks’ [message templating](https://microcks.io/documentation/using/advanced/templates/) you can also easily include dynamic content in the sample messages.\n\nMocking event-driven architecture using Microcks is a game-changer as you do not need to write code nor set up complex infrastructure! Your consumers can receive messages in the minute. Testing some changes is just one commit away. You update the AsyncAPI specification in the Git repository and Microcks will take care of updating everything! It's even capable of providing and managing the Kafka infrastructure thanks to the excellent [Strimzi.io](https://strimzi.io/) operator if you wish! See our [Everything managed by Microcks](https://microcks.io/documentation/installing/deployment-options/#everything-managed-by-microcks) deployment option :rocket:\n\nOur second feature is testing or how to make your delivery lifecycle reliable.\n\n## How to make your delivery lifecycle reliable?\n\nAs the number of event producers and subscribers is exploding, managing changes and taking care of versioning compatibility is essential. And what about checking that business rules implying event triggering are correctly implemented? The fact it produces syntactically correct events and all this in a fully automated way based on each change and new commit in your source code repository?\n\nAgain this is all provided by Microcks thanks to its capability to interoperate with your CI/CD pipeline using our plugins for [Jenkins](https://microcks.io/documentation/automating/jenkins/), [Tekton](https://microcks.io/documentation/automating/tekton/) or [any other CI pipeline technology like GitLab](https://microcks.io/documentation/automating/cli/). You'll typically use these plugins to trigger a Kafka test in Microcks.\n\n![microcks-kafka-testing](/img/posts/microcks-asyncapi-part2/microcks-kafka-testing.webp)\n\nIn Microcks, testing Kafka endpoints means connecting to a remote Kafka topic on an existing broker in the organization, listening for incoming messages, and checking that received messages are valid against the event-based API schema that is referenced in your source of truth: the AsyncAPI specification. You can find further technical details on the blog post [mocking and testing Apache Kafka API using Microcks](https://microcks.io/blog/apache-kafka-mocking-testing/).\n\nTesting of event-driven architecture is no longer a nightmare with Microcks! Microcks can connect to the Kafka brokers in your organization and tell you if the received messages are valid according to your specification. No drifting risks anymore or way to introduce regression in production! You'll drive and control everything from your pipeline.\n\nWhat are the business use-cases of AsyncAPI? Where can you use Microcks as an essential part of your toolchain?\n\n## Business use-cases of AsyncAPI\n\nAs said before, event-driven and asynchronous APIs are becoming mainstream because we truly understand the decoupling level - and thus power and agility - it brings within our products. We see the need for asynchronous APIs and Apache Kafka's presence as the de facto standard for message brokering - everywhere.\n\n* In every business vertical: to decouple a recording action (registration, purchase, like) to a marketing reaction (CRM update, behavioral analysis, marketing notification, renewal process management, etc...)\n* In Governmental organizations: to synchronize complex and partitioned repositories using master data management and staging pipelines techniques\n* In Financial Services: to streamline the sharing of information between core platforms and distribution ecosystems of partners,\n* In Industry: to enable Industry 4.0 to use IoT and become more agile to respond to market unpredictability and improve quality,\n* Soon in every Citizen's life: to power tomorrow Smart Cities with IoT and enable smart real-time insights and decision making.\n\nThese use cases come from companies using Microcks for simulating and testing their API implementation, and we are thankful to our users and community.\n\n## Summary\n\nWe are convinced that cutting edge developers understand the purpose, usages, and efficiency of asynchronous mechanisms. To take all its advantages and especially to use an AsyncAPI contract-first approach: developers must work hand in hand with software architects, business/product owners within the enterprise. In our humble opinion, this is clearly a strong point of attention to improve collaboration between enterprise silos and take the quintessence of AsyncAPI specification for a contract-first approach using Microcks as the ultimate tooling for mocking and testing purposes. Please read our [previous blog post on this topic](https://microcks.io/blog/continuous-testing-all-your-apis/) and share it with your software architects :wink:\n\nWe hope these two Microcks features - mocking and testing - and application use-cases are clear and you now better understand our value proposition. Microcks proposes a very pragmatic and powerful usage of AsyncAPI specification: way beyond documentation or code generation! It allows you to speed-up and makes your delivery of Kafka event-driven architectures reliable.\n\nThe roadmap ahead is also full of exciting new features we are looking forward to: \n\n* Continuing to make AsyncAPI full potential bloom through implementing multiple schema format supports - like Apache Avro - and [adding examples in the spec](https://github.com/asyncapi/asyncapi/issues/329),\n* Taking advantage of multiple protocol binding capabilities, releasing very soon a [MQTT implementation](https://github.com/microcks/microcks/issues/293) to support our users and prospects on the IoT landscape,\n* Solidifying an initiative we started a long time ago about a shared repository of simulation and test suites for standards or products APIs...\n\nWe are open and you can help make Microcks an even greater tool! Please spread the word, send us some love through [GitHub stars](https://github.com/microcks/microcks), follow us on [Twitter](https://twitter.com/microcksio) or join our chat room on [Zulip](https://microcksio.zulipchat.com/login/).\n",
    "toc": [
      {
        "content": "Why simulating producers is a key project success factor?",
        "slug": "why-simulating-producers-is-a-key-project-success-factor",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Mocking asynchronous API on top of Apache Kafka",
        "slug": "mocking-asynchronous-api-on-top-of-apache-kafka",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "How to make your delivery lifecycle reliable?",
        "slug": "how-to-make-your-delivery-lifecycle-reliable",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Business use-cases of AsyncAPI",
        "slug": "business-use-cases-of-asyncapi",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Summary",
        "slug": "summary",
        "lvl": 2,
        "i": 4,
        "seen": 0
      }
    ],
    "slug": "/blog/microcks-asyncapi-part2",
    "filePath": "pages/blog/microcks-asyncapi-part2.md"
  },
  {
    "meta": {
      "title": "Awesome 2020 and What Can Get Better In 2021",
      "date": "2020-12-23T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/2020-summary/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Dev Comm Keeper"
        }
      ],
      "excerpt": "Fuck you COVID-19, AsyncAPI Community is stronger than you think. See the growth of AsyncAPI in 2020 in hard numbers. How we compare to 2019?",
      "readingTime": 18
    },
    "content": "\n:fu: COVID-19\n\nAsyncAPI Community is stronger than you think. \n\nSee the growth of AsyncAPI in 2020 in hard numbers. How do we compare to 2019?\n\nThis post is based on quantitative data using metrics from different platforms where AsyncAPI is present. I collected this data between 15-17.12, so they are already a bit larger by now. I'll try to confront our qualitative knowledge, what we know from discussions with others, and our observations.\n\nThis post is not 100% just in numbers and analytics. It is also a summary of all the important things that happened to the project this year.\n\n## Important moments\n\n1. Our first ever <Link href=\"/blog/asyncapi-conference-kick-off\" passHref><a>AsyncAPI Online Conference</a></Link>. This pandemic edition turned out to be a very successful event that powered us up for the rest of the year\n2. We took active part in <Link href=\"/blog/hacktoberfest-summary-2020\" passHref><a>Hacktoberfest</a></Link> as maintainers and increased the number of contributions to the project\n3. AsyncAPI was featured in InfoQ's [Software Architecture and Design InfoQ Trends Report—April 2020](https://www.infoq.com/articles/architecture-trends-2020/) that directly brought 1963 new users to the AsyncAPI website\n4. AsyncAPI showed up on [Technology Radar](https://www.thoughtworks.com/radar/tools/asyncapi) that took 1051 users directly to the AsyncAPI website\n5. Our two core tools reached their first major release\n    * [JavaScript Parser](https://github.com/asyncapi/parser-js/)\n    * [Generator](https://github.com/asyncapi/generator/)\n  \nAll those moments lead us to the most important one: the [partnership with Postman](/blog/asyncapi-partners-with-postman).\n\n## Slack\n\ntl;dr AsyncAPI community activity on [our Slack workspace](https://www.asyncapi.com/slack-invite/) doubled!\n\n<Figure\n  src=\"/img/posts/2020-summary/active-members.webp\"\n  caption=\"Figure 1: Slack active members weekly\"\n/>\n\n### Numbers getting high\n\nI don't think the below tables require any introduction.\n\n<table>\n  <tr>\n    <td align=\"center\">\n      \n    </td>\n    <td align=\"center\">\n      January 2019\n    </td>\n    <td align=\"center\">\n      January 2020\n    </td>\n    <td align=\"center\">\n      December 2020\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Messages posted\n    </td>\n    <td align=\"center\">\n      2788\n    </td>\n    <td align=\"center\">\n      25388<br/>\n      (+22600)\n    </td>\n    <td align=\"center\">\n      76609<br/>\n      (+51221)\n    </td>\n  </tr>\n    <tr>\n    <td align=\"center\">\n      Number of members\n    </td>\n    <td align=\"center\">\n      159\n    </td>\n    <td align=\"center\">\n      432<br/>\n      (+273)\n    </td>\n    <td align=\"center\">\n      888<br/>\n      (+456)\n    </td>\n  </tr>\n</table>\n\nMore members means higher activity :sweat_smile:\n\n<table>\n  <tr>\n    <td align=\"center\">\n    </td>\n    <td align=\"center\">\n      2019\n    </td>\n    <td align=\"center\">\n      2020\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Weekly members activity \n    </td>\n    <td align=\"center\">\n      45 average<br/>\n      42 median\n    </td>\n    <td align=\"center\">\n      81 average<br/>\n      76 median\n    </td>\n  </tr>\n</table>\n\n### Most present companies\n\nI was also super curious to check out where our members are coming from. The only way to do it was by checking the domain of their emails used during registration. Yes, this is not 100% accurate. Not all people use company emails in open source. It is visible in data; half of the users have the **gmail.com** domain. Nevertheless, the result of my investigation is pretty accurate with our knowledge. The ones that have more than three representants:\n- mulesoft.com\n- postman.com\n- redhat.com\n- sap.com\n- smartbear.com\n- solace.com\n- tibco.com\n- worldpay.com\n\nSome of these companies sponsored our work in 2020. The ones that didn't... don't worry, we'll contact you :wink: In 2021, we want to go into a neutral ground (i.e., joining a foundation). There'll be no more excuses.\n\n### What's next with Slack\n\nSlack hard numbers confirm what we see in Slack every day. Luckily, even though the activity doubled, the number of active users that help out in the workspace also grew :pray: With the recently announced Postman partnership, I do not worry about how we'll handle 2021.\n\nNext year we need to address two critical topics:\n- our community grows but the knowledge that we all share in Slack is lost. We use a free version of Slack, and therefore, only the last 10k messages are available. In 2021, we need to make a strong decision on what's next. Should we spend some budget on Slack commercial subscriptions, or maybe we should find a better tool?\n- we need to reorganize our channels, be a bit more granular, and target suitable community groups. We'll bother you to get your feedback once we start this reorganization.\n\n## LinkedIn\n\n[LinkedIn](https://www.linkedin.com/company/asyncapi/) grew a lot this year. We won't be able to compare this year with the previous one because... this is not a place where I want to discuss the experience you get with LinkedIn.\n\n### Followers and impressions\n\nAt the moment, we have 757 followers.\n\n<table>\n  <tr>\n    <td align=\"center\">\n      Followers\n    </td>\n    <td align=\"center\">\n      Likes\n    </td>\n    <td align=\"center\">\n      Impressions\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      611<br/>\n      57 from payed marketing\n    </td>\n    <td align=\"center\">\n      1253\n    </td>\n    <td align=\"center\">\n      80095\n    </td>\n  </tr>\n</table>\n\nPeople that like our updates are most likely the ones that click on links. 75% (947) of likes converted into visits to our [website](http://asyncapi.com/). We took this data from Google Analytics, and we know that in 2019 we had only 137 visits from LinkedIn.\n\nThe most performing update was the one about the [partnership with Postman](https://www.linkedin.com/feed/update/urn:li:activity:6742099578591481856). It is LinkedIn, and it is all about business.\n\nThe chart below shows that data match reality. The highest peak in late March is related to our first [AsyncAPI Online Conference](https://www.youtube.com/watch?v=oMSzGc5bDr4). The rise of sponsored traffic is connected to our post-conference activities using the money we got from conference sponsors.\n\n<Figure\n  src=\"/img/posts/2020-summary/linkedin-impressions.webp\"\n  caption=\"Figure 2: Impressions to updates in 2020\"\n/>\n\n### Sponsored marketing\n\nThis year we explored paid adverts on LinkedIn. We had some money left from sponsors of our AsyncAPI conference but zero experience with LinkedIn.\n\nLuckily, we have a fantastic community. One of the community members, [Dan Weese](https://www.linkedin.com/in/daniel-weese-53b27410/), helped us here. He did not only put us in contact with marketing expert, [Charles Serdou](https://www.linkedin.com/in/sardou/) but also covered his wages. Thank you, Dan :pray:\n\nThis way, we covered only LinkedIn costs paying $1 074,08\n\n<Figure\n  src=\"/img/posts/2020-summary/linkedin-folowers.webp\"\n  caption=\"Figure 3: Followers growth in 2020\"\n/>\n\nMarketing was focused on increasing the number of followers. Comparing the results of sponsored marketing with followers' organic growth, one could say LinkedIn marketing was not so good. It was very good though. LinkedIn is just super expensive and charged a lot for every new follower.\n\nWe should give it a second chance in 2021, but this time with sponsored updates.\n\n### What's next with LinkedIn\n\nThe numbers show it is worth investing in the channel. We can reach a lot of people that are not reachable on other channels. So we will for sure continue what we do now, especially that this work doesn't require too much extra effort from us.\n\nI feel that probably some traffic coming from LinkedIn to our website is not adequately tracked in Google Analytics. Data from LinkedIn say we should notice 2x947 traffic. It might be related to people blocking tracking tools, and we will have to make sure to use other tracking methods, like putting identifiers in the links.\n\n## Google Analytics\n\nWe use Google Analytics on [AsyncAPI website](https://www.asyncapi.com/) because we want to understand what content is most valuable for you, and we want to learn how the interest is growing. \n\n### Traffic got much higher\n\nThe interest is growing by a lot! Our website handles it well with the support of [Netlify](https://www.netlify.com), which is free for open-source projects.\n\n<table>\n  <tr>\n    <td align=\"center\">\n    </td>\n    <td align=\"center\">\n      2019\n    </td>\n    <td align=\"center\">\n      2020\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Unique users visits\n    </td>\n    <td align=\"center\">\n      27 090\n    </td>\n    <td align=\"center\">\n      80 399<br/>\n      (+53 309)\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Number of sessions\n    </td>\n    <td align=\"center\">\n      50 405\n    </td>\n    <td align=\"center\">\n      142 229<br/>\n      (+91 824)\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Unique pageviews\n    </td>\n    <td align=\"center\">\n      143 059\n    </td>\n    <td align=\"center\">\n      348 131<br/>\n      (+205 172)\n    </td>\n  </tr>\n</table>\n\n### Top referring channels\n\nIf we look closer to the statistics to check out how people learn about AsyncAPI, referral channels keep pretty much the same share of the pie, just numbers grow.\n\n<Figure\n  src=\"/img/posts/2020-summary/top-channel-2019.webp\"\n  caption=\"Figure 4: Top channels in 2019\"\n/>\n\n<Figure\n  src=\"/img/posts/2020-summary/top-channel-2020.webp\"\n  caption=\"Figure 5: Top channels in 2020\"\n/>\n\nIn 2019, the most viral was the information about AsyncAPI 2.0 release, while in 2020, the blog post about how we [automated releases](/blog/automated-releases) on AsyncAPI packages to speed up work. \n\n### Top blog posts\n\n[AsyncAPI blog](/blog) is not just for Fran and me. It is for the AsyncAPI Community. Anyone can share knowledge, experience, and showcase their work there. Just [let us](https://github.com/asyncapi/website/issues/new?template=blog.md) know what you want to write about.\n\nWhat is the benefit of writing/republishing on the AsyncAPI blog? Visibility among the AsyncAPI community plus our activities to make your work go viral. Just look at the below table to see our top 3 viral posts.\n\n<table>\n  <tr>\n    <td align=\"center\">\n      Post\n    </td>\n    <td align=\"center\">\n      Unique pageviews\n    </td>\n    <td align=\"center\">\n      Author\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <Link href=\"/blog/automated-releases\" passHref><a>\n      Full automation of release to NPM and Docker Hub with GitHub Actions and Conventional Commits\n      </a></Link> (March 2020)\n    </td>\n    <td align=\"center\">\n      9 318\n    </td>\n    <td align=\"center\">\n      <a href=\"https://twitter.com/derberq\">\n      Lukasz Gornicki\n      </a>\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n    <Link href=\"/blog/asyncapi_codegen_scst\" passHref>\n      <a>\n      AsyncAPI Code Generation: Microservices Using Spring Cloud Stream\n      </a></Link> (June 2020)\n    </td>\n    <td align=\"center\">\n      8 508\n    </td>\n    <td align=\"center\">\n      <a href=\"https://twitter.com/Mrc0113\">\n      Marc DiPasquale\n      </a>\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n    <Link href=\"/blog/an-api-strategist-explores-event-driven-apis\" passHref>\n      <a>\n      An API Strategist Explores Event-Driven APIs\n      </a></Link> (May 2019)\n    </td>\n    <td align=\"center\">\n      3 451\n    </td>\n    <td align=\"center\">\n      <a href=\"https://twitter.com/lifewingmate\">\n      Emmelyn Wang\n      </a>\n    </td>\n  </tr>\n</table>\n\n### What's next with the website\n\nWe need to enable Google Search Console and connect with our Google Analytics account. It will increase our knowledge about how people google before they get into the AsyncAPI website. Knowing how people find us, we can focus on more content related to search queries.\n\nWe need more posts on our blog. 2020 shows this is something that increases traffic. We already welcomed many guest bloggers, and you [can become](https://github.com/asyncapi/website/issues/new?template=blog.md) one of our writers too.\n\n## Twitter\n\nBy the time I gathered data for this blog post, we had 1433 followers on Twitter. 876 followers joined us in 2020. It is a large increase since the account creation back in March 2019.\n\n### Paid marketing\n\nWe used money from our AsyncAPI conference sponsors to advertise the conference on Twitter.\n\nWe spent $924,14 on this activity and when we compare it to organic impressions over this year, result is just great:\n\n<table>\n  <tr>\n    <td align=\"center\">\n    </td>\n    <td align=\"center\">\n      Organic (549 tweets)\n    </td>\n    <td align=\"center\">\n      Promoted (3! tweets)\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Impressions\n    </td>\n    <td align=\"center\">\n      570 466\n    </td>\n    <td align=\"center\">\n      525 329\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Retweets\n    </td>\n    <td align=\"center\">\n      1 429\n    </td>\n    <td align=\"center\">\n      77\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Likes\n    </td>\n    <td align=\"center\">\n      2 507\n    </td>\n    <td align=\"center\">\n      567\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      URLs clicks\n    </td>\n    <td align=\"center\">\n      2 759\n    </td>\n    <td align=\"center\">\n      2 283\n    </td>\n  </tr>\n    <tr>\n    <td align=\"center\">\n      Follows\n    </td>\n    <td align=\"center\">\n      4\n    </td>\n    <td align=\"center\">\n      35\n    </td>\n  </tr>\n</table>\n\nNothing is black and white, even Twitter performance. One could say:\n\n> leave organic growth and invest in paid marketing \n\nWe do not treat Twitter as just a marketing channel. It is our window to the community. We use it to share updates, short information and engage directly with our community members. We should continue to work on organic growth. It converted only into 2 160 sessions to the AsyncAPI website, which is not much if we compare it with 2 283 sessions opened with the AsyncAPI Conference website using promoted content. We do not want to close the window, though.\n\nIt's all about keeping the balance :balance_scale:\n\n### Top tweets\n\nWe did some research on the most impressive and engaging tweets.\n\n<table>\n  <tr>\n    <td align=\"center\">\n      Tweet\n    </td>\n    <td align=\"center\">\n      Impressions\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <TwitterTweetEmbed\n        tweetId='1221873851031859200' \n        options={{\n          cards: 'hidden',\n          width: 200,\n          maxWidth: 400\n        }}\n      />\n    </td>\n    <td align=\"center\" className=\"font-bold\">\n      15k\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <TwitterTweetEmbed\n        tweetId='1332276932998799361'\n        options={{\n          cards: 'hidden',\n          width: 200,\n          maxWidth: 400\n        }}\n      />\n    </td>\n    <td align=\"center\" className=\"font-bold\">\n      14k\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <TwitterTweetEmbed\n        tweetId='1336234096524021760'\n        options={{\n          cards: 'hidden',\n          width: 200,\n          maxWidth: 400\n        }}\n      />\n    </td>\n    <td align=\"center\" className=\"font-bold\">\n      9k\n    </td>\n  </tr>\n</table>\n\nThere is only one tweet that shows up in the top 3 for each category.\n\n<table>\n  <tr>\n    <td align=\"center\">\n      Tweet\n    </td>\n    <td align=\"center\">\n      Engagements\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <TwitterTweetEmbed\n        tweetId='1332276932998799361' \n        options={{\n          cards: 'hidden',\n          width: 200,\n          maxWidth: 400\n        }}\n      />\n    </td>\n    <td align=\"center\" className=\"font-bold\">\n      428\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <TwitterTweetEmbed\n        tweetId='1336337910409220100'\n        options={{\n          cards: 'hidden',\n          width: 200,\n          maxWidth: 400\n        }}\n      />\n    </td>\n    <td align=\"center\" className=\"font-bold\">\n      259\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <TwitterTweetEmbed\n        tweetId='1278614358617198592'\n        options={{\n          width: 200,\n          maxWidth: 400\n        }}\n      />\n    </td>\n    <td align=\"center\">\n      <div className=\"font-bold\">\n        253 \n      </div>\n      (not all those memes were lame after all)\n    </td>\n  </tr>\n</table>\n\nIt is pretty clear that what you liked the most this year is that we are hiring :muscle: \n\nWe are still hiring!\n\n<NewsletterSubscribe className=\"my-8\" formName=\"form 1\" type=\"jobs\" title=\"Receive an email when we publish a new job offer:\" />\n\n### What's next with Twitter\n\nWe should get more insights into how Twitter activity converts into visits to our website. Twitter offers something called **conversion tracking** which seems like a perfect fit, and this is something we will enable for next year.\n\nPaid marketing on Twitter is useful, so we will continue using it for important events.\n\n## GitHub\n\nWe notice growing traffic in [our GitHub organization](https://github.com/asyncapi) like on other channels.\n\n### Most popular repositories\n\nOur most popular repositories contain the AsyncAPI specification and the AsyncAPI Generator that the community can use to generate documentation and code.\n\n[The asyncapi repository](https://github.com/asyncapi/asyncapi/) that had 245 stars in 2019 jumped to 1361. The peak you see on the diagram was caused by us putting the link to the asyncapi repository on [Hacker News](https://news.ycombinator.com/item?id=22728257).\n\n<Figure\n  src=\"/img/posts/2020-summary/star-history-asyncapi.webp\"\n  caption=\"Figure 6: GitHub stars growth in asyncapi repository\"\n/>\n\n[The generator repository](https://github.com/asyncapi/generator/) grew from 62 to 198. The path got steeper this year. This popularity is covered with our recent development activities in the project. \n\n<Figure\n  src=\"/img/posts/2020-summary/star-history-generator.webp\"\n  caption=\"Figure 7: GitHub stars growth in generator repository\"\n/>\n\n### Traffic growth\n\nAll numbers went up :sweat_smile:\n\nThe growth of contributors was not organic but driven by our activities in the [Hacktoberfest](/blog/hacktoberfest-summary-2020) event.\n\n<table>\n  <tr>\n    <td align=\"center\">\n    </td>\n    <td align=\"center\">\n      2019\n    </td>\n    <td align=\"center\">\n      2020\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Contributors\n    </td>\n    <td align=\"center\">\n      76\n    </td>\n    <td align=\"center\">\n      119\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Commits\n    </td>\n    <td align=\"center\">\n      1.5k\n    </td>\n    <td align=\"center\">\n      3.5k\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Pull requests (opened/closed)\n    </td>\n    <td align=\"center\">\n      399/397<br/>99% closed\n    </td>\n    <td align=\"center\">\n      1200/1175<br/>97% closed\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Issues (opened/closed)\n    </td>\n    <td align=\"center\">\n      322/287<br/>89% closed\n    </td>\n    <td align=\"center\">\n      587/401<br/>68% closed\n    </td>\n  </tr>\n</table>\n\nWe're closing fewer issues. This number got worse than last year because we freeze progress on the asyncapi repository, and the last few months did not continue any efforts towards specification 2.1 and 3.0 releases. The reason was pretty simple; we were involved in discussions with many players and planning the next step forward to scale up in 2021. It would not be fair with the AsyncAPI community to work on the next specification versions, with the current government process, knowing we prepare [partnership with Postman](/blog/asyncapi-partners-with-postman).\n\n### What's next with GitHub\n\nWe are doing well on GitHub, and so far, I don't see any improvements other than the further automation that we have in plans to handle even more traffic next year.\n\n## npm\n\nThe majority of our tools are written in JavaScript/TypeScript, and we host them on Node Package Manager(npm)\n\n### Top packages\n\nOur most important packages are [the Generator](https://www.npmjs.com/package/@asyncapi/generator) and [the Parser](https://www.npmjs.com/package/@asyncapi/parser). Below you can see how downloads of these packages increased.\n\n<table>\n  <tr>\n    <td align=\"center\">\n    </td>\n    <td align=\"center\">\n      2019\n    </td>\n    <td align=\"center\">\n      2020\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Generator\n    </td>\n    <td align=\"center\">\n      21 536\n    </td>\n    <td align=\"center\">\n      134 224\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Parser (published May 2019)\n    </td>\n    <td align=\"center\">\n      18 591\n    </td>\n    <td align=\"center\">\n      173 286\n    </td>\n  </tr>\n</table>\n\nThe change in numbers is so huge that I checked them twice to make sure I'm not wrong.\n\n<Figure\n  src=\"/img/posts/2020-summary/npm.webp\"\n  widthClass=\"w-6/12\"\n  caption=\"Figure 8: Popularity of all packages on npm\"\n/>\n\nIf you know the package from the above list had some different names over the year, you can check it with [npm stat](https://npm-stat.com) project. For example, late in the year, we moved the React component under **@asyncapi**, and under the old name, it had 56 520 downloads. Next year won't be so messy.\n\n### What's next with npm\n\nThis year we introduced **@asyncapi** scope on npm and switched all packages to it. You could see some differences in numbers in previous sections because for the generator and parser I manually counted the sum of downloads of a package under different names.\n\nThere are still many downloads of the parser and generator using old names. It means we still have many people that do not migrate to new releases. Next year we could write a blog post that summarizes the differences between old tools and their latest versions. It could be linked to the deprecation notice.\n\n## YouTube\n\nThe [AsyncAPI YouTube channel](https://www.youtube.com/asyncapi) had a massive increase in the traffic. \n\n### Watch time goes crazy\n\nWe felt it might be significant because of the AsyncAPI conference, but we never expected a 6000% growth of the watch time!\n\n<table>\n  <tr>\n    <td align=\"center\">\n    </td>\n    <td align=\"center\">\n      2019\n    </td>\n    <td align=\"center\">\n      2020\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Views\n    </td>\n    <td align=\"center\">\n      527\n    </td>\n    <td align=\"center\">\n      8 678\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      Watch time\n    </td>\n    <td align=\"center\">\n      29.9h\n    </td>\n    <td align=\"center\">\n      1 850.1h\n    </td>\n  </tr>\n    <tr>\n    <td align=\"center\">\n      Subscribers\n    </td>\n    <td align=\"center\">\n      35\n    </td>\n    <td align=\"center\">\n      390\n    </td>\n  </tr>\n</table>\n\n### Most popular videos\n\nUndeniably the most popular this year was our first AsyncAPI online conference.\n\n<table>\n  <tr>\n    <td align=\"center\">\n    </td>\n    <td align=\"center\">\n      Views\n    </td>\n    <td align=\"center\">\n      Author\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://youtu.be/oMSzGc5bDr4\">\n        AsyncAPI Online Conference\n      </a>\n    </td>\n    <td align=\"center\">\n      4 123\n    </td>\n    <td align=\"center\">\n      AsyncAPI Community\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://youtu.be/Q5ZdPUzYbmc\">\n        AsyncAPI SIG meeting 37 (December 8, 2020) - SPECIAL EDITION!\n      </a>\n    </td>\n    <td align=\"center\">\n      542\n    </td>\n    <td align=\"center\">\n      AsyncAPI Community\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://youtu.be/XJCCexjV4Ao\">\n        Event-Based API Patterns and Practices\n      </a>\n    </td>\n    <td align=\"center\">\n      354\n    </td>\n    <td align=\"center\">\n      <a href=\"https://twitter.com/launchany\">\n        James Higginbotham\n      </a>\n    </td>\n  </tr>\n</table>\n\nIn case you missed our conference, watch the recording and stay tuned for the next conference in 2021.\n\n<YouTube id=\"oMSzGc5bDr4\" />\n\n### What's next with YouTube\n\nI think it is the right moment to work on the channels' landing page. We could use it to promote the most valuable content.\n\n## Open Collective\n\nWe earned and spent lots of money this year :money_mouth_face:\n\nHuge applause :clap: to all [our sponsors](https://opencollective.com/asyncapi#section-contributors)! \n\nWe enabled the [GitHub sponsoring](https://github.com/sponsors/asyncapi) this year, but still, 99% of funds go through the [Open Collective](https://opencollective.com/asyncapi).\n\n<table>\n  <tr>\n    <td align=\"center\">\n      Source\n    </td>\n    <td align=\"center\">\n      Amount\n    </td>\n    <td align=\"center\">\n      Balance\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://opencollective.com/asyncapi/events/asyncapi-online-conference-fd574661\">\n        AsyncAPI Online Conference\n      </a>\n    </td>\n    <td align=\"left\">\n      $983 Swags for participants<br/>\n      $359,10 <a href=\"https://www.womenwhocode.com/\">WWC donation</a><br/>\n      $1 074,08 LinkedIn marketing<br/>\n      $924,14 Twitter marketing<br/>\n      $66,54 Zoom account<br/>\n    </td>\n    <td align=\"center\">\n      $0\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://opencollective.com/asyncapi\">\n        AsyncAPI Initiative\n      </a>\n    </td>\n    <td align=\"center\">\n      $52 371 Maintanance<br/>\n      $3 750 <a href=\"https://opencollective.com/json-schema\">\n        JSON Schema\n      </a> \n    </td>\n    <td>\n      $1 493,64\n    </td>\n  </tr>\n</table>\n\nIn 2021 we continue using Open Collective. Even though we started [partnership with Postman](/blog/asyncapi-partners-with-postman) to cover many maintenance costs, there are other costs. Even once we join some foundation next year, we still need to collect money to run the project.\n\n## Ultimate questions - how many people use the spec?\n\nWe don't know.\n\nIt is the area where we have no specific metrics. We see the growth in tools' adoption, but not everybody uses open source tools. Many companies prefer to develop those in-house.\n\nFrom observations, we know that number of users that use specification grows:\n- More and more companies seek integration with the specification. From unofficial discussions, we know their customers ask them about AsyncAPI support\n- The metrics from this blog post clearly show adoption and interest growth\n\nIt is a specification we are talking about here. There is no way to measure how many AsyncAPI files were created worldwide. At least there was no way to do it in 2020. We'll try [one idea](https://github.com/asyncapi/asyncapi/issues/377#issuecomment-626755982) of ours in 2021. It looks like in the 2021 summary, we could provide some hard numbers on the subject :crossed_fingers:\n\n## Final words\n\nMost important conclusion: If the AsyncAPI conference brought so much activity, it is evident that in 2021 we must organize another great AsyncAPI event.\n\nThanks for being with us in 2020, and stay with us for 2021 as it will be epic!\n\nI planned to include a list of all the AsyncAPI Heroes for 2020, but I was afraid I could miss someone very important and that the list would be very subjective. I hope it is clear, though, that this project is where it is, thanks to many guardian angels out there that help us out.\n\n> Photo by <a href=\"https://unsplash.com/@macroman?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Immo Wegmann</a> on <a href=\"https://unsplash.com/s/photos/2020-summary?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "Important moments",
        "slug": "important-moments",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Slack",
        "slug": "slack",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Numbers getting high",
        "slug": "numbers-getting-high",
        "lvl": 3,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Most present companies",
        "slug": "most-present-companies",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "What's next with Slack",
        "slug": "whats-next-with-slack",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "LinkedIn",
        "slug": "linkedin",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Followers and impressions",
        "slug": "followers-and-impressions",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Sponsored marketing",
        "slug": "sponsored-marketing",
        "lvl": 3,
        "i": 7,
        "seen": 0
      },
      {
        "content": "What's next with LinkedIn",
        "slug": "whats-next-with-linkedin",
        "lvl": 3,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Google Analytics",
        "slug": "google-analytics",
        "lvl": 2,
        "i": 9,
        "seen": 0
      },
      {
        "content": "Traffic got much higher",
        "slug": "traffic-got-much-higher",
        "lvl": 3,
        "i": 10,
        "seen": 0
      },
      {
        "content": "Top referring channels",
        "slug": "top-referring-channels",
        "lvl": 3,
        "i": 11,
        "seen": 0
      },
      {
        "content": "Top blog posts",
        "slug": "top-blog-posts",
        "lvl": 3,
        "i": 12,
        "seen": 0
      },
      {
        "content": "What's next with the website",
        "slug": "whats-next-with-the-website",
        "lvl": 3,
        "i": 13,
        "seen": 0
      },
      {
        "content": "Twitter",
        "slug": "twitter",
        "lvl": 2,
        "i": 14,
        "seen": 0
      },
      {
        "content": "Paid marketing",
        "slug": "paid-marketing",
        "lvl": 3,
        "i": 15,
        "seen": 0
      },
      {
        "content": "Top tweets",
        "slug": "top-tweets",
        "lvl": 3,
        "i": 16,
        "seen": 0
      },
      {
        "content": "What's next with Twitter",
        "slug": "whats-next-with-twitter",
        "lvl": 3,
        "i": 17,
        "seen": 0
      },
      {
        "content": "GitHub",
        "slug": "github",
        "lvl": 2,
        "i": 18,
        "seen": 0
      },
      {
        "content": "Most popular repositories",
        "slug": "most-popular-repositories",
        "lvl": 3,
        "i": 19,
        "seen": 0
      },
      {
        "content": "Traffic growth",
        "slug": "traffic-growth",
        "lvl": 3,
        "i": 20,
        "seen": 0
      },
      {
        "content": "What's next with GitHub",
        "slug": "whats-next-with-github",
        "lvl": 3,
        "i": 21,
        "seen": 0
      },
      {
        "content": "npm",
        "slug": "npm",
        "lvl": 2,
        "i": 22,
        "seen": 0
      },
      {
        "content": "Top packages",
        "slug": "top-packages",
        "lvl": 3,
        "i": 23,
        "seen": 0
      },
      {
        "content": "What's next with npm",
        "slug": "whats-next-with-npm",
        "lvl": 3,
        "i": 24,
        "seen": 0
      },
      {
        "content": "YouTube",
        "slug": "youtube",
        "lvl": 2,
        "i": 25,
        "seen": 0
      },
      {
        "content": "Watch time goes crazy",
        "slug": "watch-time-goes-crazy",
        "lvl": 3,
        "i": 26,
        "seen": 0
      },
      {
        "content": "Most popular videos",
        "slug": "most-popular-videos",
        "lvl": 3,
        "i": 27,
        "seen": 0
      },
      {
        "content": "What's next with YouTube",
        "slug": "whats-next-with-youtube",
        "lvl": 3,
        "i": 28,
        "seen": 0
      },
      {
        "content": "Open Collective",
        "slug": "open-collective",
        "lvl": 2,
        "i": 29,
        "seen": 0
      },
      {
        "content": "Ultimate questions - how many people use the spec?",
        "slug": "ultimate-questions---how-many-people-use-the-spec",
        "lvl": 2,
        "i": 30,
        "seen": 0
      },
      {
        "content": "Final words",
        "slug": "final-words",
        "lvl": 2,
        "i": 31,
        "seen": 0
      }
    ],
    "slug": "/blog/2020-summary",
    "filePath": "pages/blog/2020-summary.md"
  },
  {
    "meta": {
      "title": "AsyncAPI partners with Postman to boost development of Asynchronous APIs",
      "date": "2020-12-08T16:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Partnership",
        "Announcement"
      ],
      "cover": "/img/posts/asyncapi-partners-with-postman.webp",
      "authors": [
        {
          "name": "Fran Méndez",
          "photo": "/img/avatars/fmvilas.webp",
          "link": "https://twitter.com/fmvilas",
          "byline": "AsyncAPI Founder"
        }
      ],
      "excerpt": "I'm proud and honored to let you know that we're partnering with Postman to boost the development of Asynchronous APIs to a new level.",
      "readingTime": 3
    },
    "content": "\nI'm proud and honored to let you know that we're partnering with [Postman](https://www.postman.com) to boost the development of Asynchronous APIs to a new level :rocket:\n\nSince the very beginning, I knew the duty we had at hand was challenging. And still is! The specification was just the trigger of a snowball effect. What's the spec for if you can't do anything with it? Tooling is as important as the specification. However, tooling is a number of times more complex than the specification. We engineers don't want to abandon our favorite programming language and framework, therefore, it's AsyncAPI's responsibility to integrate with the existing tools in the market. **The specification (and tools) should work for the user, not the other way around.** Partnering with Postman allows us to boost the development of more and better tools to help engineers create and maintain Asynchronous APIs while using their favorite programming languages and frameworks.\n\n**Our goal is to make Asynchronous APIs as successful and mature as REST APIs.** We are aware this is a long journey but, with Postman's help, we'll be able to grow the team and continue working on the AsyncAPI specification and all the necessary tools to create a delightful developer experience. The AsyncAPI Initiative team is fully committed to open source software (OSS), and the partnership with Postman will help us keep doing our job with freedom and independence.\n\n## Next steps\n\nWe want to make the AsyncAPI Initiative a neutral and independent place for collaborating on defining the future of Asynchronous APIs. Next step for us is to host the project in a neutral foundation to guarantee the long-term success of the initiative. We're currently in conversations with different actors of the OSS world to make sure the initiative remains independent.\n\nAlso, we want you to work with us. [We are hiring](/jobs) at Postman to work full-time on AsyncAPI. In the first half of 2021, we'll open a bunch of positions, including Software Engineers, Graphic Designers, Technical Writers, and more. Make sure you don't miss them!\n\n<NewsletterSubscribe className=\"my-8\" formName=\"form 1\" type=\"jobs\" title=\"Receive an email when we publish a new job offer:\" />\n\nBefore I finish, I would love to thank [Kin Lane](https://twitter.com/kinlane/) and [Abhinav Asthana](https://twitter.com/a85) for being so supportive. And of course, a huge shout out to [Łukasz Gornicki](https://twitter.com/derberq) and [Eva Morcillo](https://twitter.com/e_morcillo) for their tireless support. None of these would be possible without their help.\n\nThere's a bright future ahead for Asynchronous APIs. 2021 will be the year of AsyncAPI, the year of you, our beloved open-source community.\n\nCheers! :beers:",
    "toc": [
      {
        "content": "Next steps",
        "slug": "next-steps",
        "lvl": 2,
        "i": 0,
        "seen": 0
      }
    ],
    "slug": "/blog/asyncapi-partners-with-postman",
    "filePath": "pages/blog/asyncapi-partners-with-postman.md"
  },
  {
    "meta": {
      "title": "Happy Birthday AsyncAPI (week 47, 2020)",
      "date": "2020-11-18T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/status-update-47/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "readingTime": 5,
      "excerpt": "Happy Birthday AsyncAPI\nOn 18.11.2017 Fran Mendez exclaimed &ampquot;Eureka” and created AsyncAPI. The story is more complicated than that, but it is not a time for a history lesson, so let us keep it"
    },
    "content": "\n## Happy Birthday AsyncAPI\n\nOn 18.11.2017 Fran Mendez exclaimed \"Eureka” and created AsyncAPI. The story is more complicated than that, but it is not a time for a history lesson, so let us keep it simple :smile:\n\nYes, AsyncAPI is 3 years old :beers:\n\nThis is what [they](https://raisingchildren.net.au/babies/development/development-tracker-3-12-months/3-4-months) say about kids at age 3:\n\n> Around this age, your baby loves to move and will probably start rolling from tummy to back. When you give him tummy time, he might lift his head high or push up on his hands. He might even sit up with some support behind and on each side of his body.\n\nThat is about it. We do not want to just sit, relax, and enjoy lunch anymore. ** It's time for us to start moving, exploring, and not stopping but making a stand in the industry**. We have great years ahead of us. Trust me. Soon you'll learn that work on AsyncAPI will lift off to another level.\n\n<img src=\"https://media.giphy.com/media/Xw6yFn7frR3Y4/giphy.gif\" />\n\nJoin us during these strange pandemic times in asynchronous remote celebration, whenever and wherever you can.\n\n## Generator 1.0 And Other Goodies\n\nFollowing the recent [1.0 release of the AsyncAPI Parser](https://www.asyncapi.com/blog/status-update-43-20) we came to the point we could release the first major release of [the AsyncAPI Generator](https://github.com/asyncapi/generator/) too. \n\nFeel free to congratulate us by giving a :star: to [the project](https://github.com/asyncapi/generator/stargazers). This is the moment to join us and think with us about the 2.0 release and all the goodies we can add to it.\n\nTry out the project by following :point_down: instructions:\n<GeneratorInstallation />\n\n### Generator GitHub Action 1.0\n\nYes, our official [GitHub Action for Generator](https://github.com/marketplace/actions/generator-for-asyncapi-documents) already uses the latest Generator and is released under v1. \n\n```yaml\n- name: Generating HTML from my AsyncAPI document\n  uses: asyncapi/github-action-for-generator@v1\n  with:\n    template: '@asyncapi/html-template@0.15.4'  #In case of template from npm, because of @ it must be in quotes\n    filepath: docs/api/my-asyncapi.yml\n    parameters: baseHref=/test-experiment/ sidebarOrganization=byTags #space separated list of key/values\n    output: generated-html\n```\n\n[The AsyncAPI Playground](https://playground.asyncapi.io/) is up to date with the latest generator. \n\n### Writing Own Generator Template Ain't Easy\n\nWriting a template compatible with the AsyncAPI Generator is not an easy task that you can complete in one day. To write a template that generates docs or code, you need to have not only decent knowledge about AsyncAPI specification but also the features of the Generator:\n\n- How do I extract data from the spec file?\n- What template engine powers Generator and how to use it?\n- How can I add optional features to the template?\n\nThere is a lot of it. We wanted to make it easy for you. We created a [GitHub Template](https://github.com/asyncapi/template-for-generator-templates) that showcases all features available in the Generator. It contains:\n- A template that generates class diagram showing relations between schemas\n- Detailed readme which explains all the features and where are they used in the template\n\nTo try out the template, run :point_down: commands:\n```\n# Install the AsyncAPI Generator if you do not have it yet\nnpm install -g @asyncapi/generator\n\n# Run generation\nag https://raw.githubusercontent.com/asyncapi/generator/v1.0.1/test/docs/dummy.yml https://github.com/asyncapi/template-for-generator-templates -o output\n\n# Open the result of the generation\nopen output/index.html\n```\n\n<Figure\n  src=\"/img/posts/status-update-47/diagram.webp\"\n  caption=\"Figure 1: Schema consumed by the template and the resulting diagram\"\n/>\n\n## React Component and Web Component\n\n### New Npm Scope\n\nSince the 0.16.2 release, we changed the npm scope of the component and now use the official **asyncapi** one. That means you should update your dependencies and from now on use **@asyncapi/react-component**.\n\n[![Edit asyncapi-react-component-in-action](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/asyncapi-react-component-in-action-wvdy2)\n\n### Web Component\n\nSince the 0.17.5 release, we are now automatically publishing also the @asyncapi/web-component to npm. Given that it depends on the React component, it will always follow the same version number. This is all possible thanks to work done by amazing [Hesyar Uzuner](https://github.com/hesyar), [Claude Gex](https://github.com/gexclaude), [Maciej Urbańczyk](https://github.com/magicmatatjahu).\n\nNow it should be easier for you to use this component in non-React projects. That is, for example, how you would use it in a plain HTML:\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>AsyncAPI Web Component Demo</title>\n    <script src=\"https://unpkg.com/@asyncapi/web-component@0.17.5/lib/asyncapi-web-component.js\" defer></script>\n    <script>\n        var schema = {\n            url: \"https://raw.githubusercontent.com/asyncapi/asyncapi/master/examples/2.0.0/simple.yml\"\n        };\n\n        window.onload = function() {\n            document.getElementById(\"asyncapi\").schema = schema;\n        }\n    </script>\n</head>\n\n<body>\n\n    <asyncapi-component id=\"asyncapi\" cssImportPath=\"https://unpkg.com/@asyncapi/react-component@0.17.5/lib/styles/fiori.css\"></asyncapi-component>\n\n</body>\n\n</html>\n```\n\nThere is also a sample project where you can see how this Web component plays together with Angular.\n\n[![Edit asyncapi-web-component-in-action](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/asyncapi-web-component-in-action-l652x)\n\nWe already have [some ideas](https://github.com/asyncapi/asyncapi-react/issues/191) on how to improve DX for the component. Try it on your own and let us know what you think.\n\n### Examples Rendering\n\nSince the 0.16.0 release, the component supports examples provided in the AsyncAPI document on a Message Object level. These examples are treated with priority over others. You can try it out in [the React component playground](https://asyncapi.github.io/asyncapi-react/).\n\n<Figure\n  src=\"/img/posts/status-update-47/react-playground.webp\"\n  caption=\"Figure 2: View of the AsyncAPI React playground where you can see sample AsyncAPI document with example in Message Object, and how the React component renders it.\"\n/>\n\n## AsyncAPI Special Interest Group (SIG) open meeting\n\nThe last meeting took place on Tuesday, 10th of November, 4PM UTC. Meeting notes and recording are available [here](https://github.com/asyncapi/asyncapi/issues/459).\n\nThe next meeting is scheduled for next [Tuesday, 24th of November, 8AM UTC](https://everytimezone.com/s/2088528d). \n\nWe work on the agenda for the next meeting [here](https://github.com/asyncapi/asyncapi/issues/462). At the moment, there is nothing on the agenda, so you can easily sneak your topic in. \n\nWe host the meeting on [Zoom](https://zoom.us/j/165106914). Do not forget about future meetings and always have up to date invitations in your calendar by adding your email to [this](https://groups.google.com/forum/#!forum/asyncapi-users) mailing list.\n\n## Some Good Read Resources\n\n- [What Is AsyncAPI and How Does It Differ from OpenAPI](https://ergonotes.com/what-is-asyncapi-and-how-does-it-differ-from-openapi/)\n- [How Microcks Can Speed-Up Your AsyncAPI Adoption - Part 1](https://www.asyncapi.com/blog/microcks-asyncapi-part1) by [Laurent Broudoux](https://twitter.com/lbroudoux)\n- [Is Hacktoberfest Good For Maintainers?](https://www.asyncapi.com/blog/hacktoberfest-summary-2020) by [Lukasz Gornicki](https://twitter.com/derberq)\n\n> Cover photo by <a href=\"https://unsplash.com/@will_myers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Will Myers</a> on <a href=\"https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "Happy Birthday AsyncAPI",
        "slug": "happy-birthday-asyncapi",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Generator 1.0 And Other Goodies",
        "slug": "generator-10-and-other-goodies",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Generator GitHub Action 1.0",
        "slug": "generator-github-action-10",
        "lvl": 3,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Writing Own Generator Template Ain't Easy",
        "slug": "writing-own-generator-template-aint-easy",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "React Component and Web Component",
        "slug": "react-component-and-web-component",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "New Npm Scope",
        "slug": "new-npm-scope",
        "lvl": 3,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Web Component",
        "slug": "web-component",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Examples Rendering",
        "slug": "examples-rendering",
        "lvl": 3,
        "i": 7,
        "seen": 0
      },
      {
        "content": "AsyncAPI Special Interest Group (SIG) open meeting",
        "slug": "asyncapi-special-interest-group-sig-open-meeting",
        "lvl": 2,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Some Good Read Resources",
        "slug": "some-good-read-resources",
        "lvl": 2,
        "i": 9,
        "seen": 0
      }
    ],
    "slug": "/blog/status-update-47-20",
    "filePath": "pages/blog/status-update-47-20.md"
  },
  {
    "meta": {
      "title": "How Microcks Can Speed-Up Your AsyncAPI Adoption - Part 1",
      "date": "2020-11-11T18:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "Testing"
      ],
      "cover": "/img/posts/microcks-asyncapi-part1/microcks-1.0.0-loves-asyncapi.webp",
      "authors": [
        {
          "name": "Laurent Broudoux",
          "photo": "/img/avatars/lbroudoux.webp",
          "link": "https://twitter.com/lbroudoux",
          "byline": "Microcks.io Founder"
        }
      ],
      "readingTime": 3,
      "excerpt": "August 11th 2020 was the official announcement of Microcks 1.0.0 release and our first Microcks General Availability (GA) version to fully manage event-driven API through the support of AsyncAPI speci"
    },
    "content": "\nAugust 11th 2020 was the official announcement of [Microcks 1.0.0](https://microcks.io/blog/microcks-1.0.0-release/) release and our first Microcks General Availability (GA) version to fully manage event-driven API through the support of [AsyncAPI](https://www.asyncapi.com/) specification. **This first post explains why we decided to start this project and provides more insights.**\n\nFor those who don't know [Microcks](https://microcks.io) yet: it is the ultimate Open source Kubernetes Native tool for Mocking and Testing all your APIs. With Microcks, you can turn your API contract, collection or SOAP UI projects into live mocks in a few seconds. For further information, please read [\"Why Microcks ?\"](https://microcks.io/blog/why-microcks/).\n\nWe are following the [AsyncAPI](https://www.asyncapi.com/) specification initiative since day one and I clearly remember how the [first announcement back in 2017](https://blog.hitchhq.com/introducing-the-asyncapi-specification-7feb57b460ae) resonated within our team ! We shared the same principles: Open source and community driven... and last but not least, 100% aligned with our vision that open specifications standards like [OpenAPI](https://www.openapis.org/) is the ultimate way to move forward and perpetuate our mantra: unlock developers potential in an unpredictable and strongly innovative environment!\n\nSince then, we have been in touch with our mutual communities and strategic users to see if we all embrace the idea of adding AsyncAPI testing and mocking support within Microcks. \nMicrocks community was very enthusiastic by the idea and problem this integration can solve. We have helped some users on their AsyncAPI use cases to grab valuable feedback on how to manage Microcks event-driven API integration. We learned a lot from different vertical industries, including tricky IoT & Edge computing or fintech implementations.\n\nOur communities clearly validate that it makes sense to have the same tool managing all their API whatever the type, open contract definition or design tool used. This is why, today Microcks supports open standards for contract definitions and mainstream open collaborative tools:\n\n![microcks-supported-standards](/img/posts/microcks-asyncapi-part1/microcks-supported-standards.webp)\n\nIt took us a year to make, which explains why Microcks 1.0.0 release is already GA and the first tool on [this topic](https://www.asyncapi.com/docs/tooling/#mocking) :wink: \n\n![asyncapi-tool-tweet](/img/posts/microcks-asyncapi-part1/asyncapi-tool-tweet.webp)\n\nThis is a major step forward as we are convinced that the transition to cloud-native applications will strongly embrace event-based and reactive architecture. Thus the need to speed-up and govern event-based API like any other services mocking using Microcks will be crucial and a key success factor for any modern and agile software developments.\n\nMicrocks 1.0.0 provides a solid platform for simulating event-based API using message broker technologies like [Apache Kafka](https://kafka.apache.org) even before the publishing component has been developed. And once developed, it is then capable to validate that all the publisher sent events will be compliant with the defined specification, automatically from a CI/CD pipeline.\n\nTo demonstrate our commitment/vision and to [improve AsyncAPI specifications](https://www.asyncapi.com/blog/status-update-37-20/#proposal-for-more-formal-examples) on our favorite topic: testing & mocking, we have launched an upstream feature request in order to provide a formal type for message examples.\n\n![call-to-action](/img/posts/microcks-asyncapi-part1/call-to-action.webp)\n\nPlease have a look at [this proposal #329](https://github.com/asyncapi/asyncapi/issues/329) and share your opinion. At the moment, it is a part of [AsyncAPI 2.1 milestone](https://github.com/asyncapi/asyncapi/milestone/17).\n\n ** In the next article, we will focus on Microcks + AsyncAPI use cases. Stay tuned.**\n\n> And if you can't wait for text explanataions, do not hesitate having a look at the [AsyncAPI SIG Meeting #34 recording](https://www.youtube.com/watch?v=pmRA4M-TWuE) for full illustrations of the capabilities. :wink:\n",
    "toc": [],
    "slug": "/blog/microcks-asyncapi-part1",
    "filePath": "pages/blog/microcks-asyncapi-part1.md"
  },
  {
    "meta": {
      "title": "Is Hacktoberfest Good For Maintainers?",
      "date": "2020-11-05T05:00:00.000Z",
      "type": "Community",
      "tags": [
        "Hacktoberfest"
      ],
      "cover": "/img/posts/hacktoberfest-summary-2020/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "readingTime": 9,
      "excerpt": "tl;dr\nIn October, we welcomed 26 new contributors with 70 pull requests (PRs) merged. It was an exhausting but also a fascinating experience.\nHacktoberfest Is Ok\nDon&amp#39;t be afraid of Hacktoberfes"
    },
    "content": "\n## tl;dr\n\nIn October, we welcomed 26 new contributors with 70 pull requests (PRs) merged. It was an exhausting but also a fascinating experience.\n\n## Hacktoberfest Is Ok\n\nDon't be afraid of [Hacktoberfest](https://hacktoberfest.digitalocean.com/). It is an excellent event for both contributors and maintainers.\n\nThere are [haters](https://blog.domenic.me/hacktoberfest/) that will tell you something different. My advice, follow [truncated mean](https://en.wikipedia.org/wiki/Truncated_mean) measure and always discard extreme opinions, especially if they call for boycotting:\n\n> Finally, and most importantly, we can remember that this is how DigitalOcean treats the open source maintainer community, and stay away from their products going forward\n\nCancel culture at its best. The fact that someone is good at programming or works at Google or Facebook doesn't make them experts in everything. Remember that celebrities are not good candidates for a role model.\n\nThere are no perfect events; there are no best solutions. There is always a place for improvement, but it should be followed by open, civilized discussion.\n\nLet me conclude by saying that I hope the \"harm to the open source made by DigitalOcean\" is not as significant as the harm that such hate does to open source by discouraging new open-source contributors. However, this is just speculation. How can I consider any of these things harmful if I did not conduct scientific research? I can only confirm that Hacktoberfest did not harm [AsyncAPI Initiative](https://www.asyncapi.com/). On the contrary, it was pretty neat.\n\n## Spam\n\nDuring the entire event, we had only two spam PRs. I can imagine that a much more popular and known project might have had more. Nevertheless, adding the **invalid** label and closing a PR is a super simple operation, three clicks.\n\nThe definition of spam heavily depends on maintainers. For example, [this](https://github.com/facebook/react/pull/19953) is not invalid to me, because I don't think of grammar as \"subjective nits\".\n\n## Why We Participated in Hacktoberfest\n\nOur intentions were pretty clear from the very beginning. As I wrote in the [previous post](/blog/hacktoberfest-2020), we wanted to:\n - Promote [AsyncAPI Initiative](https://www.asyncapi.com/) as a place where we work not only on the AsyncAPI specification, but also lots of tools\n - Help members of the broader open-source community make their first contributions in a friendly environment\n\nMy impression is that sometimes the open-source is perceived as a kind of elite gathering. **This is quite often blocking people from joining because they feel they cannot help but rather waste others' time.** I was there in the past, I thought the same. It's just another variation of the damn [impostor syndrome](https://en.wikipedia.org/wiki/Impostor_syndrome). You can always help, no matter what your experience is.\n\nStart small. Don't start with tasks that can be overwhelming. Don't throw yourself into the deep end. \n\nWe wanted to help others make first baby steps in a secure and inclusive environment, with lots of patience and support.\n\n## What It Takes To Have 70 PRs Merged\n\nIt is not enough to label 70 issues with the **hacktoberfest** label, sorry :smiley:\n\nFirst of all, you need to be passionate about open source and dedicated to what you do. It can't just be a task that somebody assigned to you. It would help if you were prepared to treat Hacktoberfest participants as a priority. I would compare it to the onboarding process of new hires. \n\nOf course, not all participants join to stay longer, usually they just follow the  \"one pull request, and I'm out of here\" approach.\n\nIt doesn't matter. \n\nPlease don't make assumptions; assumptions are evil. Be opened, treat every contribution equally, and remember that the onboarding process is a crucial element. If you fail with the onboarding process, you fail big time at the very beginning.\n\n### What We Prepared\n\nWe prepared the following materials for potential participants:\n- [Blog post](https://www.asyncapi.com/blog/hacktoberfest-2020) about our participation\n- [Onboarding videos](https://www.youtube.com/playlist?list=PLbi1gRlP7pigFSE_6G88x0t12HFLU4A4b) that explain how to start\n- 78 issues from more than 30 repositories and put them all in one [list](https://docs.google.com/spreadsheets/d/1vX4J395apexutfQ0OSqPNltFKDacmemHZwCmOXwHNLo/) with additional information about the difficulty level or the technical area,\n\nIt took me around eight workdays to do it all. The most time-consuming part was to go through all the issues, pick candidates, create new ones, and group them all in a Google Sheet.\n\n### What We Did During The Event\n\n70 pull requests mean —at least— 70 reviews :sweat_smile:\n\nIf you know your project well, it is not very time-consuming, and anyway, it is the work you have to do as a maintainer. I do not count this time as an extra Hacktoberfest effort. Of course, it can be overwhelming if this is not a standard amount of PRs that you get every month.\n\nWe also hosted [office hours](https://www.youtube.com/playlist?list=PLbi1gRlP7pigZP2da6zbDT2YU7glQOTPH) for participants. This was fun, and we wanted to start doing live streams about AsyncAPI anyway.\n\nLast but not least, once a week, I advertised our project on the official Hacktoberfest Discord server.\n\n[![](/img/posts/hacktoberfest-summary-2020/feedback-sharkham.webp)](https://github.com/asyncapi/vscode-extension/pull/8#issuecomment-719759737)\n\nIt looks like we do not need to do more for the next year.\n\n## Was It Worth It\n\nHell yeah, and I'm already looking forward to Hacktoberfest 2021.\n\nIt was great to see so many different people interacting with the project and seeing we reached our goal.\n\n[![](/img/posts/hacktoberfest-summary-2020/feedback-juergenbr.webp)](https://github.com/asyncapi/html-template/pull/98#issuecomment-709014754)\n\nWe got some new features, CI/CD cleanup in all repositories, and solved many trivial SonarCloud-reported issues that we would never found time to solve.\n\n## What Made It Such a Success\n\nOur success was a typical return on investment.\n\n[![](/img/posts/hacktoberfest-summary-2020/feedback-Orodan.webp)](https://github.com/asyncapi/playground/pull/38#issuecomment-710014222)\n\nWe asked all contributors to provide feedback on how they learned about us and what was the most helpful resource. 20 out of 26 responded to our request.\n\n<Figure\n  src=\"/img/posts/hacktoberfest-summary-2020/how-they-learned.webp\"\n  caption=\"Figure 1: Ways in which the contributors learned about AsyncAPI participating in Hacktoberfest\"\n/>\n\nI think it is pretty clear that introducing the official Discord channel was a great idea. I personally do not like Discord because of the lack of support for threads, but better this than nothing.\n\n<Figure\n  src=\"/img/posts/hacktoberfest-summary-2020/what-they-used.webp\"\n  caption=\"Figure 2: Resources helpful for contributors\"\n/>\n\nSuch a simple thing as a Google Sheet with a list of issues grouped by different factors was, in the end, our best resource for contributors. I encourage you to create such a sheet for your contributors next year.\n\n## Open Request to Hacktoberfest Organizers\n\nThere is one thing that calls for an improvement for next year. Just one? Yeah, opt-in solution for projects that want to participate in Hacktoberfest was addressed during this event, and I assume it stays on.\n\nThe number of projects that people can work on is overwhelming, and finding the right issue seems very difficult. Please have a look at the feedback we got from our contributors. It is enough to develop an official application where potential contributors can adequately filter out issues by technology and difficulty. In the end, it doesn't make sense for all maintainers to work on their own Google Sheets and post it on Discord. A better way would be to introduce an app for all.\n\n## Hall Of Fame\n\nBelow you can find a list of all contributors that joined AsyncAPI during Hacktoberfest and contributed their time to the project. The list is sorted alphabetically, including the number of PRs created by this contributor.\n\n<table>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://github.com/ab510\">\n        <img src=\"https://avatars3.githubusercontent.com/u/46869762?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            ab510 (2)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/anbreaker\">\n        <img src=\"https://avatars3.githubusercontent.com/u/6112820?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            anbreaker (3)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/beni0888\">\n        <img src=\"https://avatars3.githubusercontent.com/u/2619784?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Jesús Miguel Benito Calzada (1)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/bszwarc\">\n        <img src=\"https://avatars3.githubusercontent.com/u/17266942?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n             Barbara Szwarc (8)\n          </b>\n        </sub>\n      </a>\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://github.com/bufutda\">\n        <img src=\"https://avatars3.githubusercontent.com/u/7246741?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Mitchell Sawatzky (2)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/C-Zekeri\">\n        <img src=\"https://avatars3.githubusercontent.com/u/55132738?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Chenemi Zekeri (2)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/charlietharas\">\n        <img src=\"https://avatars3.githubusercontent.com/u/55163594?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Charlie Tharas (1)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/christeen24\">\n        <img src=\"https://avatars3.githubusercontent.com/u/26082656?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Christeen Fernando (1)\n          </b>\n        </sub>\n      </a>\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://github.com/DanielChuDC\">\n        <img src=\"https://avatars3.githubusercontent.com/u/52316624?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            danielchu (4)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/depimomo\">\n        <img src=\"https://avatars3.githubusercontent.com/u/12368942?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            depimomo (4)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/falconmfm\">\n        <img src=\"https://avatars3.githubusercontent.com/u/2099350?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Miguel Angel Falcón Muñoz (1)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/gabrielclaudino\">\n        <img src=\"https://avatars3.githubusercontent.com/u/26636890?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Gabriel Claudino (1)\n          </b>\n        </sub>\n      </a>\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://github.com/HashTalmiz\">\n        <img src=\"https://avatars3.githubusercontent.com/u/55018280?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Talmiz Ahmed (5)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/HUTCHHUTCHHUTCH\">\n        <img src=\"https://avatars3.githubusercontent.com/u/55915170?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            HUTCHHUTCHHUTCH (11)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/JakubIwanowski\">\n        <img src=\"https://avatars3.githubusercontent.com/u/25127286?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Jakub Iwanowski (2)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/jooaodanieel\">\n        <img src=\"https://avatars3.githubusercontent.com/u/12701604?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            João Francisco Lino Daniel (1)\n          </b>\n        </sub>\n      </a>\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://github.com/juergenbr\">\n        <img src=\"https://avatars3.githubusercontent.com/u/683438?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Jürgen B. (3)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/mbeuil\">\n        <img src=\"https://avatars3.githubusercontent.com/u/33709157?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            mbeuil (2)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/mowies\">\n        <img src=\"https://avatars3.githubusercontent.com/u/6901203?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Moritz Wiesinger (1)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/nekosune\">\n        <img src=\"https://avatars3.githubusercontent.com/u/690546?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Katrina Knight (2)\n          </b>\n        </sub>\n      </a>\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://github.com/Orodan\">\n        <img src=\"https://avatars3.githubusercontent.com/u/7422824?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Jimmy Kasprzak (3)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/philrussel21\">\n        <img src=\"https://avatars3.githubusercontent.com/u/44673258?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Phil Antiporda (1)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/RageZBla\">\n        <img src=\"https://avatars3.githubusercontent.com/u/1196871?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Olivier Lechevalier (6)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/sanskar-p\">\n        <img src=\"https://avatars3.githubusercontent.com/u/54014518?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n             Sanskar Patro (1)\n          </b>\n        </sub>\n      </a>\n    </td>\n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://github.com/sharkham\">\n        <img src=\"https://avatars3.githubusercontent.com/u/49769979?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n            Sam (1)\n          </b>\n        </sub>\n      </a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/slavakr\">\n        <img src=\"https://avatars3.githubusercontent.com/u/1413160?v=4\" width=\"100px;\" alt=\"\"/>\n        <br />\n        <sub>\n          <b>\n             GrimPix (1)\n          </b>\n        </sub>\n      </a>\n    </td>\n  </tr>\n</table>\n\n> Cover photo by <a href=\"https://unsplash.com/@goian?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Ian Schneider</a> on <a href=\"https://unsplash.com/s/photos/success-event?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "tl;dr",
        "slug": "tldr",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Hacktoberfest Is Ok",
        "slug": "hacktoberfest-is-ok",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Spam",
        "slug": "spam",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Why We Participated in Hacktoberfest",
        "slug": "why-we-participated-in-hacktoberfest",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "What It Takes To Have 70 PRs Merged",
        "slug": "what-it-takes-to-have-70-prs-merged",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "What We Prepared",
        "slug": "what-we-prepared",
        "lvl": 3,
        "i": 5,
        "seen": 0
      },
      {
        "content": "What We Did During The Event",
        "slug": "what-we-did-during-the-event",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Was It Worth It",
        "slug": "was-it-worth-it",
        "lvl": 2,
        "i": 7,
        "seen": 0
      },
      {
        "content": "What Made It Such a Success",
        "slug": "what-made-it-such-a-success",
        "lvl": 2,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Open Request to Hacktoberfest Organizers",
        "slug": "open-request-to-hacktoberfest-organizers",
        "lvl": 2,
        "i": 9,
        "seen": 0
      },
      {
        "content": "Hall Of Fame",
        "slug": "hall-of-fame",
        "lvl": 2,
        "i": 10,
        "seen": 0
      }
    ],
    "slug": "/blog/hacktoberfest-summary-2020",
    "filePath": "pages/blog/hacktoberfest-summary-2020.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Initiative Status Update (week 43, 2020)",
      "date": "2020-10-21T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/status-update-43/cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "readingTime": 4,
      "excerpt": "AsyncAPI JavaScript Parser 1.0.0 Is Out\nI’m very proud to share that we are finally there, release 1.0.0 is out in the wild.\nOne month passed since the last release candidate, and no one reported any "
    },
    "content": "\n## AsyncAPI JavaScript Parser 1.0.0 Is Out\n\nI’m very proud to share that we are finally there, release 1.0.0 is out in the wild.\n\nOne month passed since the last release candidate, and no one reported any blockers for our first major release.\n\nAsyncAPI JavaScript Parser is an official library that validates AsyncAPI documents and returns a set of functions that make it much easier to access the document's contents. It works well both in the browser and in Node.js. We've been using it for very long in our React component to parse in the browser and in the AsyncAPI Generator to parse documents in the Node.js server and CLI.\n\nPlease join us in the celebration. We do it in a typical asynchronous way. Everyone celebrates whenever they can...\n\n<div className=\"text-center\">\n  <img src=\"https://media.giphy.com/media/Vj97qNut6WDHa/giphy.gif\" />\n</div>\n\n## HTML Template Improvements\n\nHacktoberfest contributions brought many improvements and bug fixes. Two weeks ago, during the last status update, the HTML template version was 0.12.2, and now it is 0.15.0.\n\n### PDF Generation\n\nThe template supports now an additional parameter called **pdf**. You use it to get an additional PDF file generated, next to the index.html file. In the CLI, pass `-p pdf=true` to get it. Thank you [Talmiz Ahmed](https://github.com/HashTalmiz).\n\n### Change Default Name of HTML File\n\nThe template now supports an additional parameter called **outFilename**. You use it to change the default index.html file to something different, like for example, asyncapi.html. In the CLI, pass `-p outFilename=asyncapi.html` to get it. Thank you [Mitchell Sawatzky](https://github.com/bufutda). \n\n### Display of Schema UID\n\nDue to suggestions from different community members, we now display the UID of the schema. UID is displayed only if it is provided. An anonymous UID assigned by the AsyncAPI Parser to schemas without UID is not shown.\n\nNotice how it is displayed in the below example, next to the first two **mixedTypeArray** property schemas.\n\n<img className=\"w-3/4\" src=\"/img/posts/status-update-43/display-schema-uid.webp\" />\n\n## Java Spring Template Improvements\n\nOur great contributor [Semen Tenischev](https://github.com/Tenischev) came back and kicked off the work on the Java template. Most important is a new feature to support _anyOf_ and _oneOf_. There are also bug fixes for enums generation and how schemas without UID are handled. The current version is 0.20.1. \n\n## Hacktoberfest Status\n\nFor us, the Hacktoberfest celebration has been a great success so far. The first day of the event started with two spam pull requests, but then...well, see for yourself:\n- We had 24 contributors\n- We merged 58 pull requests!\n\nOnly around 20 issues left on our [list](https://docs.google.com/spreadsheets/d/1vX4J395apexutfQ0OSqPNltFKDacmemHZwCmOXwHNLo/). Hurry up and become our star!\n\n## Generator Release Candidate 13\n\nWe released [another](https://github.com/asyncapi/generator/releases/tag/v1.0.0-rc.13) release candidate with several security fixes. Important to notice in this RC is that we changed the way we build the docker image. Now it doesn’t contain the generator's sources but we install Generator CLI as a global application. This means the entrypoint is not “node ./cli.js” but “ag”, just like you would use it without Docker. Also, keep in mind that this release candidate now uses the official major release of the JavaScript Parser.\n\n## AsyncAPI Special Interest Group (SIG) open meeting\n\nThe last meeting took place on Tuesday, 13th of October, 4PM UTC. Meeting notes and recording are available [here](https://github.com/asyncapi/asyncapi/issues/451).\n\nThe next meeting is scheduled for next [Tuesday, 27th of October 8AM UTC](https://everytimezone.com/s/577ca99f). \n\nWe work on the agenda for the next meeting [here](https://github.com/asyncapi/asyncapi/issues/455). At the moment, there is nothing on the agenda so you can easily sneak your topic in. \n\nWe host the meeting on [Zoom](https://zoom.us/j/165106914). Do not forget about future meetings and always have up to date invitations in your calendar by adding your email to [this](https://groups.google.com/forum/#!forum/asyncapi-users) mailing list.\n\n> Cover photo by <a href=\"https://unsplash.com/@spacex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">SpaceX</a> on <a href=\"https://unsplash.com/s/photos/rocket-launch?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "AsyncAPI JavaScript Parser 1.0.0 Is Out",
        "slug": "asyncapi-javascript-parser-100-is-out",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "HTML Template Improvements",
        "slug": "html-template-improvements",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "PDF Generation",
        "slug": "pdf-generation",
        "lvl": 3,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Change Default Name of HTML File",
        "slug": "change-default-name-of-html-file",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Display of Schema UID",
        "slug": "display-of-schema-uid",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Java Spring Template Improvements",
        "slug": "java-spring-template-improvements",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Hacktoberfest Status",
        "slug": "hacktoberfest-status",
        "lvl": 2,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Generator Release Candidate 13",
        "slug": "generator-release-candidate-13",
        "lvl": 2,
        "i": 7,
        "seen": 0
      },
      {
        "content": "AsyncAPI Special Interest Group (SIG) open meeting",
        "slug": "asyncapi-special-interest-group-sig-open-meeting",
        "lvl": 2,
        "i": 8,
        "seen": 0
      }
    ],
    "slug": "/blog/status-update-43-20",
    "filePath": "pages/blog/status-update-43-20.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Initiative Status Update (week 41, 2020)",
      "date": "2020-10-07T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/status-update-41-20-new-website.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "readingTime": 5,
      "excerpt": "New Website\nI&amp#39;m super excited to share with you that last week we released a new AsyncAPI website:\nOn a home page, we now promote the Playground more and put much more emphasis on the different"
    },
    "content": "\n\n\n## New Website\n\nI'm super excited to share with you that last week we released [a new AsyncAPI website](/):\n- On a home page, we now promote [the Playground](https://playground.asyncapi.io) more and put much more emphasis on the different ways you can engage with AsyncAPI Community,\n- Documentation view got additional navigation per document so, for example, it is now much better to navigate through different sections of [the specification document](/docs/specifications/2.0.0),\n- The tools section is now dedicated to AsyncAPI's official tools to clarify the AsyncAPI initiative is not just the spec. Just have a look how much detailed is, for example, the [generator view](/generator),\n- Don't worry, all the other tools are still there, under [the Community section](/docs/community/tooling)\n- The cherry on the cake is a much more appealing [Blog view](/blog)\n\n[Fran Méndez](https://twitter.com/fmvilas) did all this fantastic job. Well done, Bro! Sources of the website are [here](https://github.com/asyncapi/website). Feel free to use it as a template for your website and let us know if you need help reusing it.\n\n## Hacktoberfest\n\nAsyncAPI Initiative joined Hacktoberfest. We decided to join the event at the end of August when nobody even thought this would happen. The first day of Hacktoberfest felt like a false start. Because of the enormous amount of spam pull requests, some open-source community people went too far in the #cancelculture trend. They opted on Twitter for the Hacktoberfest cancelation and DigitalOcean boycott. Luckily, not everyone is a hater, and Hacktoberfest stays. Anyway, this is a topic for another post.\n\nDo we regret we engaged with event participants? Hell no! So far, we got only 2 spam PRs, but we also got many issues addressed (26 in 7 days) that we listed for the event.\n\nWe had two primary goals to join the event:\n- Show the community that AsyncAPI Initiative is not just the spec but a lot of great tooling.\n- Help out people to take their first baby steps in open-source contributions with a welcoming community. We not only prepared issues with different levels of difficulty but also created a set of videos that explain how to contribute and what the issues are about. \n\nAnyway. We share the summary of how Hacktoberfest ended up for us in the next status update. So far, so good though.\n\nRemember that throughout the entire October me and Fran, we'll be hosting office hours so anyone can join and ask for help or even do a pair programming session with us. Feel invited! More details in the blog post about the event. We will stream to our official media accounts:\n- https://www.twitch.tv/asyncapi\n- https://www.youtube.com/asyncapi\n- https://twitter.com/AsyncAPISpec \n\nLook into [this](https://calendar.google.com/calendar/u/0?cid=dGJyYmZxNGRlNWJjbmd0OG9rdmV2NGxzdGtAZ3JvdXAuY2FsZW5kYXIuZ29vZ2xlLmNvbQ) calendar for the schedule.\n\n## Apidays Live Hong Kong\n\nThe AsyncAPI founder, [Fran Méndez](https://twitter.com/fmvilas), was invited to present at Apidays Live Hong Kong. It is a free event that we recommend you to join. Fran's talk is scheduled for tomorrow at 8:10 AM CEST (2:10 PM Hong Kong timezone). He'll talk about `AsyncAPI and the Future of API specs`.\n\nOur regular community member, Paul Taylor from Mulesoft, will talk about `Getting Started with AsyncAPI`. His talk is scheduled for tomorrow, 6:10 AM CEST (12:10 PM Hong Kong timezone).\n\n To join the event, register [here](https://www.eventbrite.com/e/apidays-live-hong-kong-the-open-api-economy-finance-as-a-service-api-ecosystems-tickets-104511637120). \n\n## React Component Improvements\n\nThe latest version of the component is 0.13.1. Since the last status update, we had three releases, where one was a feature to display descriptions of channels and operations correctly. We can see more interest in the component and more people asking about a client side's documentation rendering. External contributors pushed all recent changes to the component. Thanks a lot to [Dominik Henneke](https://github.com/dhenneke), [Oliver Sand](https://github.com/Fox32), and [Jakub Iwanowski](https://github.com/JakubIwanowski).\n\nDon't think that server-side docs generation dies. So far generation of docs using [HTML Template](https://github.com/asyncapi/html-template) is most popular. We had a few bug fixes added to it, and the current release is 0.13.0. The latest release has a feature that few people asked for. Now you can add `-p outFilename=customName.html` parameter to modify the name of the output HTML file.\n\n## AsyncAPI Special Interest Group (SIG) open meeting\n\nThe last meeting took place on Tuesday, 15th of September, 4PM UTC. Meeting notes and recording are available [here](https://github.com/asyncapi/asyncapi/issues/443). \n\nThe next meeting is scheduled for next [Tuesday, 13th of October, 4PM UTC](https://everytimezone.com/s/89b676b6). \n\nWe work on the agenda for the next meeting [here](https://github.com/asyncapi/asyncapi/issues/451). At the moment, there is nothing in the agenda so you can sneak in your topic easily. \n\nWe host the meeting on [Zoom](https://zoom.us/j/165106914). Do not forget about future meetings and always have up to date invitations in your calendar by adding your email to [this](https://groups.google.com/forum/#!forum/asyncapi-users) mailing list.\n\n## Some Good Read\n\n- [3 Experts on How the API Industry Is Changing](https://nordicapis.com/3-experts-on-how-the-api-industry-is-changing/) article by [Thomas Bush](https://www.linkedin.com/in/thomasbush/)\n- [Going AsyncAPI: The Good, The Bad, and The Awesome](https://www.youtube.com/watch?v=bSfgNDJf97M) video by [Ben Gamble](https://twitter.com/BenGamble7)\n- [AsyncAPI @Hacktoberfest](https://www.asyncapi.com/blog/hacktoberfest-2020) article by [Lukasz Gornicki](https://twitter.com/derberq)\n\n> Cover photo by <a href=\"https://unsplash.com/@pineapple?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Pineapple Supply Co.</a> on <a href=\"https://unsplash.com/s/photos/celebrate?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "New Website",
        "slug": "new-website",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Hacktoberfest",
        "slug": "hacktoberfest",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Apidays Live Hong Kong",
        "slug": "apidays-live-hong-kong",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "React Component Improvements",
        "slug": "react-component-improvements",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "AsyncAPI Special Interest Group (SIG) open meeting",
        "slug": "asyncapi-special-interest-group-sig-open-meeting",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Some Good Read",
        "slug": "some-good-read",
        "lvl": 2,
        "i": 5,
        "seen": 0
      }
    ],
    "slug": "/blog/status-update-41-20",
    "filePath": "pages/blog/status-update-41-20.md"
  },
  {
    "meta": {
      "title": "AsyncAPI @Hacktoberfest",
      "date": "2020-09-30T05:00:00.000Z",
      "type": "Community",
      "tags": [
        "Hacktoberfest"
      ],
      "cover": "/img/posts/hacktoberfest.webp",
      "weight": 10,
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "readingTime": 5,
      "excerpt": "&amplt;Warning\n  title=&ampquot;HacktoberFest 2020 has finished&ampquot;\n  description={\n    &ltspan&gtCheck out our &ltLink href=&quot/blog/hacktoberfest-summary-2020&quot passHref&gt&lta&gtsummary b"
    },
    "content": "\n<Warning\n  title=\"HacktoberFest 2020 has finished\"\n  description={\n    <span>Check out our <Link href=\"/blog/hacktoberfest-summary-2020\" passHref><a>summary blog post</a></Link>. There are lots of good insights!</span>\n  }\n/>\n\n## What is AsyncAPI\n\nAsyncAPI is a specification for describing your [event-driven architecture](https://www.asyncapi.com/docs/getting-started/event-driven-architectures/). You are probably using already [OpenAPI/Swagger specification](https://www.asyncapi.com/docs/getting-started/coming-from-openapi/) for describing your synchronous RESTful APIs. AsyncAPI is something that supplements OpenAPI. As an example, you should use AsyncAPI when your services do not talk to each other directly but through a message broker.\n\nIn contrast to the OpenAPI Initiative, AsyncAPI Initiative is focused not only on creating and evolving the AsyncAPI specification but also on its tooling. It is a vendor-neutral space for the community to work together on the spec and its tools. We work on tools like specification parsers or docs and code generators.\n\n<YouTube id=\"pU71J-F7pfI\" />\n\n## What Is Hacktoberfest And Why AsyncAPI Initiative Joins It\n\n[Hacktoberfest](https://hacktoberfest.digitalocean.com/) is a well-known event that promotes open source contributions. In short, you have the entire October to submit four pull requests to any project you want, and in exchange, you get a super cool t-shirt. Is that it? Is it just for a t-shirt? Nah, the t-shirt is nice but what you also get is easy access to open source world. Maintainers of many projects open up for contributions, and it is a great chance to make your first step to joining this fantastic world.\n\nAsyncAPI Initiative joins the Hacktoberfest for two main reasons:\n\n- Promote AsyncAPI Initiative as a place where we don't work on the specification only but also build a lot of great tools\n- Make it much easier for the community to make the first contribution to one of the AsyncAPI repositories\n\nIn the past, we were also there where you are now, shy and uncertain if we can impact open source community. We want to give you an easy path to take the first baby steps in the world of open source in a welcoming and friendly environment.\n\n> Don't forget to [sign up](https://hacktoberfest.digitalocean.com/login) to the Hacktoberfest\n\n<YouTube id=\"_1WRr3Ml9t4\" />\n\n## How Can You Help\n\nThere is always a lot of work waiting out there. For the sake of this special event, we prepared around 75 GitHub issues that you can pick up. They represent different areas (for example, JavaScript or HTML), different difficulty (for example, 50 issues are easy), and different repositories. No matter if they are trivial or demanding, all of them are important for us. Even with trivial ones where you, for example, need to remove a semicolon, we will still be super happy because this will improve the quality of the project (SonarCloud reports). In other words, every single issue from [this](https://docs.google.com/spreadsheets/d/1vX4J395apexutfQ0OSqPNltFKDacmemHZwCmOXwHNLo/edit?usp=sharing) list is important.\n\n### 1. Pick The Right Issue\n\n[Here](https://docs.google.com/spreadsheets/d/1vX4J395apexutfQ0OSqPNltFKDacmemHZwCmOXwHNLo/edit?usp=sharing) you can find a list of all the issues that you can work on. Most of the issues are about code contribution, but not all of them. There are also issues about documentation or CI/CD configuration (we use GitHub Actions). Just pick the issues you want to work on, one at a time, and let us know in the comments section that you want to work on it.\n\n<YouTube id=\"Iqs_2BiNEEo\" />\n\n### 2. Setup Your Environment And Create A First Pull Request\n\nOnce you [install Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) on your machine and get a [GitHub account](https://github.com/join), you need first to decide if you are here just for Hacktoberfest or longer, and make sure if your issue is easy and maybe you can complete it in the GitHub UI. \n\nIn case you are here just for the Hacktoberfest, and you picked easy issues that involve changes only to a single file, there is no need to install Git and complicate your life. GitHub UI enables you to [make changes to a single file online](https://docs.github.com/en/free-pro-team@latest/github/managing-files-in-a-repository/editing-files-in-your-repository).\n\nIn case you:\n\n- want to stay with us longer,\n- you picked up an issue where you need to make changes to more than just one file,\n- you also need to run the project locally to check if it works\n\nThen follow [this](https://github.com/asyncapi/.github/blob/master/git-workflow.md) short instruction on how to fork the repository and set it up locally.\n\nOnce you are ready with your changes, submit a pull request. Be nice and follow our [code of conduct](https://github.com/asyncapi/.github/blob/master/CODE_OF_CONDUCT.md) and make sure your pull request is [described properly](https://github.com/asyncapi/.github/blob/master/CONTRIBUTING.md#conventional-commits).\n\n<YouTube id=\"BsC5tu4M1rw\" />\n\n## Office Hours\n\nDo you feel overwhelmed? No need. You can do it. Just take this blog post seriously. \n\nTrust me when I write that every pull request is crucial for us.\nTrust me when I write that we are a welcoming community.\nDon't be afraid that you will waste our time. If we would think about it this way, we would not even join the Hacktoberfest.\n\nStill not sure if you can make it? Don't worry. We want to host office hours throughout the event, 2x a week, 1h long, and different time zones. You can join whenever you want and ask us anything, or do pair programming with us. We start with the first meeting on [Tuesday 6th, 8AM UTC](https://calendar.google.com/calendar/u/0?cid=dGJyYmZxNGRlNWJjbmd0OG9rdmV2NGxzdGtAZ3JvdXAuY2FsZW5kYXIuZ29vZ2xlLmNvbQ) and then on the following days:\n\n- Tuesday 6th, 8AM UTC\n- Thursday 8th, 4PM UTC\n- Tuesday 13th, 8AM UTC\n- Thursday 15th, 4PM UTC\n- Tuesday 20th, 8AM UTC\n- Thursday 22nd, 4PM UTC\n- Tuesday 27th, 8AM UTC\n- Thursday 29th, 4PM UTC\n\nWe stream to our official media accounts:\n\n- https://www.twitch.tv/asyncapi\n- https://www.youtube.com/asyncapi\n- https://twitter.com/AsyncAPISpec \n\nYou can also join us in a more asynchronous discussion on [Slack](https://www.asyncapi.com/slack-invite/). For updates and latest news, the best is to follow our [Twitter account](https://twitter.com/AsyncAPISpec). \n\n## Blooper Reel\n\nBefore you jump to your first contribution, have a look at the making of the videos. It was quite fun.\n\n<YouTube id=\"anjcF2l0lGs\" />\n\nEnjoy the Hacktoberfest!\n",
    "toc": [
      {
        "content": "What is AsyncAPI",
        "slug": "what-is-asyncapi",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "What Is Hacktoberfest And Why AsyncAPI Initiative Joins It",
        "slug": "what-is-hacktoberfest-and-why-asyncapi-initiative-joins-it",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "How Can You Help",
        "slug": "how-can-you-help",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "1. Pick The Right Issue",
        "slug": "1-pick-the-right-issue",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "2. Setup Your Environment And Create A First Pull Request",
        "slug": "2-setup-your-environment-and-create-a-first-pull-request",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Office Hours",
        "slug": "office-hours",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Blooper Reel",
        "slug": "blooper-reel",
        "lvl": 2,
        "i": 6,
        "seen": 0
      }
    ],
    "slug": "/blog/hacktoberfest-2020",
    "filePath": "pages/blog/hacktoberfest-2020.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Initiative Status Update (week 39, 2020)",
      "date": "2020-09-22T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/status-update-39/status-update-39-cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "readingTime": 4,
      "excerpt": "Circular References Supported in HTML and Markdown Templates\nAfter recent efforts into circular references support in the AsyncAPI JavaScript Parser, now we started using these features in HTML and Ma"
    },
    "content": "\n## Circular References Supported in HTML and Markdown Templates\n\nAfter recent efforts into circular references support in the AsyncAPI JavaScript Parser, now we started using these features in HTML and Markdown docs generators. With the latest releases of those two templates, you can generate documentation for schemas containing circular references. Below you can see an example specification file and how its payload and payload generated example looks like in generated HTML. You can also give it a try on your own in our [Playground](https://playground.asyncapi.io/). \n\n```asyncapi caption='AsyncAPI schema with a circular reference.'\nasyncapi: 2.0.0\ninfo:\n  title: Example\n  version: 0.1.1\nchannels:\n  recursive:\n    subscribe:\n      message:\n        payload:\n          $ref: '#/components/schemas/Recursive'\ncomponents:\n  schemas:\n    Recursive:\n      type: object\n      properties:\n        children:\n          type: array\n          items:\n            $ref: '#/components/schemas/Recursive'\n        something:\n          type: string\n```\n\n<Row>\n  <Column>\n    <Figure\n      src=\"/img/posts/status-update-39/pic2-circ-schema.webp\"\n      caption=\"Message payload presentation.\"\n    />\n  </Column>\n  <Column>\n    <Figure\n      src=\"/img/posts/status-update-39/pic3-circ-example.webp\"\n      caption=\"Generated payload example.\"\n    />\n  </Column>\n</Row>\n\n## Generate HTML Docs into a Single File\n\nThanks to the contribution from [Gordeev Artem](https://github.com/GordeevArt), you can now generate HTML documentation into a single file. Like what?\n\nTo generate HTML documentation for AsyncAPI files, you can use our [HTML generator template](https://github.com/asyncapi/html-template). It generates an index.html file with correctly rendered content of the AsyncAPI file. In addition, it also references additional files necessary for nice display of the HTML, JavaScript, and CSS files. \n\nFrom time to time, the community asked that it would be nice if the template could generate only one index.html file with all the JavaScript and CSS inline inside the HTML file.\n\nNow it is possible! There is a new parameter added to the template called singlePage. Just pass it for example, in the CLI like this -p singlePage=true.\n\n## Parser with More Helpers and Better API docs\n\nWe released [Parser release candidate 5](https://github.com/asyncapi/parser-js/releases/tag/v1.0.0-rc.5) with features you want to have in a library before you announce the 1.0.0 release. Thanks to generous support from our community member [Maciej Urbanczyk](https://github.com/magicmatatjahu), this release candidate contains the following additions:\n\n- Missing externalDocs field in AsyncAPIDocument model\n- New functions to all models that need it: hasBindings, bindingProtocols, hasBinding(name), binding(name), extensionKeys, extKeys, hasExtension, hasExt, tagNames, tag, hasTag, hasDescription\n- Much better API documentation. In the past, it was not only missing functions that were not available but also functions that were not documented because of the wrong usage of JSDocs. Now see on your own how significant is the change by looking just on the list of functions available for ChannelParameter model:\n\n\n<Row>\n  <Column>\n    <Figure\n      src=\"/img/posts/status-update-39/pic1-api-before.webp\"\n      caption=\"ChannelParameter Docs before release.\"\n    />\n  </Column>\n  <Column>\n    <Figure\n      src=\"/img/posts/status-update-39/pic2-api-after.webp\"\n      caption=\"ChannelParameter Docs after release.\"\n    />\n  </Column>\n</Row>      \n\n## Hacktoberfest Preparation\n\n[Hacktoberfest](https://hacktoberfest.digitalocean.com/) is a great event for people to start contributing to open source. It runs throughout October, and we want AsyncAPI Initiative to join the event. Why?\n\n- Enable different communities to jump into the AsyncAPI projects with simple tasks, so they can get familiar with what we have, where to find things, and how easy it is to kick off with the first contribution\n- Show to the community something that might not be so obvious, that the AsyncAPI Initiative is not only working on the specification but also a lot of great tools to make it easy to work with the specification \n\nIf you are interested in how we plan to join the Hacktoberfest, look at our [plan](https://docs.google.com/document/d/1fljbYU-wD4gvusFpWqCrVQfPb4nitcKAKag1TOm5lNs/). \n\n## The Highlight of Interesting Discussions\n\n### WAMP Protocol Bindings\n\nThere are community efforts to define bindings for [Web Application Messaging Protocol (WAMP)](https://wamp-proto.org/). In case you are experienced with the protocol, please join and support [here](https://github.com/asyncapi/asyncapi/issues/400).\n\n### Go Code Generation \n\nThere are community efforts to create a template for generating Go code using the AsyncAPI generator. The initial pull request is opened. You can help even if you are not familiar with AsyncAPI, as you can help with just the review of the generated code. Please join and support [here](https://github.com/asyncapi/go-template/pull/1/files).\n\n## AsyncAPI Special Interest Group (SIG) open meeting\n\nThe last meeting took place on Tuesday, 15th of September, 4PM UTC. Meeting notes and recording are available [here](https://github.com/asyncapi/asyncapi/issues/435). \n\nThe next meeting is scheduled for next [Tuesday, 29th of September, 8AM UTC](https://everytimezone.com/?t=5f727900,1e0). \n\nWe work on the agenda for the next meeting [here](https://github.com/asyncapi/asyncapi/issues/443). At the moment, there is nothing in the agenda so you can sneak in your topic easily. \n\nWe host the meeting on [Zoom](https://zoom.us/j/165106914). Do not forget about future meetings and always have up to date invitations in your calendar by adding your email to [this](https://groups.google.com/forum/#!forum/asyncapi-users) mailing list.\n\n\n> Cover photo by <a href=\"https://unsplash.com/@finleydesign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Neil Thomas</a> on <a href=\"https://unsplash.com/s/photos/community-support?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Unsplash</a>\n",
    "toc": [
      {
        "content": "Circular References Supported in HTML and Markdown Templates",
        "slug": "circular-references-supported-in-html-and-markdown-templates",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Generate HTML Docs into a Single File",
        "slug": "generate-html-docs-into-a-single-file",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Parser with More Helpers and Better API docs",
        "slug": "parser-with-more-helpers-and-better-api-docs",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Hacktoberfest Preparation",
        "slug": "hacktoberfest-preparation",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "The Highlight of Interesting Discussions",
        "slug": "the-highlight-of-interesting-discussions",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "WAMP Protocol Bindings",
        "slug": "wamp-protocol-bindings",
        "lvl": 3,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Go Code Generation",
        "slug": "go-code-generation",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "AsyncAPI Special Interest Group (SIG) open meeting",
        "slug": "asyncapi-special-interest-group-sig-open-meeting",
        "lvl": 2,
        "i": 7,
        "seen": 0
      }
    ],
    "slug": "/blog/status-update-39-20",
    "filePath": "pages/blog/status-update-39-20.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Initiative Status Update (week 37, 2020)",
      "date": "2020-09-09T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/status-update-33-vacation.webp",
      "weight": 10,
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "readingTime": 4,
      "excerpt": "We canceled the previous status update due to the vacation cucumber season, so this status update covers the last four and not two weeks. Please familiarize yourself with many things we worked on and "
    },
    "content": "\nWe canceled the previous status update due to the vacation cucumber season, so this status update covers the last four and not two weeks. Please familiarize yourself with many things we worked on and the exciting discussions we had.\n\n## Template for templates development\n\nWe’ve spent a lot of time recently on tooling development. Now it is time to start working on some docs! Last few weeks, we worked on a template, a boilerplate that one can use to create a new repository to start writing their template for the AsyncAPI Generator. \n\nThe work is still in progress and will take a few weeks more, but you can already see a preview [here](https://github.com/derberg/template-for-generator-templates). All the Generator features are showcased there already. We are missing only example tests and readme there. \n\nThe next steps are writing a set of interactive tutorials that can explain all the features step by step, help create a super basic template, and then a more complex one.\n\nIn case you have some ideas, or maybe you want to help write those, please let us know.\n\n## Avro 1.8.2 support\n\nAvro schema parser now supports [Avro 1.8.2](https://github.com/asyncapi/avro-schema-parser/pull/6) and not only 1.9.0. The AsyncAPI Generator and the Playground already support the new version of the parser.\n\n## Parser v1.0.0-rc.4\n\nThe latest release candidate includes few bug fixes, but most important is that it also introduces proper tests for the browser to make sure we avoid any future mistakes in the project that could cause browser-incompatible release.\n\n## React component improvements\n\nThe AsyncAPI React component for rendering documentation on the client-side just reached release v0.12.1. Among all the other improvements, the most important are:\n\n- Custom schema parsers for RAML, OpenAPI, and Avro are now also used by this component\n- Better handling and rendering of `additionalProperties`\n- Schemas are not presented in the tables anymore\n\n## The Highlight of Interesting Discussions\n\n### Proposal for more formal examples\n\nAsyncAPI 2.0 specs allow you to specify an example of the message. You can have many examples stored in an array of maps, where the key is the name of the example, and value can be of any type. [Laurent Broudoux](https://github.com/lbroudoux) from [Microcks](https://github.com/lbroudoux) project created a proposal for better representation of examples where you can provide an example of the message payload and the headers. It means we will end up with more formal Examples object in the spec.\n\nPlease have a look at [this](https://github.com/asyncapi/asyncapi/issues/329) proposal and share your opinion. At the moment, it is a part of our AsyncAPI 2.1 milestone.\n\n### Native support for projects like CloudEvents\n\n[CloudEvents](https://cloudevents.io/) is a specification for commonly describing event data. AsyncAPI is a specification for describing an application's API related to asynchronous communication. In the end, users should not decide which spec is better cause they serve a different purpose. Through discussions with the community, we learned that many want to use AsyncAPI + CloudEvents + Avro.\n\nBefore AsyncAPI 2.0.0 we released [an article](https://www.asyncapi.com/blog/asyncapi-cloud-events/) where we discussed how CloudEvent could be used in an AsyncAPI document. Long story short, it was about presenting a payload of messages wrapped with CloudEvents in AsyncAPI Payload object, and how to leverage AsyncAPI custom schema format. Such an approach can lead to a lot of duplications.\n\nCloudEvents is like an envelope for your letter. The message may include some non-business related data instead of having them separated in the headers. You do not want to mix this technical information with business information in the AsyncAPI document under one Payload field, even if this is possible.\n\nOne possible option could be to reuse AsyncAPI bindings functionality, but so far, they were used only for describing information related to specific protocols.\n\nPlease have a look at [this](https://github.com/asyncapi/asyncapi/issues/432) issue or talk to us on Slack. In short, we discuss there an option to introduce an object called Envelope.\n\n## AsyncAPI Special Interest Group (SIG) open meeting\n\nThe last meeting took place on Tuesday, 1st of September, 8AM UTC. Meeting notes and recording are available [here](https://github.com/asyncapi/asyncapi/issues/430). \n\nThe next meeting is scheduled for next [Tuesday, 15th of September, 4PM UTC](https://everytimezone.com/s/4347f3c8). \n\nWe work on the agenda for the next meeting [here](https://github.com/asyncapi/asyncapi/issues/435). At the moment, there is nothing in the agenda so you can sneak in your topic easily. \n\nWe host the meeting on [Zoom](https://zoom.us/j/165106914). Do not forget about future meetings and always have up to date invitations in your calendar by adding your email to [this](https://groups.google.com/forum/#!forum/asyncapi-users) mailing list.\n\n## Curated Content\n\n- [Microcks 1.0.0 release with AsyncAPI support](https://medium.com/microcksio/microcks-1-0-0-release-5a5d0dbaf212) by [Laurent Broudoux](https://twitter.com/lbroudoux)\n- [Event-Streaming: An Additional Architectural Style to Supplement API Design](https://www.asyncapi.com/blog/event-streaming-an-additional-architectural-style-to-suplement-api-design/) by [James Higginbotham](https://twitter.com/launchany)\n- [Choosing Between Web APIs and Message Streaming](https://www.asyncapi.com/blog/choosing_between_web_apis_and_message_streaming/) by [James Higginbotham](https://twitter.com/launchany)\n",
    "toc": [
      {
        "content": "Template for templates development",
        "slug": "template-for-templates-development",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Avro 1.8.2 support",
        "slug": "avro-182-support",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Parser v1.0.0-rc.4",
        "slug": "parser-v100-rc4",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "React component improvements",
        "slug": "react-component-improvements",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "The Highlight of Interesting Discussions",
        "slug": "the-highlight-of-interesting-discussions",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Proposal for more formal examples",
        "slug": "proposal-for-more-formal-examples",
        "lvl": 3,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Native support for projects like CloudEvents",
        "slug": "native-support-for-projects-like-cloudevents",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "AsyncAPI Special Interest Group (SIG) open meeting",
        "slug": "asyncapi-special-interest-group-sig-open-meeting",
        "lvl": 2,
        "i": 7,
        "seen": 0
      },
      {
        "content": "Curated Content",
        "slug": "curated-content",
        "lvl": 2,
        "i": 8,
        "seen": 0
      }
    ],
    "slug": "/blog/status-update-37-20",
    "filePath": "pages/blog/status-update-37-20.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Initiative Status Update (week 33, 2020)",
      "date": "2020-08-12T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/status-update-33-robots.webp",
      "weight": 10,
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "readingTime": 3,
      "excerpt": "Parser First Release Candidate is Alive\nSince the last update, we jumped from release 0.28.0 to 0.33.1. In the last two weeks we fixed a few bugs, in the parser and in the AsyncAPI JSON Schema that th"
    },
    "content": "\n## Parser First Release Candidate is Alive\n\nSince the last update, we jumped from release 0.28.0 to 0.33.1. In the last two weeks we fixed a few bugs, in the parser and in the [AsyncAPI JSON Schema](https://github.com/asyncapi/asyncapi/blob/master/versions/2.0.0/schema.json) that the parser is using for most of the validations. In case you have a Node.js application, you can also easily access the schema through [a dedicated dependency](https://github.com/asyncapi/asyncapi-node). It was important not only to fix all those bugs but also to stop relying on our fork of the [json-schema-ref-parser](https://github.com/APIDevTools/json-schema-ref-parser). Now we use the latest version of the upstream so it will be easier to bump into the latest versions. \n\nBecause of all those recent fixes, now was the moment to release our first release candidate for the parser. Give it a try and let us know what is missing!\n\n\n## Generator release candidate\n\nWe just released another release candidate for the [Generator](https://github.com/asyncapi/generator/releases). The only new thing is the latest Parser release candidate to make it available to a broader audience. Say hello the release candidate number 8. Any bets we won’t go higher than 10?\n\n## AsyncAPI React Improvements\n\nOur React component for rendering AsyncAPI files on a client-side has some improvements:\n\n- [Regex pattern of a given property is not displayed](https://github.com/asyncapi/asyncapi-react/pull/115)\n- [Displayed information that payload can or cannot have additional properties](https://github.com/asyncapi/asyncapi-react/pull/118)\n\nThis component also uses the latest parser release candidate. Try it out with [this](https://asyncapi.github.io/asyncapi-react/) preview.\n\n## The Highlight of Interesting Discussions\n\n### HTML Generator vs React Component aka How to Stay DRY\n\nAt the moment, AsyncAPI organization has two components for rendering HTML out of the AsyncAPI document:\n\n- [HTML Template](https://github.com/asyncapi/html-template) is based on the [Generator](https://github.com/asyncapi/generator) and therefore, can be used only on a server.  You can use it through its CLI in your CI/CD pipelines or host them as a Node.js application,\n- [AsyncAPI React](https://github.com/asyncapi/asyncapi-react/) is a component that can be used in a client-side application without an application server. Its limitation at the moment is that it can be used only with React.js as a dependency.\n\nNone of the above solutions is perfect, yet we still have to maintain both to support as many use cases as possible. That is why we want to make a change here and stay DRY. Join the discussion in [this](https://github.com/asyncapi/html-template/issues/51) issue. We would like to replace current HTML template logic entirely and reuse the React component. There are two possible solutions we see:\n\n- We could produce a kind of a bundle that would contain the React component, and there would be a simple index.html that would use it.\n- We could try the approach of projects like Gatsby or Next.js that already use React to generate static sites.\n\n## AsyncAPI Special Interest Group (SIG) open meeting\n\nThe last meeting was canceled. It felt like the center of the holiday season.\n\nThe next meeting is scheduled for next [Tuesday, 18th of August, 4PM UTC](https://everytimezone.com/s/48cdc0da). \n\nWe work on the agenda for the next meeting [here](https://github.com/asyncapi/asyncapi/issues/425). At the moment, there is nothing in the agenda so you can sneak in your topic easily. \n\nWe host the meeting on [Zoom](https://zoom.us/j/165106914). Do not forget about future meetings and always have up to date invitations in your calendar by adding your email to [this](https://groups.google.com/forum/#!forum/asyncapi-users) mailing list.\n\n## Curated Content\n\n- [How CloudEvents and AsyncAPI can help enable Event Driven Architecture](https://www.linkedin.com/pulse/how-cloudevents-asyncapi-can-help-enable-event-driven-paul-taylor/) - by [Paul Taylor](https://www.linkedin.com/in/paultay/)\n- [OpenAPI is the HTTP Binding in AsyncAPI](http://apievangelist.com/2020/07/20/openapi-is-the-http-binding-in-asyncapi/) - by [Kin Lane](https://twitter.com/kinlane)\n- [Avro Schema Parser and others in AsyncAPI Initiative Status Update (week 31, 2020)](https://www.asyncapi.com/blog/status-update-31-20/) - our last update where we discuss Avro schema parser.\n",
    "toc": [
      {
        "content": "Parser First Release Candidate is Alive",
        "slug": "parser-first-release-candidate-is-alive",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Generator release candidate",
        "slug": "generator-release-candidate",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "AsyncAPI React Improvements",
        "slug": "asyncapi-react-improvements",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "The Highlight of Interesting Discussions",
        "slug": "the-highlight-of-interesting-discussions",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "HTML Generator vs React Component aka How to Stay DRY",
        "slug": "html-generator-vs-react-component-aka-how-to-stay-dry",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "AsyncAPI Special Interest Group (SIG) open meeting",
        "slug": "asyncapi-special-interest-group-sig-open-meeting",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Curated Content",
        "slug": "curated-content",
        "lvl": 2,
        "i": 6,
        "seen": 0
      }
    ],
    "slug": "/blog/status-update-33-20",
    "filePath": "pages/blog/status-update-33-20.md"
  },
  {
    "meta": {
      "title": "Avro Schema Parser and others in AsyncAPI Initiative Status Update (week 31, 2020)",
      "date": "2020-07-30T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/asyncapi-avro.webp",
      "weight": 10,
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "readingTime": 5,
      "excerpt": "Avro Schema Parser\nShort Intro to Schema Types in AsyncAPI\nThere are many different schema formats that one might use to describe the message payload. Not everyone uses JSON Schema. There are multiple"
    },
    "content": "\n## Avro Schema Parser\n\n### Short Intro to Schema Types in AsyncAPI\n\nThere are many different schema formats that one might use to describe the message payload. Not everyone uses JSON Schema. There are multiple formats out there, like RAML 1.0 Data Types, Avro, or even OpenAPI 3.0. When you write your AsyncAPI file, you should not manually convert schemas that you already store somewhere in a format different from AsyncAPI Schema. The best practice is to reuse existing schemas by referring to them in your AsyncAPI file and making sure that the Message object has information about the schema format within the schemaFormat parameter. \n\nAsyncAPI [lists schema types](https://www.asyncapi.com/docs/specifications/2.0.0/#messageObjectSchemaFormatTable) that are a MUST but is not limited to this list only. RAML Data Types is not a MUST HAVE, yet we already have a custom parser for it.\n\nFrom the AsyncAPI tooling perspective, we have a [basic JavaScript Parser](https://github.com/asyncapi/parser-js/) capable of parsing schema of the payload provided with AsyncAPI schema format or JSON schema format. Other schema parsers are plugins that you can register with a parser, like [OpenAPI 3.0](https://github.com/asyncapi/openapi-schema-parser) or [RAML 1.0 Data Types](https://github.com/asyncapi/raml-dt-schema-parser). You could provide such plugins as well for your custom formats.\n\n### Avro Parser\n\nThe 3rd plugin that we now officially support is related to Avro schema type. The first minor version is already out there, and you can give it a try, even if your schemas are in the Confluent Schema Registry. Have a look at the docs of [the Avro schema parser](https://github.com/asyncapi/avro-schema-parser). The Avro parser is also part of the latest release candidate of [the Generator](https://github.com/asyncapi/generator/). Please help us make it work for you.\n\n## Circular References in AsyncAPI\n\nNow JavaScript Parser can handle circular references that you might have in your AsyncAPI files. The current implementation fully dereferences circular references, and you cannot change this behavior. We also extended the API to help you out to deal with circular references:\n\n- The core AsyncAPI model now contains the hasCircular() function that you can use to determine at the very beginning if a given AsyncAPI document contains some circular references or not. An example use case for it is to throw a proper error message to the user with a clear message that circular references are not supported by your tool at the moment,\n- The Schema model contains isCircular() function to check if a given schema is circular, so you do not have to detect it on your own and adequately react\n\nHave a look at [this](https://github.com/asyncapi/parser-js/pull/94/files) pull request for implementation details. The work is still in progress as nice features in the Parser do not mean now all the Generator’s templates will support it. Have a look at [this](https://github.com/asyncapi/parser-js/issues/83#issuecomment-659958312) comment if you need more details.\n\n## TypeScript Support in Parser\n\nSince Parser 0.27 we will now always generate [TypeScript types](https://github.com/asyncapi/parser-js/blob/master/types.d.ts) to make it much easier for TypeScript developers to use Parser in their tools.\n\n## Generator Release Candidate 7 is out\n\nWe just released another release candidate that contains a lot of improvements that we added to the Parser. It also includes the above mentioned `avro-schema-parser` so it is easier for you to test it out. Give it a try.\n\n## The Highlight of Interesting Discussions\n\n### Publish vs Subscribe Discussion Continues\n\nWe noticed that people that interact with AsyncAPI for the first time are confused about the meaning of those two words, publish and subscribe. Without going much into detail and oversimplifying things, we can say that this is the part of the community that considers using AsyncAPI to describe their internal broker-centric architecture. In such cases, you want to describe the application's behavior and not what others can do with it. You want to use the Publish verb to specify that your application publishes to a given channel. What if your application is exposed to the outside world where others can interact with it? You want Publish to mean something different, like it is now, that it means your application is subscribed to a given channel, so that you can publish to it, and the application will receive a message. \n\nEvent-driven architectures are complex beasts with many patterns, and we should try to make AsyncAPI a single home for all of them. Please engage in this discussion, share your thoughts, and help us out to find the best solution:\n\n- [Proposal](https://github.com/asyncapi/asyncapi/issues/390) to solve the above challenge with a view property that will not require 3.0 release. There is also an idea to introduce more verbs.\n- [Recording](https://www.youtube.com/watch?v=U6h7LwdEr0w) of the last open SIG meeting where there was a discussion about publish/subscribe confusion.\n\n## AsyncAPI Special Interest Group (SIG) open meeting\n\nThe last meeting took place on Tuesday, 21st of July, 4PM UTC. Meeting notes and recording are available [here](https://github.com/asyncapi/asyncapi/issues/404). \n\nThe next meeting is scheduled for next [Tuesday, 4th of August, 8AM UTC](https://everytimezone.com/s/6df9fcca). \n\nWe work on the agenda for the next meeting [here](https://github.com/asyncapi/asyncapi/issues/417). At the moment, there is nothing in the agenda so you can sneak in your topic easily. \n\nWe host the meeting on [Zoom](https://zoom.us/j/165106914). Do not forget about future meetings and always have up to date invitations in your calendar by adding your email to [this](https://groups.google.com/forum/#!forum/asyncapi-users) mailing list.\n\n## Curated Content\n\n- [Pulsar vs. Kafka — Part 1 — A More Accurate Perspective on Performance, Architecture, and Features](https://streamnative.io/blog/tech/pulsar-vs-kafka-part-1) - [StreamNative](https://streamnative.io/) view on Apache Pulsar vs Apache Kafka\n- [Kafka vs. Pulsar vs. RabbitMQ: Performance, Architecture, and Features Compared](https://www.confluent.io/kafka-vs-pulsar/) - [Confluent](https://www.confluent.io/) view on Apache Kafka vs Apache Pulsar\n- [How to Write Your First AsyncAPI Specification](https://nordicapis.com/how-to-write-your-first-asyncapi-specification/) - by [Thomas Bush](https://nordicapis.com/author/thomas_bush/)\n",
    "toc": [
      {
        "content": "Avro Schema Parser",
        "slug": "avro-schema-parser",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Short Intro to Schema Types in AsyncAPI",
        "slug": "short-intro-to-schema-types-in-asyncapi",
        "lvl": 3,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Avro Parser",
        "slug": "avro-parser",
        "lvl": 3,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Circular References in AsyncAPI",
        "slug": "circular-references-in-asyncapi",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "TypeScript Support in Parser",
        "slug": "typescript-support-in-parser",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Generator Release Candidate 7 is out",
        "slug": "generator-release-candidate-7-is-out",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "The Highlight of Interesting Discussions",
        "slug": "the-highlight-of-interesting-discussions",
        "lvl": 2,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Publish vs Subscribe Discussion Continues",
        "slug": "publish-vs-subscribe-discussion-continues",
        "lvl": 3,
        "i": 7,
        "seen": 0
      },
      {
        "content": "AsyncAPI Special Interest Group (SIG) open meeting",
        "slug": "asyncapi-special-interest-group-sig-open-meeting",
        "lvl": 2,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Curated Content",
        "slug": "curated-content",
        "lvl": 2,
        "i": 9,
        "seen": 0
      }
    ],
    "slug": "/blog/status-update-31-20",
    "filePath": "pages/blog/status-update-31-20.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Initiative Status Update (week 29, 2020)",
      "date": "2020-07-14T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/asyncapi-sonarcloud.webp",
      "weight": 10,
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "readingTime": 4,
      "excerpt": "Increasing the quality of tools with SonarCloud\nWe enabled SonarCloud for the most critical AsyncAPI tools that are reaching or already reached 1.0.0 release. Luckily this amazing software is availabl"
    },
    "content": "\n## Increasing the quality of tools with SonarCloud\n\nWe enabled [SonarCloud](https://sonarcloud.io) for the most critical AsyncAPI tools that are reaching or already reached 1.0.0 release. Luckily this amazing software is available for free for open-source projects.\n\n1.0.0 release is something serious, and we wanted to make sure that we have an automated way of checking the code quality and security. Now every pull request is validated for the following projects:\n\n- Generator\n- Parser\n- Custom schema parsers for OpenAPI schema and RAML data types\n\nThe quality of those projects is visible [here](https://sonarcloud.io/organizations/asyncapi/projects). We additionally validate code with [ESLint plugin from SonarCloud](https://github.com/SonarSource/eslint-plugin-sonarjs). \n\nWith the Parser we went even one step further, and we now statically check the security of the code also with the [ESLint security plugin](https://github.com/nodesecurity/eslint-plugin-security).\n\nLooking at the quality of SonarCloud we will roll it out to the rest of the project under AsyncAPI GitHub organization.\n\n## Parser 1.0.0 right behind the corner\n\nRecent releases in the JavaScript Parser, brought many new features to the parser:\n\n- Server variables validation. Parser throws an error if you forgot to specify a Variable object for a variable used in the server URL like `url: api.streetlights.smartylighting.com:{port}` where `{port}` is a variable.\n- Channel parameters validation. Parser throws an error if you forgot to specify a Parameter object for a parameter used in the channel name like `event/{streetlightId}/lighting/measured` where `{streetlightId}` is a parameter.\n- We added missing validation of the payload provided with the AsyncAPI schema format. In the past, when you provided a message payload information in Components object, it was correctly validated, but not if you provided this information directly under the channel.\n- Parser throws an error if OperationId is duplicated across the whole AsyncAPI document. This is an essential property for code generation, and specification is precise that duplicates of this information are not allowed.\n- Parser throws an error if you provided server security information in a wrong format and has a corresponding Security Schema object.\n\nFor today, except for [handling circular references issue](https://www.asyncapi.com/blog/status-update-27-20/#circular-references) I mentioned in my last update, there are no other serious tasks we want to solve before the 1.0.0 release. Keep your fingers crossed.\n\n## The Highlight of Interesting Discussions\n\nThere are some interesting discussions/topics where it would be great to hear your opinion.\n\n### Add view property in the specification\n\nThis proposal addresses the confusion around the semantics of Publish and Subscribe channel operations. At the moment, the specification should be used to describe how users can interact with an application. In other words, if the AsyncAPI document of the application says that it **has a publish channel**, it means that this application is **subscribed to this channel**, and application users can publish an event to this application by publishing an event to this channel. Community proposal behind the `view` property is to enable you to decide if you want the specification to tell you how you can interact with an application, or how the application behaves. You could say that publish means that the application published events to the channel and not the other way around. \n\nPlease have a look at [the corresponding issue](https://github.com/asyncapi/asyncapi/issues/390) and share your opinion.\n\n### Allow $schema property in the specification\n\nWith `$schema` property you can specify a location of the JSON Schema file and most of the IDEs will make your life much easier by adding auto-completion and other super useful functionalities. In the issue we discuss how we could allow maybe not only `$schema` but any property starting with `$`, and also we talk about the opportunity to measure the adoption of the specification. \n\nPlease have a look at [the corresponding issue](https://github.com/asyncapi/asyncapi/issues/377) and share your opinion.\n\n## AsyncAPI Special Interest Group (SIG) open meeting\n\nThe last meeting took place on Tuesday, 7th of July, 8AM UTC. Meeting notes and recording are available [here](https://github.com/asyncapi/asyncapi/issues/401).\n\nThe next meeting is scheduled for next Tuesday, 21st of July, 4PM UTC. \n\nWe work on the agenda for the next meeting [here](https://github.com/asyncapi/asyncapi/issues/404). At the moment, there is nothing in the agenda so you can sneak in your topic easily. \n\nWe host the meeting on [Zoom](https://zoom.us/j/165106914). Do not forget about future meetings and always have up to date invitations in your calendar by adding your email to [this](https://groups.google.com/forum/#!forum/asyncapi-users) mailing list.\n\n## Curated Content\n\nSome articles you might want to read to learn something new:\n\n- [Event-Streaming: An Additional Architectural Style to Supplement API Design](https://www.asyncapi.com/blog/event-streaming-an-additional-architectural-style-to-suplement-api-design/) by [James Higginbotham](https://twitter.com/launchany)\n- [How to mitigate unhappy paths with an event-driven architecture at scale](https://blogs.mulesoft.com/dev/design-dev/event-driven-architecture-for-unhappy-paths/) by Paul Taylor\n- [Understanding Event Driven Architecture](https://hackernoon.com/understanding-event-driven-architecture-ub1k3umo) by [Craig Godden-Payne](https://twitter.com/DigitalBeardy)\n",
    "toc": [
      {
        "content": "Increasing the quality of tools with SonarCloud",
        "slug": "increasing-the-quality-of-tools-with-sonarcloud",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Parser 1.0.0 right behind the corner",
        "slug": "parser-100-right-behind-the-corner",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "The Highlight of Interesting Discussions",
        "slug": "the-highlight-of-interesting-discussions",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Add view property in the specification",
        "slug": "add-view-property-in-the-specification",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Allow $schema property in the specification",
        "slug": "allow-schema-property-in-the-specification",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "AsyncAPI Special Interest Group (SIG) open meeting",
        "slug": "asyncapi-special-interest-group-sig-open-meeting",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Curated Content",
        "slug": "curated-content",
        "lvl": 2,
        "i": 6,
        "seen": 0
      }
    ],
    "slug": "/blog/status-update-29-20",
    "filePath": "pages/blog/status-update-29-20.md"
  },
  {
    "meta": {
      "title": "Event-Streaming: An Additional Architectural Style to Supplement API Design",
      "date": "2020-07-07T08:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "REST APIs",
        "Streaming",
        "EDA"
      ],
      "cover": "/img/posts/event-streaming-an-additional-architectural-style-to-suplement-api-design/cover.webp",
      "authors": [
        {
          "name": "James Higginbotham",
          "photo": "/img/avatars/jhigginbotham.webp",
          "link": "https://twitter.com/launchany",
          "byline": "AsyncAPI Contributor"
        }
      ],
      "readingTime": 6,
      "excerpt": "This post originally appeared on Capital One Tech\n\nThe growth and adoption of web-based APIs is key to the transformational technology journey of any enterprise. Those APIs, whether they are RESTful o"
    },
    "content": "\n> This post originally appeared on [Capital One Tech](https://medium.com/capital-one-tech/event-streaming-an-additional-architectural-style-to-supplement-api-design-703c4f801722)\n\nThe growth and adoption of web-based APIs is key to the transformational technology journey of any enterprise. Those APIs, whether they are RESTful or not, remain synchronous. They, like the web, utilize the pattern of HTTP to implement a request-response interaction approach.\n\nTo illustrate, assume we have a project management API with the following interactions:\n\n1. Create a project (e.g. POST /projects)\n1. Create a new task (e.g. POST /projects/{projectId}/tasks)\n1. Assign the task to someone on our team (e.g. POST /tasks/{taskId}/assignees)\n1. The assignee marks the task as complete (e.g. PUT /tasks/{taskId})\n\nAn API following this design works if design of the user interface closely mirrors those endpoints. But suppose an additional application requirement is to ‘automatically’ update a task’s status when marked complete by another user. With a request/response web-API, an option is to incessantly poll a status API on the chance a status might have changed. This is both cumbersome and error-prone.\nInstead of polling, we can introduce an __event-driven architecture__.\n\n## Introduction to Event-Driven Architecture\n\nIn an event-driven architecture (or EDA), an application is composed of independent components that react to events published by other components. EDA is popular for distributed applications, as new components may be introduced into a solution to solve emerging problems — without the knowledge of previously developed components. Message brokers are used as an intermediary for communication, producing a loosely coupled design by preventing components from directly communicating with one another.\n\nIf you are familiar with service-oriented architecture (SOA), you have experienced EDA. Most service-oriented architectures used an enterprise service bus (ESB) for service communication rather than a message broker. Events were published to the ESB, where they were then routed to other services to integrate two or more software systems. However, ESBs proved problematic as they were used as “integration glue”, causing integration code to become scattered across services, apps, and the ESB; fragile systems were created. This fragility produced a greater need for coordination between teams, slowing software delivery.\n\n## The Emergence of a Microservice and Event-Driven Architecture\n\nTo overcome this increased coordination, the microservice architecture was introduced as a replacement for traditional SOA. This newer distributed architecture, built on APIs and microservices, encourages “dumb pipes, smart endpoints.” Integration logic is pushed to the consumers and producers. Message brokers, rather than ESBs, are used for message routing, not integration logic. Services and APIs talk to one another while hiding implementation details. This loose coupling makes software more resilient to evolution as new requirements emerge.\n\nAs enterprises shift to APIs backed by a microservice architecture, the number of published events has grown considerably. Message brokers are typically transactional in nature, ensuring once-and-only-once delivery of messages. While useful for traditional software development, the transactional nature of message brokers limits the scalability of service communication.\n\nDistributed streaming data platforms, such as Apache Kafka, now offer enterprises higher throughput than traditional message brokers. Kafka removes the need for transactional messaging found in message brokers, opting instead for turning events into message streams. These streams are accessible by any authorized subscriber and may be accessed real-time or processed sequentially from a predetermined location or at the start of the stream.\n\n## API Design with Event Streaming\n\nEvent streams help software extend beyond the request-response approach common to web API styles such as REST, GraphQL, and gRPC. Software can communicate bi-directionally, removing the need for API consumers to continually poll for state changes. Instead, APIs publish events to an event stream for notification of data changes or important business events to any number of subscribed services for further processing.\n\nLet’s revisit our previous example. We needed to solve two separate requirements:\n\n1. Notification when a task is marked as completed. Our only option without a message-driven architecture is to require interested parties to constantly make API calls to see if the task has been completed (aka polling)\n1. Alerting a project owner when a task has been modified or marked as completed. Our only option is to mix our user interface concerns with our API by making the API send an email. The API is no longer responsible for managing projects and tasks — it is now responsible for the content and look-and-feel for email alerts\n\nIf we introduce a message-driven architecture to our solution, we can develop an API that delivers project and task resources that offer the necessary capabilities (create, read, update, delete, and mark as complete). Our API doesn’t need to know about how the task completion event notification will be used, including that an email will be sent. All it needs to do is publish event messages when those events occur and allow other services to take action as appropriate. Events this API may publish include:\n\n![Example of API events](/img/posts/event-streaming-an-additional-architectural-style-to-suplement-api-design/event-examples.webp \"Example of API events\")\n\nInterested parties can then subscribe to the event(s) they are interested in and safely ignore the rest. In our example, we may end up with three components:\n\n1. __Projects API__ — Manages the Projects and Project Tasks resources via a REST-based API. The API may be comprised of one or more microservices that implement the capabilities offered by the REST API. When any event, from the list in the table above, occurs then the API publishes an event into the appropriate message stream for consumption by event subscribers\n1. __Task Completed Email Microservice__ — Subscribes to the Task.Completed event, notifying project manager(s) via email when any task has been marked as completed\n1. __Task Modified Email Microservice__ — Subscribes to the Task.Updated event, notifying all team members via email when any task has been edited\n\nThe API has no awareness of the two microservices subscribed to the specific events; it just publishes the events to the appropriate message stream. The solution is considered loosely coupled and therefore capable of evolving over time as new requirements emerge, perhaps with new types of notifications (e.g. SMS, web dashboard alerts) or integrations (e.g. synching to JIRA).\n\n## Conclusion\n\nThe demand for more robust methods of software communication is pushing the limits of today’s interface solutions. Request/response-based APIs are essential. However, today’s technical problems are now demanding event-driven support — in addition to request/response — to improve an API’s capability offerings.\n\nAs API designers, we must strive to use all available tools to offer a better developer experience. As you enhance your existing APIs and new APIs emerge, ask yourself:\n\n1. How can my solution architecture be improved by moving beyond standard REST APIs and into a loosely-coupled event-driven architecture?\n1. What events should my API publish that would benefit API consumers?\n1. How will my API consumers benefit from the addition of these events and how do they take advantage of them?\n\nLet’s shift our approach from strictly request-response to thinking in terms of how our APIs can not only offer endpoints for requests, but events that enable the API to push to other services. The result will be increased innovation and more transformative APIs both within and across our LOBs.\n\n",
    "toc": [
      {
        "content": "Introduction to Event-Driven Architecture",
        "slug": "introduction-to-event-driven-architecture",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "The Emergence of a Microservice and Event-Driven Architecture",
        "slug": "the-emergence-of-a-microservice-and-event-driven-architecture",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "API Design with Event Streaming",
        "slug": "api-design-with-event-streaming",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Conclusion",
        "slug": "conclusion",
        "lvl": 2,
        "i": 3,
        "seen": 0
      }
    ],
    "slug": "/blog/event-streaming-an-additional-architectural-style-to-suplement-api-design",
    "filePath": "pages/blog/event-streaming-an-additional-architectural-style-to-suplement-api-design.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Initiative Status Update (week 27, 2020)",
      "date": "2020-06-30T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/radar.webp",
      "weight": 10,
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Community Guardian"
        }
      ],
      "readingTime": 5,
      "excerpt": "AsyncAPI is innovation and you should assess it\nThoughtWorks and InfoQ clearly point out this is the best moment to have a closer look at AsyncAPI specification. Specification brings standardization i"
    },
    "content": "\n## AsyncAPI is innovation and you should assess it\n\nThoughtWorks and InfoQ clearly point out this is the best moment to have a closer look at AsyncAPI specification. Specification brings standardization into event-driven architectures and makes space for building great tools to solve problems like testing, documentation, code generation, and many others. Read more:\n\n- [ThoughtWorks Technology Radar - Tools](https://www.thoughtworks.com/radar/tools?blipid=202005046)\n- [Software Architecture and Design InfoQ Trends Report—April 2020](https://www.infoq.com/articles/architecture-trends-2020/)\n\n## Generator and Parser 1.0 releases\n\nWe are going in the right direction with the first major releases for [the Generator](https://github.com/asyncapi/generator/) and [the Parser](https://github.com/asyncapi/parser-js/). The last [release candidate](https://github.com/asyncapi/generator/releases/tag/v1.0.0-rc.4) we produced for the Generator is pretty much stable, and all tasks were completed. We also tried it in our [GitHub Action](https://github.com/asyncapi/github-action-for-generator/pull/8) and [AsyncAPI Hub](https://hub.asyncapi.io), and it works like a charm.\n\n> Then why are you not promoting the last release candidate to 1.0.0?\n\nGood question, I’m glad you asked :) \n\nGenerator depends a lot on the Parser. Parser did not reach a major release yet. As you may have guessed, I'm now focused on the Parser 1.0.0 release, and the issues we want to complete before the release are listed in [this milestone](https://github.com/asyncapi/parser-js/milestone/3). The good news is that most of the issues are either in progress, and some have pull requests already opened.\n\n> What’s the plan then?\n\nRelease the Parser with 1.0.0 and then Generator 1.0.0 as we already know that Parser 1.0.0 introduces some breaking changes.\n\n> It is taking way too long.\n\nFair point. We just need more hands on the board. If you are a JavaScript developer and you thought about joining AsyncAPI as a contributor, but you never knew the right moment, now is the time. I'm now entirely focused on the Parser and would be happy to onboard some more people. Just let me know, and I'll onboard you.\n\n## New Website Right Behind The Corner\n\nThe time has come to do some refreshment of the AsyncAPI website. We also change the engine used to generate the website, from Hugo to Next.js. Have a look at [the preview](https://deploy-preview-108--asyncapi-website.netlify.app/) of the work and feel free to share your feedback to Fran in [this pull request](https://github.com/asyncapi/website/pull/108). Greatest things you can see there:\n\n- Better exposure of community-related channels on the landing page\n- More prominent promotion of AsyncAPI maintained tools, like [the Generator](https://deploy-preview-108--asyncapi-website.netlify.app/generator)\n- A more unobstructed view of the [Blog](https://deploy-preview-108--asyncapi-website.netlify.app/blog) section\n- Right-hand side page navigation with scroll spy on [documentation view](https://deploy-preview-108--asyncapi-website.netlify.app/docs/specifications/2.0.0).\n\nThere are many other significant changes. You'll see them immediately on the main landing page.\n\n## The Highlight of Interesting Discussions\n\nThere are some interesting discussions/topics where it would be great to hear your opinion.\n\n### Circular References\n\nHow would you expect those are handled by the Parser and also by the Generator? Should such references be ignored or resolved, and if resolved, then how? Should generated docs indicate circular reference or ignore this info as irrelevant? These are all the questions we face now, and it would be awesome to get your input [here](https://github.com/asyncapi/parser-js/issues/83).\n\n### React Wrapper Redoc style\n\nAsyncAPI Initiative provides two ways of generating docs from AsyncAPI specification:\n\n- [HTML template](https://github.com/asyncapi/html-template) for the AsyncAPI generator. The classical server-side generation you perform in your CI pipelines or in an application with Node.js server.\n- [React component](https://github.com/asyncapi/asyncapi-react/) that you can use for dynamic docs rendering client-side. This one is great, but only if you want to use React in your application.\n\nWe are thinking about how we could consolidate both into one project that is maintained just once. In the meantime, the community created [this wrapper](https://github.com/jfveronelli/instant-asyncapi-doc) for our React component inspired by ReDoc approach to OpenAPI. It would be great to know what you think about this and what are your expectations toward AsyncAPI Initiative. Join the [discussion](https://github.com/asyncapi/asyncapi/issues/391).\n\n### React for Template Engine for the Generator\n\nWe are getting a bit tired of Nunjucks and how hard it is to debug and read the templates. Fran came up with an idea to use React as a template engine for our docs and code generator. He got inspired by the emerging popularity of solutions like Gatsby or Next.js (supporting pre-rendering of React components). Before you say out loud \"you are crazy\" join the discussion [here](https://github.com/asyncapi/generator/issues/377).\n\n## AsyncAPI Special Interest Group (SIG) open meeting\n\nThe last meeting took place on Tuesday, 23rd of June, 4PM UTC. Meeting notes are available [here](https://github.com/asyncapi/asyncapi/issues/394).\n\n{{%youtube id=\"LDanOihP9i4\"%}}\n\nThe next meeting is scheduled for next Tuesday, 7th of July, 8AM UTC. \n\nThe agenda for the meeting is built [here](https://github.com/asyncapi/asyncapi/issues/401). There is nothing on the agenda, so you can easily sneak your topic in. \n\nThe meeting is hosted on [Zoom](https://zoom.us/j/165106914). Do not forget about future meetings, and always have up to date invitations in your calendar. Add your email to [this](https://groups.google.com/forum/#!forum/asyncapi-users) mailing list.\n\n## Curated Content\n\nSome articles you might want to read to learn something new:\n\n- [Choosing Between Web APIs and Message Streaming](https://www.asyncapi.com/blog/choosing_between_web_apis_and_message_streaming/) by [James Higginbotham](https://twitter.com/launchany)\n- [How event-driven architecture solves modern web app problems](https://stackoverflow.blog/2020/03/16/how-event-driven-architecture-solves-modern-web-app-problems/) by [Bogdan Sucaciu](https://twitter.com/BSucaciu)\n- [WebSockets for fun and profit](https://stackoverflow.blog/2019/12/18/websockets-for-fun-and-profit/) by [Max Pekarsky](https://twitter.com/maxverse)\n",
    "toc": [
      {
        "content": "AsyncAPI is innovation and you should assess it",
        "slug": "asyncapi-is-innovation-and-you-should-assess-it",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Generator and Parser 1.0 releases",
        "slug": "generator-and-parser-10-releases",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "New Website Right Behind The Corner",
        "slug": "new-website-right-behind-the-corner",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "The Highlight of Interesting Discussions",
        "slug": "the-highlight-of-interesting-discussions",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Circular References",
        "slug": "circular-references",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "React Wrapper Redoc style",
        "slug": "react-wrapper-redoc-style",
        "lvl": 3,
        "i": 5,
        "seen": 0
      },
      {
        "content": "React for Template Engine for the Generator",
        "slug": "react-for-template-engine-for-the-generator",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "AsyncAPI Special Interest Group (SIG) open meeting",
        "slug": "asyncapi-special-interest-group-sig-open-meeting",
        "lvl": 2,
        "i": 7,
        "seen": 0
      },
      {
        "content": "Curated Content",
        "slug": "curated-content",
        "lvl": 2,
        "i": 8,
        "seen": 0
      }
    ],
    "slug": "/blog/status-update-27-20",
    "filePath": "pages/blog/status-update-27-20.md"
  },
  {
    "meta": {
      "title": "Choosing Between Web APIs and Message Streaming",
      "date": "2020-06-23T06:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "REST APIs",
        "Streaming",
        "EDA"
      ],
      "cover": "/img/posts/choosing_between_web_apis_and_message_streaming/cover.webp",
      "authors": [
        {
          "name": "James Higginbotham",
          "photo": "/img/avatars/jhigginbotham.webp",
          "link": "https://twitter.com/launchany",
          "byline": "AsyncAPI Contributor"
        }
      ],
      "excerpt": "When faced with a variety of options, how are developers building APIs supposed to know which is the right one for their solution? In this article, I’m going to outline the common characteristics for both REST APIs and message streaming so developers can better understand when (and when not) to use each one.",
      "readingTime": 7
    },
    "content": "\n> This post originally appeared on [Capital One Tech](https://medium.com/capital-one-tech/choosing-between-rest-web-apis-and-message-streaming-8e2f4813a058)\n\nWhen faced with a variety of options, how are developers building APIs supposed to know which is the right one for their solution? In this article, I’m going to outline the common characteristics for both REST APIs and message streaming so developers can better understand when (and when not) to use each one.\n\n## Characteristics of REST-Based Web APIs\n\nREST-based web APIs create a conversation between a client (the API consumer) and an API server (the backend). When we build REST-based APIs within Capital One, we use HTTP as our protocol. Our designs depend heavily on HTTP, from the methods (e.g. GET, POST, PUT, PATCH, DELETE) to the headers that help us communicate between client and server (e.g. Authorization, Accept, Content-Type).\n\n![Request/response client-server list conversation](/img/posts/choosing_between_web_apis_and_message_streaming/convo-1.webp)\n\n```\nGET /projects\nAccept: application/json\n\n200 OK\nContent-Type: application/json\n \n [\n  { \"projectId\":\"...\", \"name\":\"...\" },\n  { \"projectId\":\"...\", \"name\":\"...\" },\n  { \"projectId\":\"...\", \"name\":\"...\" },\n  ...\n ]\n```\n\n![Request/response client-server create conversation](/img/posts/choosing_between_web_apis_and_message_streaming/convo-2.webp)\n\n```\nPOST/projects\nContent-Type: application/json\n\n{ \"name\":\"...\", ... }\n\n201 Created\nContent-Type: application/json\n \n { \"projectId\":\"...\", \"name\":\"...\", ... }\n\n```\n\nThe client (or API consumer) is the app, which sends a message (i.e. an HTTP request) to the API whenever it needs something. The server then replies with the response, including a status code that indicates if the request was processed successfully (2xx error code), failed due to client error (4xx error code), or failed due to server error (5xx error code). All communication flows from the consumer to the API backend.\n\nWhen we add in hypermedia links, we extend the conversation with some additional information that may be helpful to the client:\n\n![Request/response client-server hypermedia conversation](/img/posts/choosing_between_web_apis_and_message_streaming/convo-3.webp)\n\n```\nGET /projects/12345\nAccept: application/json\n\n200 OK\nContent-Type: application/json\n \n { \n \"name\":\"...\", ...,\n \"_links\": {\n   { \"self\" :\"/projects/1234\" }, \n   { \"related_projects\": [\n     { \"4567\" :\"/projects/4567\" }, \n     { \"8901\" :\"/projects/8901\" }, \n     { \"9012\" :\"/projects/9012\" } \n   ]}, \n   { \"members\": [\n     { \"1\" :\"/users/1\" }, \n     { \"2\" :\"/users/2\" }, \n     { \"3\" :\"/users/3\" }, \n     { \"4\" :\"/users/4\" }, \n     { \"5\" :\"/users/5\" } \n   ]}\n }\n```\n\nREST-based APIs have a specific set of characteristics that are summarized below:\n\n* __Request/response model__ — API consumers send requests to an API server and receive a response.\n* __Pull-based interaction__ — API consumers send an API request when data or functionality is required (e.g. user interface, at a pre-scheduled time).\n* __Synchronous__ — API consumers receive the response after a request is sent.\n* __Multiple content types__ — since REST APIs are built upon HTTP, responses may be JSON, XML, or other content types as necessary to support consumer needs (e.g. CSV, PDF).\n* __Flexible interactions__ — Building upon the available HTTP verbs, consumers may interact with REST-based APIs through resources in a variety of ways: queries/search, creating new resources, modifying existing resources, and deleting resources. We can also build complex workflows by combining these interactions into higher-level processes.\n* __Caching and concurrency protocol support__ — HTTP has caching semantics built-in, allow for caching servers to be placed between the consumer and API server, as well as cache control of responses and eTags for concurrency control to prevent overwriting content.\n* __Internal and external access__ — REST APIs may be restricted for internal use or for external use by partners or public developers.\n\nFor most solutions, offering a REST-based API is a great starting point, allowing any application or automation script to interact with your API over HTTP.\n\n## Characteristics of Message Streaming\n\nUnlike REST APIs, message streaming is better at providing notifications when new messages arrive. Once subscribed, the client will be notified when new messages are available:\n\n![Event-based API subscription](/img/posts/choosing_between_web_apis_and_message_streaming/convo-4.webp)\n\n```\nPOST /subscriptions\nContent-Type: application/json\n\n{ \"callbackUrl\":\"https://my.callback/path\", ... }\n\n201 Created\nContent-Type: application/json\n \n```\n\nNow that the client is subscribed to a topic, it will receive notifications when new messages are available. This may be the result of a REST API processing incoming requests from a web or mobile app, then adding messages into the message stream topic to notify anyone that is interested:\n\n![Event-based API notifications](/img/posts/choosing_between_web_apis_and_message_streaming/convo-5.webp)\n\n```\nPOST https://my.callback/path\n<<project created event>>\n\nPOST https://my.callback/path\n<<project archived event>>\n\nPOST https://my.callback/path\n<<project updated event>>\n```\n\nNotice how our conversation became more interesting. We now can be notified when things change or critical business events occur; without needing to modify and redeploy the API to support a new integration that emerges in the future. This is called loose coupling, and it helps our systems be used in new ways without the originator of the messages even knowing about current and future subscribers.\n\nThose familiar with message brokers will realize that this is familiar. The difference between a message broker and message streaming is that _message streaming allows us to revisit past messages in sequence as well_:\n\n![Streaming API conversation](/img/posts/choosing_between_web_apis_and_message_streaming/convo-6.webp)\n\n```\n<<request last 12 messages from project_messages topic>>\n\n<<retrieve and send last 12 messages from project_messages topic>>\n```\n\nThis feature is useful when we need to go aggregate values or perform a new calculation we previously didn’t realize we needed.\n\nNote — we can’t filter messages or perform other aggregate queries when requesting the messages — only the client can do this after requesting the messages from the topic. REST APIs are better suited for performing ad hoc queries than message streams.\n\nAs you are discovering, message streaming is a different style of interaction than REST-based APIs. Additional characteristics of message streaming are summarized below:\n\n* __Publish/subscribe model__ — Apps or APIs publish messages to a topic which may have zero, one, or many subscribers rather than a request/response model.\n* __Subscriber notification interaction__ — Apps receive notification when a new message is available, such as when data is modified or new data is available.\n* __Asynchronous__ — Unlike REST APIs, apps cannot use message streams to submit a request and receive a response back without complex coordination between parties.\n* __Single content-type__ — At Capital One, our message streaming is built upon Avro, a compact binary format useful for data serialization. Unlike HTTP, Avro doesn’t support other content types (e.g. CSV, PDF).\n* __Replayability__ — At Capital One, our message streaming is built on Kafka, subscribers may revisit and replay previous messages sequentially.\n* __No caching or concurrency protocol support__ — Message streaming doesn’t offer caching semantics, cache-control, or concurrency control between publisher and subscriber.\n* __Internal access only__ — Subscribers must be internal to the organization, unlike HTTP which may be externalized to partner or public consumers.\n\nMessage streaming offers some additional communication options that REST-based APIs do not — push-based notifications when new data or state changes occur, and the option of revisiting past messages in the stream to perform new calculations or re-execute logic that failed previously. When combined together, REST-APIs enable consuming apps to integrate easily with an HTTP API, while message streaming allow consumers to be notified of changes without needing to check with the REST API first. This can be a powerful combination that can satisfy use cases that exist today, while allowing emerging use cases to be handled in the future — all without modifying existing systems to accommodate new solutions.\n\n## Summary\n\nAs you may have realized, choosing between a web API and message streaming isn’t difficult, as long as you understand the characteristics of each one. REST APIs are best suited to request/response interactions where the client application sends a request to the API backend over HTTP. Message streaming is best suited to notification when new data or events occur that you may want to take action upon. Just be sure to match the needs of the consumer with one or more approaches to offer a robust interface to your solution’s capabilities.\n",
    "toc": [
      {
        "content": "Characteristics of REST-Based Web APIs",
        "slug": "characteristics-of-rest-based-web-apis",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Characteristics of Message Streaming",
        "slug": "characteristics-of-message-streaming",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Summary",
        "slug": "summary",
        "lvl": 2,
        "i": 2,
        "seen": 0
      }
    ],
    "slug": "/blog/choosing_between_web_apis_and_message_streaming",
    "filePath": "pages/blog/choosing_between_web_apis_and_message_streaming.md"
  },
  {
    "meta": {
      "type": "Engineering",
      "cover": "/img/posts/asyncapi-codegen_pic-00.webp",
      "title": "AsyncAPI Code Generation: Microservices Using Spring Cloud Stream",
      "date": "2020-06-02T05:00:00.000Z",
      "tags": [
        "Solace",
        "Java",
        "Spring",
        "EDA"
      ],
      "authors": [
        {
          "name": "Marc DiPasquale",
          "photo": "/img/avatars/mdipasquale.webp",
          "link": "https://twitter.com/mrc0113",
          "byline": "Developer Advocate at Solace"
        }
      ],
      "readingTime": 12,
      "excerpt": "Code generation is no simple feat. There are a lot of complexities when it comes to generating useful application code. In this post, I am going to walk you through generating your own microservices u"
    },
    "content": "\nCode generation is no simple feat. There are a lot of complexities when it comes to generating useful application code. In this post, I am going to walk you through generating your own microservices using Spring Cloud Stream and the AsyncAPI Code Generator. These tools should help to simplify things when defining and implementing your asynchronous applications. I explained the same idea in a video you can [watch here](https://www.youtube.com/watch?v=QEDL6AqsaJc), and all of the artifacts are [available in GitHub](https://github.com/Mrc0113/asyncapi-codegen-scst). \n\n> This post [AsyncAPI Code Generation: Microservices Using Spring Cloud Stream](https://solace.com/blog/asyncapi-codegen-microservices-using-spring-cloud-stream/) appeared first on [Solace](https://solace.com).\n\n# AsyncAPI: What Is It?\n\nBefore we dive into code generation let’s start with the basics – what is AsyncAPI? Over the past few years, [AsyncAPI](https://www.asyncapi.com/) has emerged as the industry standard for defining asynchronous, event-driven APIs; you can think of it as OpenAPI for the asynchronous world. It is an open source initiative that provides <u>both</u> a specification to describe and document your asynchronous applications in a machine-readable format, and tooling (such as code generators) to make life easier for developers tasked with implementing them.\n\nI’m not going to go into great detail about the specification, but for context you should know that it defines metadata about your asynchronous API, the channels available for sending/receiving messages, and components – such as schemas – that define the messages that are being exchanged. For more information about the specification you can read about it [here](https://www.asyncapi.com/docs/specifications/2.0.0/).\n\n# Defining the Application That You Want to Develop: The  AsyncAPI Document\n\nThe first step in doing code generation with AsyncAPI is obtaining an AsyncAPI document that defines the application that you want to develop. Per the specification, this document is represented as JSON objects and must conform to the JSON standards. YAML, being a superset of JSON, can also be used. There are two main ways of going about obtaining this document: manually create the document or use an event portal.\n\nIf you decide to manually create the document after familiarizing yourself with the specification, don’t worry – you won’t be starting with a blank slate. The AsyncAPI initiative has provided a handy, interactive tool called the [AsyncAPI Hub](https://hub.asyncapi.io/) to make this easier. On the left side of the Hub you can familiarize yourself with the specification and make changes to a real AsyncAPI document, and as you do so the right side of the screen updates to show how the document is parsed into a more human-readable format.\n\n![asyncapi playground for creating microservices using spring cloud stream](/img/posts/asyncapi-codegen_pic-01.webp)\n\nThe second way is to use an event portal. Solace PubSub+ Event Portal, for example, allows for architects and developers to collaborate using a GUI to design your event-driven architecture. The team would define the applications that exist in the system, as well as the events that are exchanged and the schemas which define them. Having a catalog of well-organized channels and events for reuse will also save you both time and headaches while collaborating, instead of having to comb through a bunch of files in various locations.\n\nOnce the design is in place, PubSub+ Event Portal allows the developer to choose the application they are responsible for developing and download the AsyncAPI document in JSON or YAML.\n\n![pic2](/img/posts/asyncapi-codegen_pic-02.webp)\n\n# Create Event-Driven Microservices Using Spring Cloud Stream Without Learning Messaging APIs\n\nNow that we have our AsyncAPI document that describes our application it’s time to develop the application. The AsyncAPI [Code Generator](https://github.com/asyncapi/generator) supports templates to generate code for a variety of different languages and protocols, but for this example we’re going to use the [Spring Cloud Stream template](https://github.com/asyncapi/java-spring-cloud-stream-template). One should note that the template generates a Maven project.\n\nThe Spring Cloud Stream framework provides an easy way to get started with event-driven microservices by providing binders that allow the developer to create their microservices without having to learn messaging APIs.\n\n### Download and Run the AsyncAPI Generator\n\nThe first step is of course to install the AsyncAPI generator itself. If you have NodeJS installed this takes just one easy `npm` command as seen below. You can find the required versions in the [Code Generator](https://github.com/asyncapi/generator) on github.\n\n```bash\nnpm install -g @asyncapi/generator\n```\n\nOnce you have the generator installed you can run it using the `ag` command. At a minimum you must specify the AsyncAPI document to run it against and the template to use as shown below.\n\n```generator-cli\nag https://raw.githubusercontent.com/asyncapi/asyncapi/2.0.0/examples/2.0.0/streetlights.yml @asyncapi/java-spring-cloud-stream-template\n```\n\nIn most cases you’ll want to take advantage of the parameters and specification extensions that are specified by the template being used. For example, the Spring Cloud Stream template that I’m using in this example allows me to [configure many options](https://github.com/asyncapi/java-spring-cloud-stream-template#configuration-options), including the Spring Cloud Stream binder I want to use – for example, the Solace binder.\n\nOther parameters include:\n\n- Maven information: `artifactId` and `groupId`\n- Java package: `javaPackage`\n- Broker connection Info: `host`, `username`, `password` and `msgVpn`\n\nUsing these options, my `ag` command might look something like this, where `-o` specifies the output directory:\n\n```generator-cli\nag -o ExpenseIntegration -p binder=solace -p view=provider -p actuator=true -p artifactId=ExpenseIntegration -p groupId=acme.rideshare -p javaPackage=acme.rideshare.expense -p host=localhost:55555 -p username=default -p password=default -p msgVpn=default ~/Downloads/ExpenseIntegration.yaml @asyncapi/java-spring-cloud-stream-template\n```\n\nAfter running, the output will look something like this:  \n![pic3](/img/posts/asyncapi-codegen_pic-03.webp)\n\n# Add Your Business Logic\n\nAt this point the generator has created an `ExpenseIntegration` directory that contains the Maven project. We can use the IDE of choice and import the Maven project to add business logic.\n\nAs seen in the image below, once imported, the project looks like a regular Spring Boot Java project with generated classes under the `javaPackage` that was defined earlier and an `application.yml` file for configuration. Generated classes under `javaPackage` include Plain Old Java Objects (POJOs) defined from the schemas in the AsyncAPI document and `Application.java` which contains the actual Spring Cloud Functions where we’ll add our business logic.  \n![pic4](/img/posts/asyncapi-codegen_pic-04.webp)\n\nThe generated POJOs, like `RideReceipt` in the image above, define your data model per the schemas included in the AsyncAPI document. These POJOs contains variables with getters and setters for each attribute defined to allow both for developers to get coding quickly without having to manually create the objects themselves, but also for Spring Cloud Stream to automatically convert messages directly to POJOs.\n\nThen we have the `Application.java` class, which can be renamed using the `javaClass` parameter. The generator will add functions to handle messages delivered on the channels defined in the AsyncAPI document [as described in the template](https://github.com/asyncapi/java-spring-cloud-stream-template#how-it-works).\n\nIn the example below we can see a single `java.util.function.Consumer` bean since our AsyncAPI document describes our application as a subscriber to messages whose payload is defined by the `RideReceipt` schema. Note the comment that states // Add business logic here; this is where the developer can add their business logic.\n\n```java\n@SpringBootApplication\npublic class Application {\n   private static final Logger logger = LoggerFactory.getLogger(Application.class);\n   public static void main(String[] args) {\n      SpringApplication.run(Application.class);\n   }\n\n   @Bean\n   public Consumer<RideReceipt> acmeRideshareBillingReceiptCreated001Consumer() {\n      // Add business logic here.\n      return null;\n   }\n}\n```\n\nYou might say: “Marc, that’s great, but how the heck is that function actually binding to the messaging channels!?” This is where the `application.yml` file comes into play.\n\nThe generated `application.yml` file defines several things as specified in the AsyncAPI document or from the parameters passed into the generator. First, it defines the list of functions it wants Spring Cloud Stream aware of under `spring.cloud.stream.function.definition`. Second, it tells Spring Cloud Stream which channels to bind those functions to under `spring.cloud.streams.bindings`. Lastly, it contains connection information to the messaging system. The connection info is specified by different parameters depending on the binder you choose but, in this case, it’s defined under `solace.java`.\n\n```yaml\nspring: \n  cloud: \n    stream: \n      function: \n        definition: acmeRideshareBillingReceiptCreated001Consumer \n    bindings: \n      acmeRideshareBillingReceiptCreated001Consumer-in-0:\n        destination: acme/rideshare/billing/receipt/created/0.0.1\n\nsolace: \n  java: \n    host: 'localhost:55555' \n    msgVpn: default \n    clientUsername: default \n    clientPassword: default\n\nlogging: \n  level: \n    root: info \n    org: \n      springframework: info\n```\n\nNote that all of this was done for the developer so they didn’t have to track down which SCSt parameters needed to be set, map the functions to the bindings, etc. They just have to add their business logic in place of the project and hit run! In this case since it’s a Spring Boot project you can “run as a Spring Boot app” in your IDE or even run from the command line using `mvn spring-boot:run`.\n\n# Helpful Parameters and Specification Extensions for Creating Microservices Using the AsyncAPI Spring Cloud Stream Template\n\nAs I mentioned, there are a lot of complexities when it comes to generating useful application code from a microservice. Because of these complexities, I thought I’d call out some tips, tricks, and painpoints of using the AsyncAPI Spring Cloud Stream template.\n\nThere are a bunch of different parameters and specification extensions that you should consider when generating your code. All of them can be found [here](https://github.com/asyncapi/java-spring-cloud-stream-template#configuration-options), but I’ll go over a few of the parameters that I use quite often:\n\n- The `binder` parameter allows you to specify the Spring Cloud Stream binder that you’d like to use. Currently the generator supports `kafka`, `rabbit` and `solace`.\n- The `info.x-view` specification extension can be set at the info level in your AsyncAPI document. This extension allows for you to define how the document should be viewed from an application perspective. By default an AsyncAPI specification takes a `client` view where operations (publish/subscribe) defined in a document represent what an application accepts (or how you would communicate with that application). However, for code generation you may want to  generate what an application actually does. This is where setting the `view` parameter comes in. If you set `view` to a value of `provider`  the operations defined in the document will be treated as what an application actually does. Note that this extension can also be set using the `view` parameter on some generator templates, such as the Java Spring Cloud Stream one. \n- The `operation.x-scs-function-name` specification extension can be set on your `publish` or `subscribe` operations in the AsyncAPI document, allowing you not only to name the generated function, but also tie two operations together to form a function that subscribes to one channel and publishes to another when the same name is used. For example, if your AsyncAPI document looked like the image below a `java.util.function.Function` bean called “calculatePercentage” would be generated which subscribes to the input channel and publishes to the output channel.\n\n```yaml\nchannels:\n  'input':\n    subscribe:\n      x-scs-function-name: calculatePercentage\n      message:\n        $ref: '#/components/messages/CovidTracking_SingleStateCurrentDataUpdate'\n  'output':\n    publish:\n      x-scs-function-name: calculatePercentage\n      message:\n        $ref: '#/components/messages/CovidTracking_SingleStateTestPercentagesUpdate'\n```\n\n- The `x-scs-destination` specification extension can be specified on a `subscribe` operation, allowing you to override the default destination value which usually matches the channel. This is useful when you are using the Solace binder and you are following the Solace pattern of publishing to topics and consuming from queues. In this case the `x-scs-destination` value would be treated as the name of the queue which your microservice will consume from and the channel name in the AsyncAPI document will be added as a topic subscription to that queue.\n- The `x-scs-group` specification extension can also be specified on a `subscribe` operation, allowing for the addition of a `group` to the generated Spring Cloud Stream `binding`. This allows for the use of consumer groups and will end up in a [durable queue](https://dev.to/solacedevs/understanding-solace-endpoints-durable-vs-non-durable-53gd) being created when using the Solace binder.\n\n# Tips For Using The Code Generator To Create Event-Driven Microservices Using Spring Cloud Stream\n\nBesides configuration options there are a few more things to keep in mind when using the generator to create event-driven microservices using Spring Cloud Stream.\n\n1. Make sure generated POJOs have the Java types you would expect for generated variables! For example, if your JSON schema defines an attribute type as a `number` or `integer` those are being mapped to a `Double` or `Integer` in Java respectively. If you would like another type, such as a float or long, you’ll want to make that change. It is also important to make sure you pay close attention to data that represents dates and/or times as those will likely end up just being represented by a `String` by default.\n2. Dynamic topics are not yet supported by the AsyncAPI SCSt Code Generator. We’ll be looking to enhance them both to support dynamic topics in the future but for now you’ll want to remove dynamic pieces of the topic from your channels in the AsyncAPI document and add them into the code afterwards.\n3. When creating a Spring Cloud Stream microservice that does _not_ contain a `java.util.function.Supplier` include a web server so the microservice continues running and listening for messages to process. This can be done by including the `-p actuator=true` parameter to include Spring Actuator functionality which itself requires a web server, and also provides some cool management and monitoring capabilities. Alternatively, you can just add the `spring-boot-starter-web` starter to your pom after it’s been generated. Note this is not an issue with the AsyncAPI generator template, but just a bug with the Solace Spring Cloud Stream binder which will be relevant to people using the generator.\n\nI hope those tips are helpful and save you some troubleshooting time!\n\n# Conclusion\n\nI hope this post was useful and you’re able to quickly dive in to generating your own event-driven microservices using Spring Cloud Stream and the AsyncAPI Code Generator after exploring the example described above.\n\nYou can get started right away and use the Solace PubSub+ Event Portal to generate your AsyncAPI document for FREE by signing up for a [new cloud account](https://console.solace.cloud/login/new-account)!\n\nIf you have more questions or want to share your experience with the tools, you can let us know in the [Solace Community Forum](http://solace.community/) or consider joining us in contributing directly to the AsyncAPI initiative.\n\n<YouTube id=\"https://www.youtube.com/embed/QEDL6AqsaJc\" />\n",
    "toc": [
      {
        "content": "AsyncAPI: What Is It?",
        "slug": "asyncapi-what-is-it",
        "lvl": 1,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Defining the Application That You Want to Develop: The  AsyncAPI Document",
        "slug": "defining-the-application-that-you-want-to-develop-the--asyncapi-document",
        "lvl": 1,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Create Event-Driven Microservices Using Spring Cloud Stream Without Learning Messaging APIs",
        "slug": "create-event-driven-microservices-using-spring-cloud-stream-without-learning-messaging-apis",
        "lvl": 1,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Download and Run the AsyncAPI Generator",
        "slug": "download-and-run-the-asyncapi-generator",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Add Your Business Logic",
        "slug": "add-your-business-logic",
        "lvl": 1,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Helpful Parameters and Specification Extensions for Creating Microservices Using the AsyncAPI Spring Cloud Stream Template",
        "slug": "helpful-parameters-and-specification-extensions-for-creating-microservices-using-the-asyncapi-spring-cloud-stream-template",
        "lvl": 1,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Tips For Using The Code Generator To Create Event-Driven Microservices Using Spring Cloud Stream",
        "slug": "tips-for-using-the-code-generator-to-create-event-driven-microservices-using-spring-cloud-stream",
        "lvl": 1,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Conclusion",
        "slug": "conclusion",
        "lvl": 1,
        "i": 7,
        "seen": 0
      }
    ],
    "slug": "/blog/asyncapi_codegen_scst",
    "filePath": "pages/blog/asyncapi_codegen_scst.md"
  },
  {
    "meta": {
      "title": "API documentation in event-driven applications",
      "date": "2020-05-18T09:00:10.000Z",
      "type": "Engineering",
      "tags": [
        "EDA",
        "Documentation"
      ],
      "cover": "/img/posts/doc-event-driven-api.webp",
      "authors": [
        {
          "name": "Héctor Valls",
          "photo": "/img/avatars/hvalls.webp",
          "link": "https://twitter.com/hhccvvmm",
          "byline": "Freelance Software Engineer"
        }
      ],
      "readingTime": 4,
      "excerpt": "We live in an era of distributed systems. Airlines and hotels communicate with each other to offer us a better experience in our travels; shops work with shipping companies, so we have our new product"
    },
    "content": "\nWe live in an era of distributed systems. Airlines and hotels communicate with each other to offer us a better experience in our travels; shops work with shipping companies, so we have our new products in our homes in a matter of hours. All of these integrations across services are done using APIs. Those APIs must be well documented so the consumers can integrate with them easily. This is not only a technical matter but also a business-related one.\n\nCurrently, the most used API protocols are <a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\">REST</a> and <a href=\"https://graphql.org/\">GraphQL</a>. You can document your REST API using the <a href=\"https://swagger.io/specification/\">OpenAPI</a> initiative. In the case of GraphQL, you can use tools like GraphiQL, which makes supported operations visible through <a href=\"https://graphql.org/learn/introspection/\">introspection query</a>.\n\nBoth protocols are essentially synchronous: you make a request against the API and wait for a response. But what happens when you are to design an asynchronous event-oriented API? OpenAPI has been designed to document request/response APIs, and GraphQL has its own specific mechanism, so they are not applicable in this case. <a href=\"https://www.asyncapi.com/\">AsyncAPI</a> to the rescue.\n\n---\n\nLet's imagine you work on a book shopping website called _SuperFunnyBooks_. Your team is responsible for the `Catalog Service`. Book publishers can register new books to the platform through your service. \n\n_SuperFunnyBooks_ product team needs a new feature to be added: when a new book is registered on the platform, it has to be recommended to users interested in that genre. To do this, a brand new service, `Recommendation Service`, is created and a new team is assigned to. \n\nThe new service needs to know when a new book is registered in the platform, so `Catalog Service` will publish a `BookRegistered` event to a message queue every time this happens. This event will contain information about the new book. But, where is the message queue located? and what does exactly \"information about the new book\" mean? It sounds a little bit abstract and vague. `Recommendation Service` team needs to know every single field that will be included in the event's payload, as well as how to connect to the message queue to start listening for new events. In other words, they need the API documentation. \n\nThis is how this event-oriented API would look like with AsyncAPI:\n\n```yaml\nasyncapi: 2.0.0\ninfo:\n  title: Catalog Service\n  version: '1.0.0'\n\nservers:\n  production:\n    url: catalog.superfunnybooks.com:9092\n    protocol: kafka\n    description: Production Kafka \n\nchannels:\n  book/registered:\n    description: Book Registered Topic\n    subscribe:\n      summary: Receive information about new book registered in catalog\n      message:\n        name: BookRegistered\n        contentType: application/json\n        payload:\n          type: object\n          properties:\n            bookId:\n              type: string\n            title:\n              type: string\n            author:\n              type: string\n            genre:\n              type: string\n            publisherId:\n              type: string\n            registeredAt:\n              type: string\n              format: datetime\n```\n\nThe first part contains API metadata information. Then, `servers` information is declared; in this case, there is a Kafka server running on `catalog.superfunnybooks.com` at port `9092`. `channels` object groups all the operations that the API supports. This one allows consumers to subscribe to `book/registered` channel to be notified when a new book is registered. Also, the concrete event's payload schema is defined. \n\nWith this document, API is properly defined and it provides a contract between `Catalog Service` and its consumers. Now, `Recommendation Service` knows where the message queue is located in the network and how exactly an event's payload looks like.\n\n---\n\nTo sum up, having nice API documentation improves communication between teams in a company as well as between external stakeholders. Also, using a machine-friendly format (like YAML) in API documentation enables it to be integrated into the development lifecycle and the possibility of taking advantage of techniques like server stubbing or automatic testing.\n\nThis has been a simple example of how to use AsyncAPI specifications to document event-oriented APIs. <a href=\"https://www.asyncapi.com/docs/specifications/2.0.0/#specification\">AsyncAPI spec</a> provides a lot of options that allow to define clearly many aspects of an API. It is worth keeping it in mind.\n\nI hope you enjoyed this post.\n\n(Original content from https://hvalls.dev/posts/doc-event-driven-api)\n",
    "toc": [],
    "slug": "/blog/doc-event-driven-api",
    "filePath": "pages/blog/doc-event-driven-api.md"
  },
  {
    "meta": {
      "title": "(Part 2) Full automation of release with GitHub Actions and Conventional Commits for non-JS projects",
      "date": "2020-04-14T05:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "GitHub Actions",
        "Release"
      ],
      "cover": "/img/posts/robot2.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Dev Comm Keeper"
        }
      ],
      "excerpt": "This post and the previous one come from our experience we gained when working on full automation for all tools maintained by AsyncaPI Initiative.",
      "readingTime": 6
    },
    "content": "\n> tl;dr\n[Here](/blog/automated-releases/) you can find the first blog post about automated releasing. The purpose of this blog post is to show how you can do the same automation in non-JavaScript projects. Even if JavaScript community created tooling, you can still use it in other projects and don't freak out.\n\nThis post and the [previous one](/blog/automated-releases/) come from our experience we gained when working on full automation for all tools maintained by [AsyncaPI Initiative](https://github.com/asyncapi/asyncapi/).\n\n> [AsyncAPI](https://github.com/asyncapi/asyncapi/) is a specification that you use to create machine-readable definitions of your event-driven APIs. \n\nThe previous post focused on JavaScript as the first library that we automated was our [generator](https://github.com/asyncapi/generator/). It covered publishing to NPM and usage of the JavaScript community ecosystem. Now we have automation rolled out to all our libraries, Go-written too.\n\n## What I need to automate release?\n\nTo automate a release efficiently, you need two things:\n\n- Machine-readable information that allows you to identify if a given commit should trigger a release or not.\n- Tooling that you can easily plug in and configure without the need to write everything from scratch.\n\nThis automation is possible thanks to the following:\n\n- The [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) specification. The purpose of Conventional Commits is to make commits machine-readable but also human-readable. It defines a set of commit prefixes that can be easily parsed and analyzed by tooling and looks good to the human eye too.\n- The [Semantic Release](https://github.com/semantic-release/semantic-release) package and related plugins that support Conventional Commits and publishing to different channels like GitHub, NPM, Slack, and others.\n\n## Where's the catch?\n\nThis blog post is about the automation of releases for non-JavaScript projects. Let me be honest though, solutions I mentioned in the previous chapter come from the JavaScript community.\n\nThe problem is, there are people who [Hate JavaScript](https://www.reddit.com/r/javascript/comments/9pwzpn/why_do_people_hate_javascript/), they truly [hate it](https://www.quora.com/Why-is-JavaScript-so-hated) like it is a living thing. Although, I'm personally proud to be an idiot that has a programming language that I can use.\n\nConventional Commits specification is heavily inspired by [Angular Commit Guidelines](https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#commit-message-format). The Semantic Release package and its plugins ecosystem are all Node.js packages.\n\n![](https://media.giphy.com/media/10FHR5A4cXqVrO/giphy.gif)\n\nIf you have Java or Go project, you can still use these tools. You do not have to keep `package.json` in your repository, so don't worry, you can keep your repository clean. The great folks from Semantic Release thought about you too.\n\n![](https://media.giphy.com/media/QynGWwS6GdOMj6cvmz/giphy-downsized.gif)\n\n## Using Semantic Release with GitHub Action in Go project\n\nOne of the projects where we use this JavaScript tools is our parser for AsyncAPI documents. It is a [Go parser](https://github.com/asyncapi/parser-go).\n\n### Semantic Release configuration\n\nThe Semantic Release package supports configuration files in different formats and file types. You are not bound to `package.json`. We chose to use `.releaserc` file in YAML format but there are [other options](https://github.com/semantic-release/semantic-release/blob/master/docs/usage/configuration.md#configuration-file) too.\n\n```yaml\n---\nbranches:\n- master\nplugins:\n- - \"@semantic-release/commit-analyzer\"\n  - preset: conventionalcommits\n- - \"@semantic-release/release-notes-generator\"\n  - preset: conventionalcommits\n- - \"@semantic-release/github\"\n  - assets:\n    - path: asyncapi-parser.darwin.amd64\n      label: Binary - Darwin AMD64\n    - path: asyncapi-parser.linux.amd64\n      label: Binary - Linux AMD64\n    - path: asyncapi-parser.windows.amd64.exe\n      label: Binary - Windows AMD64\n```\n\nOur configuration uses plugins to:\n- Analyze Git commits with Conventional Commits specification.\n- Create a Git tag and generate changelog for release notes.\n- Publish a release with additional assets. We compile our parser as binaries that are compatible with many platforms and we want to have them easily accessible with each release.\n\nWe place the configuration under `.github/workflows/`, next to our GitHub Action release workflow file: `release.yml`. It indicates that it is for release only, nothing else.\n\n### Release workflow\n\nLet us have a look at the differences between this workflow and the workflow I described for a typical JavaScript project [here](/blog/automated-releases/).\n\nFirst, you define a `test` job with the Go environment to trigger tests with different versions of Go.\n\n```yaml\ntest:\n  name: 'Testing'\n  runs-on: ubuntu-latest\n  strategy:\n    matrix:\n      go: \n        - '1.14'\n        - '1.13'\n        - '1.12' \n  steps:\n    - name: Checkout repo\n      uses: actions/checkout@v2\n    - name: Setup Go\n      uses: actions/setup-go@v1.1.2\n      with:\n        go-version: '${{ matrix.go }}'\n    - name: Invoking go test\n      run: go test ./...\n```\n\nThe next step is the `release` job, where you can differentiate two core steps. The first part is the generation of the binaries that you want to expose in the GitHub release.\n\n```yaml\n- name: Setup Go\n  uses: actions/setup-go@v1.1.2\n  with:\n    go-version: '1.14'\n- name: Invoking go vet and binaries generation\n  run: |\n    go vet ./...\n    GOOS=darwin GOARCH=amd64 go build -o=.github/workflows/asyncapi-parser.darwin.amd64 ./cmd/api-parser/main.go\n    GOOS=linux GOARCH=amd64 go build -o=.github/workflows/asyncapi-parser.linux.amd64 ./cmd/api-parser/main.go\n    GOOS=windows GOARCH=amd64 go build -o=.github/workflows/asyncapi-parser.windows.amd64.exe ./cmd/api-parser/main.go\n```\n\nSo far, it is all Go-related operations. How about the release? For the release, you need to set up a Node.js environment to run Semantic Release. Node.js community has this excellent package, [npx](https://www.npmjs.com/package/npx), that allows you to run a package without installing it, and this is what you can do here in the workflow.\n\n```yaml\n- name: Setup Node.js\n  uses: actions/setup-node@v1\n  with:\n    node-version: 13\n- name: Add plugin for conventional commits\n  run: npm install conventional-changelog-conventionalcommits\n  working-directory: ./.github/workflows\n- name: Release to GitHub\n  working-directory: ./.github/workflows\n  env:\n    GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n    GIT_AUTHOR_NAME: asyncapi-bot\n    GIT_AUTHOR_EMAIL: info@asyncapi.io\n    GIT_COMMITTER_NAME: asyncapi-bot\n    GIT_COMMITTER_EMAIL: info@asyncapi.io\n  run: npx semantic-release\n```\n\nYou only have to install `conventional-changelog-conventionalcommits` explicitly if you want to use `conventionalcommits` preset when analyzing Git commits and generating the changelog:\n```\nplugins:\n- - \"@semantic-release/commit-analyzer\"\n  - preset: conventionalcommits\n- - \"@semantic-release/release-notes-generator\"\n  - preset: conventionalcommits\n``` \n\nTake a look at full release workflow for reference:\n\n```yaml\nname: Release\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  test:\n    name: 'Testing'\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go: \n          - '1.14'\n          - '1.13'\n          - '1.12' \n    steps:\n      - name: Checkout repo\n        uses: actions/checkout@v2\n      - name: Setup Go\n        uses: actions/setup-go@v1.1.2\n        with:\n          go-version: '${{ matrix.go }}'\n      - name: Invoking go test\n        run: go test ./...\n  \n  release:\n    name: 'Release to GitHub'\n    runs-on: ubuntu-latest\n    needs: \n      - test\n    steps:\n      - name: Checkout repo\n        uses: actions/checkout@v2\n      - name: Setup Go\n        uses: actions/setup-go@v1.1.2\n        with:\n          go-version: '1.14'\n      - name: Invoking go vet and binaries generation\n        run: |\n          go vet ./...\n          GOOS=darwin GOARCH=amd64 go build -o=.github/workflows/asyncapi-parser.darwin.amd64 ./cmd/api-parser/main.go\n          GOOS=linux GOARCH=amd64 go build -o=.github/workflows/asyncapi-parser.linux.amd64 ./cmd/api-parser/main.go\n          GOOS=windows GOARCH=amd64 go build -o=.github/workflows/asyncapi-parser.windows.amd64.exe ./cmd/api-parser/main.go\n      - name: Setup Node.js\n        uses: actions/setup-node@v1\n        with:\n          node-version: 13\n      - name: Add plugin for conventional commits\n        run: npm install conventional-changelog-conventionalcommits\n        working-directory: ./.github/workflows\n      - name: Release to GitHub\n        working-directory: ./.github/workflows\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n          GIT_AUTHOR_NAME: asyncapi-bot\n          GIT_AUTHOR_EMAIL: info@asyncapi.io\n          GIT_COMMITTER_NAME: asyncapi-bot\n          GIT_COMMITTER_EMAIL: info@asyncapi.io\n        run: npx semantic-release\n```\n\nYou see, you can still have your project \"clean\" from any JavaScript-specific files and references. Everything you need for running your release with the JavaScript community tooling is only in the release-related configuration.\n\n## Conclusion\n\nI don't think I can ever understand this \"hate\" towards JavaScript. I think, though, that you can \"hate\" the language, but if you see some amazing tooling built with it, that can increase your productivity, grit your teeth, put bias aside, and enjoy life. Especially, if in exchange you get this excellent feature, notification about release under the Issue and Pull Request:\n\n![pr info about release](/img/posts/pr-indicator.webp)\n\nIn case you want to have more explanation on the release automation subject, I recommend reading [the first part of the automation story](/blog/automated-releases/). You can also [join our Slack](https://www.asyncapi.com/slack-invite/) for further discussion.\n\n_* Cover photo by [Rock'n Roll Monkey](https://unsplash.com/@rocknrollmonkey) on Unsplash_\n",
    "toc": [
      {
        "content": "What I need to automate release?",
        "slug": "what-i-need-to-automate-release",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Where's the catch?",
        "slug": "wheres-the-catch",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Using Semantic Release with GitHub Action in Go project",
        "slug": "using-semantic-release-with-github-action-in-go-project",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Semantic Release configuration",
        "slug": "semantic-release-configuration",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Release workflow",
        "slug": "release-workflow",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Conclusion",
        "slug": "conclusion",
        "lvl": 2,
        "i": 5,
        "seen": 0
      }
    ],
    "slug": "/blog/automated-releases-part-two",
    "filePath": "pages/blog/automated-releases-part-two.md"
  },
  {
    "meta": {
      "title": "AsyncAPI Online Conference scheduled for 22.04 11 AM UTC",
      "date": "2020-04-09T05:00:00.000Z",
      "type": "Communication",
      "tags": [
        "Conference"
      ],
      "cover": "/img/posts/asyncapi-conf-banner.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Dev Comm Keeper"
        }
      ],
      "excerpt": "It is happening, a first-ever AsyncAPI Online conference. We start on 22 of April, at 11 AM UTC. The event is going to take 7 hours with 12 talks from all over the world. We start in sunny Sydney and finish in cloudy Vancouver. The event is for free, online, in your favorite quarantine room.",
      "readingTime": 5
    },
    "content": "\nIt is happening, a first-ever AsyncAPI Online conference. We start on 22 of April, at [11 AM UTC](https://everytimezone.com/s/52eb2b62). The event is going to take 7 hours with 12 talks from all over the world. We start in sunny Sydney and finish in cloudy Vancouver. The event is for free, online, in your favorite quarantine room.\n\n<YouTube id=\"https://www.youtube.com/embed/EsCiDSwfAMw\" />\n\n## How do you organize an event like this in such a short time\n\nThere are two requirements you should fulfill behind you start organizing a conference:\n\n1. Gather a few people that like to walk off the beaten tracks. Best would be to involve your whole core team, as we did in AsyncAPI. All three of us got involved <img className=\"inline-block w-5 h-5 ml-1\" src=\"https://emojipedia-us.s3.amazonaws.com:443/content/2020/04/05/trollface-github-emojipedia.png\"/>\n\n    - [Fran Méndez](https://twitter.com/fmvilas) - Project Director.\n    - [Eva Morcillo Rodríguez](https://twitter.com/e_morcillo) - Marketing and Video Content Manager.\n    - [Łukasz Górnicki](https://twitter.com/derberq) - Maintainer and Dev Community Keeper.\n\n2. Make sure you have a fantastic community behind your back that supports your efforts\n\n## First baby steps to kick off the event\n\n1. Consult your community if what you plan to do makes sense\n![slack asyncapi conference](/img/posts/slack-conference.webp)\n2. Set a conference date and call for proposals deadline\n3. Get your community involved\n\nWe decided on a tight schedule. Our community had only three days to submit proposals. Oh boy, they exceeded our expectations. In total, we got 18! proposals. We were happy and proud but also afraid that we can't accept all talks.\n\n## Talks selection\n\nWe wanted to establish as many fair rules as possible in such a short timeframe. We decided to form a committee of people that could join Fran and vote for talks that they found most interesting:\n\n- They could give 1-10 points per talk.\n- They had no idea who is behind the talk. They knew only a title and an abstract of every proposal.\n\nAfter voting, we applied the following additional rules:\n\n- We did not accept more than one talk from the same company. We choose the one that was most popular among voters. \n- We did not accept talks that were either not related to the theme or other talks accepted for the conference.\n\nIn other words, we did not want to favor any company and wanted to have a schedule with talks around a similar area.\n\nAs a result, we accepted [11 talks](https://www.asyncapiconf.com/#schedule) from the community. We did it thanks to the support of this amazing group of people: \n\n- [Waleed Ashraf](https://twitter.com/WaleedAshraf01)\n- [Mike Ralphson](https://twitter.com/PermittedSoc)\n- [Jonas Lagoni](https://github.com/jonaslagoni/)\n- [Andrzej Jarzyna](https://twitter.com/pieroginomicon)\n\n## Sponsoring\n\nWe decided to [enable companies and individuals](https://github.com/asyncapi/asyncapi/issues/372) to support the event financially.\n\nHow to collect money? Do it transparently with tools that you already know. We decided to use Open Collective because we use it already to [collect money for AsyncAPI](https://opencollective.com/asyncapi)\n\nWe created a dedicated [event](https://opencollective.com/asyncapi-online-conference-fd574661/) using [Open Collective events](https://docs.opencollective.com/help/collectives/events#create-an-event). This approach allows us to collect money and share expenses explicitly for the event only. The sponsors in exchange get much more than just being listed in our [conference sponsors list](https://www.asyncapiconf.com/#sponsors), and it is clearly described under our event page.\n\nWhat is the money for? We want to spend it mainly on:\n\n- Prizes for the community involved in the event. \n- Paid event marketing. We are doing our best to promote event [on our own](https://github.com/asyncapi/asyncapi/issues/369), but we know that we could do much better using paid channels too. More people know about the event and indirectly about AsyncAPI, better profits for the community, and the sponsors.\n\n## Logistics aka connectivity issues can kill your event\n\nThese are coronavirus times. ISPs are having stress tests. Netflix is probably hitting view records. Kids are running around the house all the time. We took it all into account, and this is how we want to solve those challenges:\n\nFirst of all, we asked our presenters to record their sessions upfront and send them to us. We want to stream them live to YouTube, and we are exploring platforms that might make it easy to stream not only to YouTube but also Twitter and others. Presenters still join their sessions, and they are going to engage with the audience in conference chat in real-time during the whole presentation. What is so great about it?\n\n- The audience doesn't have to wait until the end of the presentation with questions as it works in traditional conferences\n- Presenters have much more time to engage with their audience, to exchange thoughts, and get more questions. They can also ask their teammates, organization members, or experts in their field to provide support during the talk. \n\n## Conclusion\n\nDon't be afraid to organize your event; just find some freaks that follow you to organize it. I'm a proud freak that bought the idea immediately. It is worth it, even if you do not know the outcome yet, the experience you always gain profits in the future.\n\nIn the name of the whole AsyncAPI community and the core team, I'd like to invite you to join our event on 22 of April, at [11 AM UTC](https://everytimezone.com/s/52eb2b62). The conference line-up suggests that the AsyncAPI Online conference is going to be epic!\n\n#stayhome #staysafe #staycurious\n\n\n\n",
    "toc": [
      {
        "content": "How do you organize an event like this in such a short time",
        "slug": "how-do-you-organize-an-event-like-this-in-such-a-short-time",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "First baby steps to kick off the event",
        "slug": "first-baby-steps-to-kick-off-the-event",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Talks selection",
        "slug": "talks-selection",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Sponsoring",
        "slug": "sponsoring",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Logistics aka connectivity issues can kill your event",
        "slug": "logistics-aka-connectivity-issues-can-kill-your-event",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Conclusion",
        "slug": "conclusion",
        "lvl": 2,
        "i": 5,
        "seen": 0
      }
    ],
    "slug": "/blog/asyncapi-conference-kick-off",
    "filePath": "pages/blog/asyncapi-conference-kick-off.md"
  },
  {
    "meta": {
      "title": "Automate AsyncAPI workflows with Github Actions",
      "date": "2020-04-02T05:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "GitHub Actions",
        "Automation"
      ],
      "cover": "/img/posts/asyncapi-github-action.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Dev Comm Keeper"
        }
      ],
      "excerpt": "AsyncAPI community got rich with two GitHub Actions that you can use for validation and generation.",
      "readingTime": 5
    },
    "content": "\n> tl;dr\nAsyncAPI community got rich with two GitHub Actions that you can use for [validation](https://github.com/marketplace/actions/asyncapi-github-action) and [generation](https://github.com/marketplace/actions/generator-for-asyncapi-documents).\n\nGitHub organized a [hackathon for GitHub Actions](https://githubhackathon.com/#hackathon). There is no better reason to work on a solution if there is a bag of swags waiting for you <img className=\"inline-block w-5 h-5 ml-1\" src=\"https://emojipedia-us.s3.amazonaws.com:443/content/2020/04/05/trollface-github-emojipedia.png\"/>\n\nThe hackathon was only a trigger, the right moment to decide that we should engage. The primary motivation was to write a GitHub Action that can help the AsyncAPI community in specification adoption.\n\nTwo AsyncAPI related actions we crafted in March are:\n\n- Our community member, [Waleed Ashraf](https://twitter.com/WaleedAshraf01/) created [an action](https://github.com/marketplace/actions/asyncapi-github-action) to validate AsyncAPI documents with our [parser](https://github.com/asyncapi/parser-js/)\n- We also created [official AsyncAPI action](https://github.com/marketplace/actions/generator-for-asyncapi-documents) for our [generator](https://github.com/asyncapi/generator/).\n\n## Writing a GitHub Action\n\nOur actions are both [written in JavaScript](https://help.github.com/en/actions/building-actions/creating-a-javascript-action). The other way of writing action is to do a [Docker container action](https://help.github.com/en/actions/building-actions/creating-a-docker-container-action). The best way to start writing your action is to:\n\n1. Follow [this](https://help.github.com/en/actions/building-actions/creating-a-javascript-action) tutorial to create a simple action to understand its components.\n1. Get familiar with the [official toolkit](https://github.com/actions/toolkit) that you can use to simplify writing an action. \n1. Create your custom action with [this template](https://github.com/actions/javascript-action) that has many things plugged in already, like eslint, testing, and most important, distro generation, so you do not have to commit `node_modules` directory to your repository.\n\nThese are all the resources I used to write my first action, and to master it, I only had to read the official docs, like the [reference docs for the \"action.yml\" file](https://help.github.com/en/actions/building-actions/metadata-syntax-for-github-actions). Well done GitHub!\n\n## What I can do today with AsyncAPI GitHub Actions\n\nThose two actions can help you a lot already, together or separately. I present in this post only two possible workflows, and you can take it from here and think about your ideas.\n\n### Validation of AsyncAPI files in a Pull Request\n\nYou can make sure that whenever someone makes a Pull Request to propose a change in the AsyncAPI document, you can validate it automatically using [Waleed's](https://twitter.com/WaleedAshraf01/) action `WaleedAshraf/asyncapi-github-action@v0.0.3`.\n\nActions can be triggered by [multiple types of events](https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions). In this example, we will trigger the action on any `pull_request` event.\n\n```yaml\nname: Validate AsyncAPI document\n\non:\n  pull_request:\n  \njobs:\n  validation:\n    runs-on: ubuntu-latest\n    - name: asyncapi-github-action\n      uses: WaleedAshraf/asyncapi-github-action@v0.0.3\n      with:\n        filepath: 'my-directory/asyncapi.yaml'\n```\n\n### Generating HTML and publishing it to GitHub Pages\n\nOne of the AsyncAPI use cases is to define your application and generate docs out of this definition, best in HTML. The typical workflow here would be to have a GitHub Action that your trigger on every push to the `master` branch. \n\n```yaml\nname: AsyncAPI documentation publishing\n\non:\n  push:\n    branches: [ master ]\n```\n\nTo generate HTML from your AsyncAPI definition, you need to use `asyncapi/github-action-for-generator@v0.2.0` action. You also need to specify a few more things:\n\n- The template you want to use for generation. In this example, you can see the official [AsyncAPI HTML Template](https://github.com/asyncapi/html-template). You can also write your custom template but hosting it on npm is not mandatory.\n- Path to the AsyncAPI file, in case it is not in the root of the working directory and its name is not `asyncapi.yml`\n- The template specific parameters. The crucial part here is the `baseHref` parameter. When enabling [GitHub Pages](https://pages.github.com/) for a regular repository, the URL of the Web page is `https://{GITHUB_PROFILE}.github.io/{REPO_NAME}/`. Specifying `baseHref` parameter helps the browser to properly resolve the URLs of relative links to resources like CSS and JS files. You do not have to hardcode the name of the repo in workflow configuration. Your workflow has access to information about the repository it is running in. You could do this: `${baseHref=/{github.repository}}/`\n- The output directory where the generator creates files. You might access those files in other steps of the workflow. \n\n```yaml\n- name: Generating HTML from my AsyncAPI document\n  uses: asyncapi/github-action-for-generator@v0.2.0\n  with:\n    template: '@asyncapi/html-template@0.3.0'  #In case of template from npm, because of @ it must be in quotes\n    filepath: docs/api/my-asyncapi.yml\n    parameters: baseHref=/test-experiment/ sidebarOrganization=byTags #space separated list of key/values\n    output: generated-html\n```\n\nNow you have a trigger and you can generate a Web page. The next step is to publish the generated HTML documentation to GitHub Pages. For this, you can use one of the actions created by the community, like `JamesIves/github-pages-deploy-action@3.4.2`. You can also use other hosting solutions than GitHub Pages, like, for example, Netlify and [one of their actions](https://github.com/netlify/actions/tree/master/cli).\n\n```yaml\n- name: Deploy GH page\n  uses: JamesIves/github-pages-deploy-action@3.4.2\n  with:\n    ACCESS_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    BRANCH: gh-pages\n    FOLDER: generated-html\n```\n\nHere is how a full workflow, with embedded validation, could look like:\n\n```yaml\nname: AsyncAPI documentation publishing\n\non:\n  push:\n    branches: [ master ]\n\njobs:\n  generate:\n    runs-on: ubuntu-latest\n    steps:\n    #\"standard step\" where repo needs to be checked-out first\n    - name: Checkout repo\n      uses: actions/checkout@v2\n      \n    #Using another action for AsyncAPI for validation\n    - name: Validating AsyncAPI document\n      uses: WaleedAshraf/asyncapi-github-action@v0.0.3\n      with:\n        filepath: docs/api/my-asyncapi.yml\n      \n    #In case you do not want to use defaults, you, for example, want to use a different template\n    - name: Generating HTML from my AsyncAPI document\n      uses: asyncapi/github-action-for-generator@v0.2.0\n      with:\n        template: '@asyncapi/html-template@0.3.0'  #In case of template from npm, because of @ it must be in quotes\n        filepath: docs/api/my-asyncapi.yml\n        parameters: baseHref=/test-experiment/ sidebarOrganization=byTags #space separated list of key/values\n        output: generated-html\n      \n    #Using another action that takes generated HTML and pushes it to GH Pages\n    - name: Deploy GH page\n      uses: JamesIves/github-pages-deploy-action@3.4.2\n      with:\n        ACCESS_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        BRANCH: gh-pages\n        FOLDER: generated-html\n```\n\n## Conclusion\n\nFirst of all, huge thank you to [Waleed Ashraf](https://twitter.com/WaleedAshraf01/) for creating an action to validate AsyncAPI documents.\n\nPlease try out the above-described actions and let us know what you think. Feel free to leave an issue to suggest improvements or ideas for other actions. \n\nIn case you are interested with other GitHub Actions related posts you might have a look at:\n\n- [Full automation of release to NPM and Docker Hub with GitHub Actions and Conventional Commits](/blog/automated-releases/)\n- [GitHub Actions - When Fascination Turns Into Disappointment](https://dev.to/derberg/github-actions-when-fascination-turns-into-disappointment-4d75)\n",
    "toc": [
      {
        "content": "Writing a GitHub Action",
        "slug": "writing-a-github-action",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "What I can do today with AsyncAPI GitHub Actions",
        "slug": "what-i-can-do-today-with-asyncapi-github-actions",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Validation of AsyncAPI files in a Pull Request",
        "slug": "validation-of-asyncapi-files-in-a-pull-request",
        "lvl": 3,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Generating HTML and publishing it to GitHub Pages",
        "slug": "generating-html-and-publishing-it-to-github-pages",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Conclusion",
        "slug": "conclusion",
        "lvl": 2,
        "i": 4,
        "seen": 0
      }
    ],
    "slug": "/blog/asyncapi-github-actions",
    "filePath": "pages/blog/asyncapi-github-actions.md"
  },
  {
    "meta": {
      "title": "Full automation of release to NPM and Docker Hub with GitHub Actions and Conventional Commits",
      "date": "2020-03-20T05:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "GitHub Actions",
        "Release"
      ],
      "cover": "/img/posts/robot.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Dev Comm Keeper"
        }
      ],
      "excerpt": "Repetitive tasks are tedious. If what you do manually can be automated, then what are you waiting for!",
      "readingTime": 10
    },
    "content": "\n> tl;dr\nfrom now on, we release [generator](https://github.com/asyncapi/generator/) in an automated way. We roll-out this setup to the rest when we see it is needed.\n\nRepetitive tasks are tedious. If what you do manually can be automated, then what are you waiting for! \n\n> _But these tasks take only a couple of minutes from time to time, gimme a break_\n\nA couple of minutes here, a couple of minutes there and all of a sudden you do not have time on more important things, on innovation. Automation makes it easier to scale and eliminates errors. Distractions consume time and make you less productive.\n\nWe kick ass at [AsyncAPI Initiative](https://www.asyncapi.com/) at the moment. We started to improve our tooling regularly. We are now periodically sharing project status in our [newsletter](https://www.asyncapi.com/subscribe), and host [bi-weekly open meetings](https://github.com/asyncapi/asyncapi/issues/115), but most important is that we just recently updated our roadmap.\n\nAm I just showing off? It sounds like, but that is not my intention. I wish to point out we are productive, and we want to continue this trend and automation helps here a lot. If you have libraries that you want to release regularly and you plan additional ones to come, you need to focus on release automation.\n\n## What full automation means\n\nFull automation means that the release process if fully automated with no manual steps. What else did you think?\n\n<iframe src=\"https://giphy.com/embed/6uGhT1O4sxpi8\" width=\"480\" height=\"240\" frameBorder=\"0\" className=\"giphy-embed\" allowFullScreen />\n\nYour responsibility is just to merge a pull request. The automation handles the rest. \n\nYou might say: _but I do not want to release on every merge, sometimes I merge changes that are not related to the functionality of the library_.\n\nThis is a valid point. You need a way to recognize if the given commit should trigger the release and what kind of version, PATCH, or MINOR. The way to do it is to introduce in your project [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) specification.\n\n## Conventional Commits\n\nAt [AsyncAPI Initiative](https://www.asyncapi.com/) we use [Semantic Versioning](https://semver.org/). This is why choosing [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) specification was a natural decision.\n\nPurpose of Conventional Commits is to make commits not only human-readable but also machine-readable. It defines a set of commit prefixes that can be easily parsed and analyzed by tooling.\n\nThis is how the version of the library looks like when it follows semantic versioning: `MAJOR.MINOR.PATCH`. How does the machine know what release you want to bump because of a given commit? Simplest mapping looks like in the following list:\n\n- Commit message prefix `fix: ` indicates `PATCH` release,\n- Commit message prefix `feat: ` indicates `MINOR` release,\n- Commit message prefix `{ANY_PREFIX}!: ` so for example `feat!:` or even `refactor!: ` indicate `MAJOR` release.\n\n\nIt other words, assume your version was 1.0.0, and you made a commit like `feat: add a new parameter to test endpoint`. You can have a script that picks up `feat: ` and triggers release that eventually bumps to version 1.1.0.\n\n## Workflow design\n\nAt [AsyncAPI Initiative](https://www.asyncapi.com/) where we introduced the release pipeline for the very first time, we had to do the following automatically:\n\n- Tag Git repository with a new version\n- Create GitHub Release\n- Push new version of the package to [NPM](https://www.npmjs.com/)\n- Push new version of Docker image to [Docker Hub](https://hub.docker.com/)\n- Bump the version of the package in `package.json` file and commit the change to the repository\n\nThis is how the design looks like:\n\n![npm docker release workflow](/img/posts/release-workflow.webp)\n\nThere are two workflows designed here. \n\nThe first workflow reacts to changes in the release branch (`master` in this case), decides if release should be triggered, and triggers it. The last step of the workflow is a pull request creation with changes in `package.json` and `package-lock.json`. Why are changes not committed directly to the release branch? Because we use branch protection rules and do not allow direct commits to release branches.\n\nYou can extend this workflow with additional steps, like:\n\n* Integration testing\n* Deployment\n* Notifications\n\nThe second workflow is just for handling changes in `package.json`. To fulfill branch protection settings, we had to auto-approve the pull request so we can automatically merge it.\n\n## GitHub Actions\n\nEven though I have [my opinion about GitHub Actions](https://dev.to/derberg/github-actions-when-fascination-turns-into-disappointment-4d75), I still think it is worth investing in it, especially for the release workflows.\n\nWe used the GitHub-provided actions and the following awesome actions built by the community:\n\n- [Create Pull Request](ttps://github.com/marketplace/actions/create-pull-request)\n- [Auto Approve](https://github.com/marketplace/actions/auto-approve)\n- [Merge Pull Request](https://github.com/marketplace/actions/merge-pull-requests)\n\n### Release workflow\n\nRelease workflow triggers every time there is something new happening in the release branch. In our case, it is the `master` branch:\n\n```yaml\non:\n  push:\n    branches:\n      - master\n```\n\n#### GitHub and NPM\n\nFor releases to GitHub and NPM, the most convenient solution is to integrate [semantic release](https://github.com/semantic-release/semantic-release) package and related plugins that support Conventional Commits. You can configure plugins in your `package.json` in the order they should be invoked:\n\n```json\n\"plugins\": [\n  [\n    \"@semantic-release/commit-analyzer\",\n    {\n      \"preset\": \"conventionalcommits\"\n    }\n  ],\n  [\n    \"@semantic-release/release-notes-generator\",\n    {\n      \"preset\": \"conventionalcommits\"\n    }\n  ],\n  \"@semantic-release/npm\",\n  \"@semantic-release/github\"\n]\n```\n\nConveniently, functional automation uses a [technical bot rather than a real user](https://www.thinkautomation.com/bots-and-ai/what-are-software-bots/). GitHub actions allow you to encrypt the credentials of different systems at the repository level. Referring to them in actions looks as follows: \n\n```yaml\n- name: Release to NPM and GitHub\n  id: release\n  env:\n    GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n    NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n    GIT_AUTHOR_NAME: asyncapi-bot\n    GIT_AUTHOR_EMAIL: info@asyncapi.io\n    GIT_COMMITTER_NAME: asyncapi-bot\n    GIT_COMMITTER_EMAIL: info@asyncapi.io\n  run: npm run release\n```\n\nAside from automation, the bot also comments on every pull request and issue included in the release notifying subscribed participants that the given topic is part of the release. Isn't it awesome?\n\n![pr info about release](/img/posts/pr-indicator.webp)\n\n#### Docker\n\nFor handling Docker, you can use some community-provided GitHub action that abstracts Docker CLI. I don't think it is needed if you know Docker. You might also want to reuse some commands during local development, like image building, and have them behind an npm script like `npm run docker-build`.\n\n```yaml\n- name: Release to Docker\n  if: steps.initversion.outputs.version != steps.extractver.outputs.version\n  run: | \n    echo ${{secrets.DOCKER_PASSWORD}} | docker login -u ${{secrets.DOCKER_USERNAME}} --password-stdin\n    npm run docker-build\n    docker tag asyncapi/generator:latest asyncapi/generator:${{ steps.extractver.outputs.version }}\n    docker push asyncapi/generator:${{ steps.extractver.outputs.version }}\n    docker push asyncapi/generator:latest\n```\n\n#### Bump version in package.json\n\nA common practice is to bump the package version in `package.json` on every release. You should also push the modified file to the release branch. Be aware though that good practices in the project are:\n\n- Do not commit directly to the release branch. All changes should go through pull requests with proper peer review.\n- Branches should have basic protection enabled. There should be simple rules that block pull requests before the merge.\n\nRelease workflow, instead of pushing directly to the release branch, should commit to a new branch and create a pull request. Seems like an overhead? No, you can also automate it. Just keep on reading.\n\n```yaml\n- name: Create Pull Request with updated package files\n  if: steps.initversion.outputs.version != steps.extractver.outputs.version\n  uses: peter-evans/create-pull-request@v2.4.4\n  with:\n    token: ${{ secrets.GH_TOKEN }}\n    commit-message: 'chore(release): ${{ steps.extractver.outputs.version }}'\n    committer: asyncapi-bot <info@asyncapi.io>\n    author: asyncapi-bot <info@asyncapi.io>\n    title: 'chore(release): ${{ steps.extractver.outputs.version }}'\n    body: 'Version bump in package.json and package-lock.json for release [${{ steps.extractver.outputs.version }}](https://github.com/${{github.repository}}/releases/tag/v${{ steps.extractver.outputs.version }})'\n    branch: version-bump/${{ steps.extractver.outputs.version }}\n```\n\n#### Conditions and sharing outputs\n\nGitHub Actions has two excellent features:\n\n- You can set conditions for specific steps\n- You can share the output of one step with another\n\nThese features are used in the release workflow to check the version of the package, before and after the GitHub/NPM release step. \n\nTo share the output, you must assign an `id` to the step and declare a variable and assign any value to it.\n```yaml\n- name: Get version from package.json after release step\n  id: extractver\n  run: echo \"::set-output name=version::$(npm run get-version --silent)\"\n```\n\nYou can access the shared value by the `id` and a variable name like `steps.extractver.outputs.version`. We use it, for example, in the condition that specifies if further steps of the workflow should be triggered or not. If the version in `package.json` changed after GitHub and NPM step, this means we should proceed with Docker publishing and pull request creation:\n\n```yaml\nif: steps.initversion.outputs.version != steps.extractver.outputs.version\n```\n\n#### Full workflow\n\nBelow you can find the entire workflow file:\n\n```yaml\nname: Release\n\non:\n  push:\n    branches:\n      - master\n\njobs:\n  release:\n    name: 'Release NPM, GitHub, Docker'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repo\n        uses: actions/checkout@v2\n      - name: Setup Node.js\n        uses: actions/setup-node@v1\n        with:\n          node-version: 13\n      - name: Install dependencies\n        run: npm ci\n      - name: Get version from package.json before release step\n        id: initversion\n        run: echo \"::set-output name=version::$(npm run get-version --silent)\"\n      - name: Release to NPM and GitHub\n        id: release\n        env:\n          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n          GIT_AUTHOR_NAME: asyncapi-bot\n          GIT_AUTHOR_EMAIL: info@asyncapi.io\n          GIT_COMMITTER_NAME: asyncapi-bot\n          GIT_COMMITTER_EMAIL: info@asyncapi.io\n        run: npm run release\n      - name: Get version from package.json after release step\n        id: extractver\n        run: echo \"::set-output name=version::$(npm run get-version --silent)\"\n      - name: Release to Docker\n        if: steps.initversion.outputs.version != steps.extractver.outputs.version\n        run: | \n          echo ${{secrets.DOCKER_PASSWORD}} | docker login -u ${{secrets.DOCKER_USERNAME}} --password-stdin\n          npm run docker-build\n          docker tag asyncapi/generator:latest asyncapi/generator:${{ steps.extractver.outputs.version }}\n          docker push asyncapi/generator:${{ steps.extractver.outputs.version }}\n          docker push asyncapi/generator:latest\n      - name: Create Pull Request with updated package files\n        if: steps.initversion.outputs.version != steps.extractver.outputs.version\n        uses: peter-evans/create-pull-request@v2.4.4\n        with:\n          token: ${{ secrets.GH_TOKEN }}\n          commit-message: 'chore(release): ${{ steps.extractver.outputs.version }}'\n          committer: asyncapi-bot <info@asyncapi.io>\n          author: asyncapi-bot <info@asyncapi.io>\n          title: 'chore(release): ${{ steps.extractver.outputs.version }}'\n          body: 'Version bump in package.json and package-lock.json for release [${{ steps.extractver.outputs.version }}](https://github.com/${{github.repository}}/releases/tag/v${{ steps.extractver.outputs.version }})'\n          branch: version-bump/${{ steps.extractver.outputs.version }}\n```\n\n## Automated merging workflow\n\nYou may be asking yourself:\n\n> _Why automated approving and merging is handled in a separate workflow and not as part of release workflow_\n\nOne reason is that the time between pull request creation and its readiness to be merged is hard to define. Pull requests always include some automated checks, like testing, linting, and others. These are long-running checks. You should not make such an asynchronous step a part of your synchronous release workflow. \n\nAnother reason is that you can also extend such an automated merging flow to handle not only pull requests coming from the release-handling bot but also other bots, that, for example, update your dependencies for security reasons. \n\nYou should divide automation into separate jobs that enable you to define their dependencies. There is no point to run the **automerge** job until the **autoapprove** one ends. GitHub Actions allows you to express this with `needs: [autoapprove]`\n\nBelow you can find the entire workflow file:\n\n```yaml\nname: Automerge release bump PR\n\non:\n  pull_request:\n    types:\n      - labeled\n      - unlabeled\n      - synchronize\n      - opened\n      - edited\n      - ready_for_review\n      - reopened\n      - unlocked\n  pull_request_review:\n    types:\n      - submitted\n  check_suite: \n    types:\n      - completed\n  status: {}\n  \njobs:\n\n  autoapprove:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Autoapproving\n        uses: hmarr/auto-approve-action@v2.0.0\n        if: github.actor == 'asyncapi-bot'\n        with:\n          github-token: \"${{ secrets.GITHUB_TOKEN }}\"\n\n  automerge:\n    needs: [autoapprove]\n    runs-on: ubuntu-latest\n    steps:\n      - name: Automerging\n        uses: pascalgn/automerge-action@v0.7.5\n        if: github.actor == 'asyncapi-bot'\n        env:\n          GITHUB_TOKEN: \"${{ secrets.GH_TOKEN }}\"\n          GITHUB_LOGIN: asyncapi-bot\n          MERGE_LABELS: \"\"\n          MERGE_METHOD: \"squash\"\n          MERGE_COMMIT_MESSAGE: \"pull-request-title\"\n          MERGE_RETRIES: \"10\"\n          MERGE_RETRY_SLEEP: \"10000\"\n```\n\nFor a detailed reference, you can look into [this pull request](https://github.com/asyncapi/generator/pull/242) that introduces the above-described workflow in the [generator](https://github.com/asyncapi/generator/).\n\n## Conclusions\n\nAutomate all the things, don't waste time. Automate releases, even if you are a purist that for years followed a rule of using [imperative mood](https://chris.beams.io/posts/git-commit/#imperative) in commit subject and now, after looking on prefixes from Conventional Commits you feel pure disgust.\n\n<iframe src=\"https://giphy.com/embed/8PmTor9XVnD3sxXHRe\" width=\"480\" height=\"435\" frameBorder=\"0\" className=\"giphy-embed\" allowFullScreen />\n\nIn the end, you can always use something different, custom approach, like reacting to merges from pull requests with the specific label only. If you have time to reinvent the wheel, go for it.\n\n*Cover photo by [Franck V.](https://unsplash.com/@franckinjapan) taken from Unsplash.*\n",
    "toc": [
      {
        "content": "What full automation means",
        "slug": "what-full-automation-means",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Conventional Commits",
        "slug": "conventional-commits",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Workflow design",
        "slug": "workflow-design",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "GitHub Actions",
        "slug": "github-actions",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Release workflow",
        "slug": "release-workflow",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "GitHub and NPM",
        "slug": "github-and-npm",
        "lvl": 4,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Docker",
        "slug": "docker",
        "lvl": 4,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Bump version in package.json",
        "slug": "bump-version-in-packagejson",
        "lvl": 4,
        "i": 7,
        "seen": 0
      },
      {
        "content": "Conditions and sharing outputs",
        "slug": "conditions-and-sharing-outputs",
        "lvl": 4,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Full workflow",
        "slug": "full-workflow",
        "lvl": 4,
        "i": 9,
        "seen": 0
      },
      {
        "content": "Automated merging workflow",
        "slug": "automated-merging-workflow",
        "lvl": 2,
        "i": 10,
        "seen": 0
      },
      {
        "content": "Conclusions",
        "slug": "conclusions",
        "lvl": 2,
        "i": 11,
        "seen": 0
      }
    ],
    "slug": "/blog/automated-releases",
    "filePath": "pages/blog/automated-releases.md"
  },
  {
    "meta": {
      "title": "Nunjucks templating explained on the basis of AsyncAPI specification",
      "date": "2020-03-03T07:00:00.000Z",
      "type": "Engineering",
      "tags": [
        "Nunjucks"
      ],
      "cover": "/img/posts/nunjucks-asyncapi-cover.webp",
      "authors": [
        {
          "name": "Lukasz Gornicki",
          "photo": "/img/avatars/lpgornicki.webp",
          "link": "https://twitter.com/derberq",
          "byline": "AsyncAPI Maintainer and Dev Comm Keeper"
        }
      ],
      "readingTime": 7,
      "excerpt": "Edit 14.04.2021\nIn this post, I explain how you can use Nunjucks to template information extracted from an AsyncAPI file. I also write how you can make it even easier using Nunjucks inside the AsyncAP"
    },
    "content": "\n> **Edit 14.04.2021**\nIn this post, I explain how you can use Nunjucks to template information extracted from an AsyncAPI file. I also write how you can make it even easier using Nunjucks inside the AsyncAPI Generator. Now, we also have a [React-based](https://github.com/asyncapi/generator/blob/master/docs/authoring.md#react) render engine inside the generator, and it is far more developer-friendly. I encourage you to try it out. \n\n\nSpecifications exist for a reason. Among other things, they help to bring quality, consistency, and standardize a given area. They are a great use case for templating engines. You can prepare a template that generates something from any document that follows a particular specification. You can generate whatever you want, docs, code, and diagrams. The sky is the limit. \n\nTemplating is a vast topic that is impossible to cover in a single post. In JavaScript alone, there is a zoo of different [templating engines](https://colorlib.com/wp/top-templating-engines-for-javascript/). This is why I focus here only on one engine for JavaScript, which is [Nunjucks](https://mozilla.github.io/nunjucks/). Why? Soon you'll figure that out.\n\n> **tl;dr**\nIn case you don't want to read and prefer to jump right into code. Go to this CodeSandbox project, but keep in mind you'll miss the important context and explanation.\n[![Edit learning-nunjucks](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/learning-nunjucks-wis89?fontsize=14&hidenavigation=1&theme=dark)\n\n## What is AsyncAPI?\n\n![](/img/posts/nunjucks-asyncapi.webp)\n\n[AsyncAPI](https://www.asyncapi.com/) is a specification that you use to create machine-readable definitions of your event-driven APIs:\n\n- It focuses on the application from the API user perspective. You describe what the user can do with the API, subscribe or publish to it.\n- It is protocol-agnostic so that you can use it for APIs using Kafka or MQTT, and many others.\n- It supports many different schema formats, so you can describe messages payload schema in a format that you already use like, for example, Avro.\n\n## What is Nunjucks?\n\n![](/img/posts/nunjucks-nunjucks.webp)\n\n[Nunjucks](https://mozilla.github.io/nunjucks/) is a templating engine for JavaScript, inspired by [Jinja](https://palletsprojects.com/p/jinja/). It has many nifty features that make templating really nice:\n\n- Variables declaration\n- Built-in filters\n- Way to create custom filters\n- Chaining filters\n- Includes\n- Macros\n\n## Nunjucks basics by example\n\nAll examples shown in this post can be explored in action in below CodeSandbox project.\n\n<iframe src=\"https://codesandbox.io/embed/learning-nunjucks-wis89?autoresize=1&codemirror=1&fontsize=14&theme=dark\" className=\"w-full h-64 border-0 rounded overflow-hidden\" title=\"learning-nunjucks\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\" />\n\nIn this learning project, I created a simple Express app that handles super short documentation generated from the AsyncAPI file. It is just a small sample of things that you can get from AsyncAPI using Nunjucks.\n\nI picked Nunjucks here for a reason. AsyncAPI community maintains [a tool for generating](https://github.com/asyncapi/generator/) different things from the specification document, and it is using Nunjucks as a templating engine. This basically means, use my CodeSandbox to experiment with Nunjucks, but if you plan to build some serious template for AsyncAPI, do it with the [generator](https://github.com/asyncapi/generator/) or reuse existing templates.\n\n### Variables declaration\n\nYou can declare inside the template a variable, that helps you in cases like loops. Their great use case is the same as in programming. If you have a value that you use more than once, assign it to a variable.\n\nI used it to keep the name of the API:\n```html\n{% set apiName = asyncapi.info().title() %}\n```\n\nThen I could use it multiple times, for example in these sentences:\n```html\n<!-- Sentence 1 -->\nThe {{ apiName }} is licensed under {{ asyncapi.info().license().name() }}.\n\n<!-- Sentence 2 -->\n<p>Here you can find a list of channels to which you can publish and <strong>{{ apiName }}</strong> is subscribed to:</p>\n```\n\n### Built-in filters\n\nUnlike other engines, Nunjucks comes with many built-in helpers, called filters. There are around 40 different. You can for example easily make a value all uppercase:\n\n```html\n<!-- server.protocol() value comes as all lowercase -->\nusing {{ server.protocol() | upper }} protocol\n```\n \n### Creating custom filters\n\nBuilt-in filters are awesome, but sometimes you need to create your filters. In my example, I had to build a filter that helps me to modify the `server.url()` value. \n\nIn the AsyncAPI document, you can specify a server that the application uses to publish and consume messages from. In the URL, you are allowed to use variables like this: `test.mosquitto.org:{port}`. Such a variable can be described with different levels of detail. You can provide a default value and even an enum of values. \n\nIn my example, instead of a URL like `test.mosquitto.org:{port}`, I wanted to get a fixed URL with a proper port number taken from the document:\n\n```js\n//replace is performed only if there are variables in the URL and they are declared for a server\nfunction replaceVariablesWithValues(url, serverVariables) {\n  const urlVariables = getVariablesNamesFromUrl(url);\n  const declaredVariables = urlVariables.filter(el =>\n    serverVariables.hasOwnProperty(el[1])\n  );\n\n  if (urlVariables.length !== 0 && declaredVariables.length !== 0) {\n    let value;\n    let newUrl = url;\n\n    urlVariables.forEach(el => {\n      value = getVariableValue(serverVariables, el[1]);\n\n      if (value) {\n        newUrl = newUrl.replace(el[0], value);\n      }\n    });\n    return newUrl;\n  }\n  return url;\n}\n\nfunction getVariablesNamesFromUrl(url) {\n  let result = [],\n    array;\n  const regEx = /{([^}]+)}/g;\n\n  while ((array = regEx.exec(url)) !== null) {\n    result.push([array[0], array[1]]);\n  }\n\n  return result;\n}\n\nfunction getVariableValue(object, variable) {\n  const keyValue = object[variable]._json;\n\n  if (keyValue) return keyValue.default || (keyValue.enum && keyValue.enum[0]);\n}\n```\n\nSuch a filter is very handy to use, the same as the built-in filters. You can additionally enrich its context. Take a look below where you can see that my filter gets not only `server.url()` value as a context but also `server.variables()`:\n```html\n{{ server.url() | replaceVariablesWithValues(server.variables()) }}\n```\n\n### Chaining filters\n\nBuilt-in filters, custom filters...that is not all. Chaining of the filters is like an icing on the cake.\n\n![](/img/posts/nunjucks-cherry.webp)\n\nThe same case with URL. The URL after replacing variables with values, I want to transform it into a clickable element and make it part of the DOM. All of it made easy thanks to chaining:\n\n```html\n{{ server.url() | replaceVariablesWithValues(server.variables()) | urlize | safe }}\n```\n\n### Includes\n\nYou can share static parts of the template. This allows you to decrease the size of templates and make maintenance easier. My example here is not very complex, and I've added it to the template to make the point that it is possible:\n\n```html\n<!-- content of space.html file -->\n<hr />\n<br />\n```\n\nI can include it as many times as I want across the templates like this:\n```html\n{% include \"space.html\" %}\n```\n\n### Macros\n\nYou can share not only static but also dynamic parts of the template. What does it mean? Let's take an HTML list as an example. From the syntax/structure perspective, it always looks the same, but the displayed values of the list are different. Macros are here to help you out to define a list element once. It is like a mixture of the include and a filter.\n\nIn the AsyncAPI document, I have a case where I want to list all the channels that the application uses. Actually, I want to have two lists: one list that has channels where the application is subscribed (`publish` operation) to receive messages and the other one where the application publishes (`subscribe` operation) messages to.\n\nFirst you define a macro:\n```html\n{% macro listEl(value) %}\n<li><strong>{{ value }}</strong></li>\n{% endmacro %}\n```\n\nThen you can import macros in your template:\n```html\n{% import \"macros.html\" as helpers %}\n```\n\nYou call macros like you typically call functions:\n\n```html\n{{ helpers.listEl(channelName) }}\n```\n\n## Conclusion\n\nDon't build tools from scratch if there are others already available, and they are open for contributions. Trying something from scratch, as I did with the templating CodeSandbox for AsyncAPI, makes sense only for learning purposes.\n\nKeep in mind that [AsyncAPI](https://www.asyncapi.com/) is an open community. We do not work on the specification only, but tools too. Join us on [Slack](https://www.asyncapi.com/slack-invite/) and help us build awesome tools or [donate](opencollective.com/asyncapi).\n\nTake time to look into the [parser-js](https://github.com/asyncapi/parser-js/). I used it in my CodeSandbox to parse the AsyncAPI document to pass it to templates as a context.\n",
    "toc": [
      {
        "content": "What is AsyncAPI?",
        "slug": "what-is-asyncapi",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "What is Nunjucks?",
        "slug": "what-is-nunjucks",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Nunjucks basics by example",
        "slug": "nunjucks-basics-by-example",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Variables declaration",
        "slug": "variables-declaration",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Built-in filters",
        "slug": "built-in-filters",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Creating custom filters",
        "slug": "creating-custom-filters",
        "lvl": 3,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Chaining filters",
        "slug": "chaining-filters",
        "lvl": 3,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Includes",
        "slug": "includes",
        "lvl": 3,
        "i": 7,
        "seen": 0
      },
      {
        "content": "Macros",
        "slug": "macros",
        "lvl": 3,
        "i": 8,
        "seen": 0
      },
      {
        "content": "Conclusion",
        "slug": "conclusion",
        "lvl": 2,
        "i": 9,
        "seen": 0
      }
    ],
    "slug": "/blog/using-nunjucks-with-asyncapi",
    "filePath": "pages/blog/using-nunjucks-with-asyncapi.md"
  },
  {
    "meta": {
      "title": "AsyncAPI 2.0.0 important dates",
      "date": "2019-06-12T09:56:52.000Z",
      "type": "Communication",
      "tags": [
        "Project Status"
      ],
      "cover": "/img/posts/v2-important-dates.webp",
      "authors": [
        {
          "name": "Fran Méndez",
          "photo": "/img/avatars/fmvilas.webp",
          "link": "https://twitter.com/fmvilas",
          "byline": "AsyncAPI founder"
        }
      ],
      "excerpt": "Hey folks! After some time thinking about it, I've decided it's time to define some important dates for AsyncAPI 2.0.0. So here we go!",
      "readingTime": 2
    },
    "content": "\nHey folks! After some time thinking about it, I've decided it's time to define some important dates for AsyncAPI 2.0.0. So here we go!\n\n## End of review period (July 1, 2019)\n\nAfter some time, many people have reviewed the specification and they've identified some [issues that need to be addressed](https://github.com/asyncapi/asyncapi/issues?q=is%3Aopen+is%3Aissue+label%3A%22v2.0.0+review%22) before we launch the version 2.0.0. Actually, this process will never finish but we have to decide on a date to stop reviewing and move forward. This date is July 1. After this day, reviews are still welcome but they will not make into version 2.0.0, and will have to wait for the next version.\n\n## Beta testing program (July-September)\n\nRight after we're clear on what's going to be the final version 2.0.0, we'll start working on improving all the tooling and make sure they support version 2.0.0 well. Tools are going to be open source as always so feel free to test them with your own use cases and let us know how it works! Either it sucks or it's amazing :)\n\nI'll personally track some of these tests to make sure everything is smooth. If you want to participate in the Beta testing program, feel free to reach out to me on our [Slack channel](https://www.asyncapi.com/slack-invite) or send me an email to [fmvilas@gmail.com](mailto://fmvilas@gmail.com).\n\n## Official announcement (Late September-Early October)\n\nWe'll announce the final version of AsyncAPI 2.0.0 during September-October timeframe. This doesn't mean you'll have to wait until then to use it. Remember everything is open source.\n\nWe're planning on announcing it in a great conference. Stay tuned!\n\n---\n\nHope this helps clarify the roadmap a little bit. I'll update the exact dates here as we decide on them. Thanks for reading!\n\nUntil next time! 👋",
    "toc": [
      {
        "content": "End of review period (July 1, 2019)",
        "slug": "end-of-review-period-july-1-2019",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Beta testing program (July-September)",
        "slug": "beta-testing-program-july-september",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Official announcement (Late September-Early October)",
        "slug": "official-announcement-late-september-early-october",
        "lvl": 2,
        "i": 2,
        "seen": 0
      }
    ],
    "slug": "/blog/v2-important-dates",
    "filePath": "pages/blog/v2-important-dates.md"
  },
  {
    "meta": {
      "title": "An API Strategist Explores Event-Driven APIs",
      "date": "2019-05-14T15:56:52.000Z",
      "type": "Strategy",
      "tags": [
        "APIs",
        "EDA",
        "Interview"
      ],
      "cover": "/img/posts/an-api-strategist-explores-event-driven-apis.webp",
      "authors": [
        {
          "name": "Emmelyn Wang",
          "photo": "/img/avatars/ewang.webp",
          "link": "https://twitter.com/lifewingmate",
          "byline": "API Strategy Catalyst"
        }
      ],
      "excerpt": "If you’re like me and have experience with web services and the paradigm of RESTful, web services, and SOAP APIs, but curious about event-driven, message based, or streaming APIs, this article is for you.",
      "readingTime": 16
    },
    "content": "\n# An API Strategist Explores Event-Driven APIs\n\nIf you’re like me and have experience with web services and the paradigm of RESTful, web services, and SOAP APIs, but curious about event-driven, message based, or streaming APIs, this article is for you.\n\nI virtually sat down with these experts:\n\n* [Fran Mendez](https://twitter.com/fmvilas), Founder of [AsyncAPI](https://twitter.com/AsyncAPISpec)\n\n* [Jonathan Schabowsky](https://twitter.com/JSchabowsky), Chief Architect, [Solace](https://twitter.com/solacedotcom)\n\n* [David McKenna](https://www.linkedin.com/in/david-mckenna-05726b1), SVP, Research & Development, [Axway](https://twitter.com/Axway)\n\n* [Eric Horesnyi](https://twitter.com/EricHoresnyi), General Manager, APIs & Integration, Axway (CEO of [Streamdata.io acquired by Axway](https://twitter.com/StreamdataIO))\n\nQuestion 1: **What do you think is the most important value proposition of event-driven architecture and event-driven/messaging APIs?**\n\nQuestion 2: **What is the consumption experience of messaging APIs and how much does it differ from RESTful APIs?**\n\nFor example, at the time of writing can’t just mock up the API and run it in a Postman collection and transform it (convert the technical specification to the version I want such as YAML to RAML or JSON, for example) and consume it.\n\nTry [http://editor.asyncapi.org](http://editor.asyncapi.org/) to understand the sister spec to OpenAPI (OAS).\n\nQuestion 3: **Today, how can I test drive event-driven APIs out in the wild?**\n\nMy frame of reference with REST APIs: I can inspect HTTP calls in a browser and mock up the API. I can run the API calls in API Builder or Stoplight or Postman and get an InVision conceptual app to consume the API, for example. I can use Stoplight to lint or APIMatic to create starter SDKs to test drive.\n\nQuestion 4: **How do you measure event-driven APIs?**\n\nI was thinking about how you measure the *effects* of event-driven APIs. For example, how can various types of calls live within dashboards for the sake of analytics and measurement? Future Trend: Is there a way to get wholistic data from webhooks, RESTful/JSON, SOAP/WSDL/WADL/XML, GraphQL, gRPC, etc.?\n> POV: The future of APIs is the unified catalog having a matching data-driven view. [lifewingmate](https://twitter.com/lifewingmate)\n\n## For the greater API Community\n\nRecommendations are the most important piece of the event-driven architecture value proposition. Business leaders only care about event-driven architecture as much as the end result produces the business-driving experience that specifically this type of architecture can produce.\n\n> Technology and consulting organizations need to know when and how to recommend event-driven architecture, APIs and microservices, and corresponding methods of implementation.\n> How they impact my current product engine? What business results justify the spend? — [lifewingmate](https://twitter.com/lifewingmate)\n\nHere we go!\n\n## Question 1: What do you think is the most important value proposition of event-driven architecture?\n\nFran: I’d say most interesting for me are:\n\n* loose coupling between services (if a downstream service breaks the others just work fine),\n\n* they’re fault-tolerant since events are queued or stored somewhere, and processed once the service is up and running again, and\n\n* they allow you to build real-time products easily.\n\nJonathan: 1) **Loose Coupling**— As Fran states, apps do not have to know how many different apps they are consuming data from. Rather they just care about what data they are consuming. This [scenario] is extremely powerful.\n\nAlso, data today is RARELY consumed only once, rather, it goes into big data and analytics platforms. The loose coupling described allows you to have this for free.\n\n2) **Reactive to Change** — Instead of polling, consumers can register their their interest (subscribe) and react to changes in real-time. The producer just sends events, and does not care if anyone is interested… fire and forget… Meanwhile clients that are subscribed get the data in realtime and can react. This is useful where you want to service customers in real-time.\n\n3) **Scale**— Want to be able to consume events, in order, across millions of devices? How about do 500k messages per second guaranteed of capital market trades?\n\n> Asynchronous interactions enable enterprises to do things which are nearly impossible to do synchronously.\n> — [JSchabowsky](https://twitter.com/JSchabowsky)\n\nDavid, Eric: Event-driven architecture brings comfort to end users and efficiency to the web at individual component level and at system level:\n\n* UX in Frontends\n\n* Network\n\n* APIs\n\n* Backends\n\n* Behind the API: Application languages, data plane, and DevOps\n\n* Entire System\n\n**UX in Frontends** The [most popular](https://hackr.io/blog/10-best-javascript-frameworks-2019) reactive frameworks (AngularJS, ReactJS, VueJS) react to streams of events presented to their [observables](https://streamdata.io/blog/realtime-event-driven-app-with-riot-xignite-and-streamdata-io/), a data plane presenting events to the UI.\n\nWhy is that? Because, we -mobile and desktop human users- want to be presented data in real-time:\n\n* Where is my cab? \nWhat is the price of my favorite share, now?\n\n* At what time will my train arrive at destination ?\n\nYes, our life is real-time: we do not want to waste any time and we do not want to miss anything that happens in the world ([FOMO](https://en.wikipedia.org/wiki/Fear_of_missing_out) — Fear Of Missing Out).\n\nGood news: Events improve latency of the UI by factor x20 according to our [benchmark](https://streamdata.io/blog/ui-latency-json-patch/), and avoids for users to have to refresh their UI to get the latest from their newsfeed, stocks or favorite transportation, as our [reptilian brain](https://streamdata.io/blog/animated-data/) is naturally used to [understanding].\n\n**Network** Since 2011, with the advent of social networks and to support reactive UI, the web has RFCed protocols for low-volume bidirectional/peer-to-peer traffic (**Websockets**) and server to client push over HTTP ([SSE](https://streamdata.io/blog/push-sse-vs-websockets/)). For lower volume of events, typically for alerts, **webhooks** have become popular.\n\n**APIs** Most API calls are useless: up to 98.5% according to [Zapier](https://news.ycombinator.com/item?id=6360474) who created the concept of Polling Madness. That is because the API client does not know when data will change, so would keep polling an API to make sure it does not miss any update. Event-Driven Architecture in APIs reverses the paradigm: why don’t we have the component who know when data change to take charge, instead of answering to useless calls?\n\nThis [situation] leads to the API server pushing streams of events to the API client who have subscribed to a topic. Traffic hence goes north-south only when necessary, rather than south-north-south to hit updates randomly. Augmenting a REST API with a streaming API typically brings [90% efficiency](https://streamdata.io/blog/benchmark-server-sent-events-versus-polling/) in CPU and network use for most demanding traffic.\n\n**Backends** In some industries, backends have been using evented architecture for a while.\n\n**Behind the API: Application Languages, data plane, and DevOps** \nBackend architectures have relied on events for a while, before REST was created. In my Flashboy days in [High Frequency Trading](https://www.infoq.com/podcasts/eric-horesnyi-ai-hft), we were pushing events from exchanges to hedge funds to allow them to stay in front of the market (making big money at low risk, I’m repentant), using IP-based tweaks (IP multicast and their famous storms), and proprietary middleware.\n\nSince then, message buses have evolved to open standards adopted outside finance (thanks Linkedin for **Kafka**), and -as already noted- the web has made it possible to transport events over HTTP. Additionally, and almost at the same time, people -like [myself](https://streamdata.io/blog/network-based-architecture-fielding-fowler-and-haussmann/)- having advocated microservices for years without seeing convergence of best practices are now contented: **Kubernetes** is here, and has instantly been adopted by all architects and DevOps to prepare their ideal microservices architecture.\n\nAnd when you dig into Kubernetes and associated frameworks Istio and Envoy, what do you find? REST APIs of course, but that was expected by definition of microservices. What you also find is Async APIs for each microservice. Kaboom! Backends now have a blueprint for quite a few years: Kafka and Kubernetes to orchestrate data flows, control and scale them. And this blueprint is entirely event-driven.\n\nTo top it all and not surprisingly, languages traditionally used to create application layers linked to databases have also gone through their event revolution with reactive extensions such as **RxJava** widely adopted by the Java community. Now the entire backend dev, DevOps, and IT community can focus on what will make them able to compete with agility over the web.\n\n**Entire System** If we take a helicopter view to look at the entire system, what does the event-driven revolution?\n\nThe entire chain from data plane, app, API, network down to the frontends are event-driven: Event flow between IoT devices (eg GPS), mobile apps, and ML without any barrier, people can all align thinking in terms of data streams of events rather than databases, considering intensity and relevance of feeds rather than states and calls.\n\nAs all components have embraced the EDA revolution (I prefer evolution -revolution is always violent- as this is happening with live clients to be supported at the same time, hence slowly, but based on a Darwinian selection of design). This new **end-to-end chain of events** brings simplicity and efficiency to components individually and collectively.\n\n## Question 2: What is the consumption experience of event-driven APIs? How much does it differ from RESTful APIs?\n\nFran: You usually connect to a broker to start sending and/or receiving messages. Examples of brokers are RabbitMQ, Kafka, Solace, etc. The difference with synchronous patterns like REST, gRPC, and GraphQL is that you don’t ask for information. You don’t make requests.\n\nJust connect to the broker and subscribe to a channel of your interest. Eventually (no pun intended), you’ll get this information, such as when the events occur. Similarly, you’ll send events to the broker whenever they occur to you. (replace you with your service)\n\nJonathan: Today, the consumption experience generally sucks! This is a gap in the market AsyncAPI is solving and Solace [and several other companies, organizations, and individuals] is looking to help solve too… help make the experience as pleasant as with RESTful APIs.\n\nDavid, Eric: There are many different technologies for providing event driven APIs\n\n* Server-Sent Events (SSE) for pushing data to the client to provide reactive user experience\n\n* Webhooks for making HTTP callbacks on state change\n\n* HTML5 Websockets providing full-duplex communication channels over a single TCP connection between client and server.\n\n* MQTT and AMQP for IoT use cases\n\n## Question 3: Today, how can I test drive event-driven APIs out in the wild?\n\nFran: You can’t or is not easy. Part of the reason for the existence of AsyncAPI is precisely to enable that.\n\nJonathan: Check out [cloud.solace.com](https://cloud.solace.com) … Sign up for an account (free) and play around. Create an event broker (think of that like an API gateway) and look at our runnable code pen examples. This is all more infrastructure based…. Now imagine AsyncAPI and you layer that on top, it becomes more like API management. Also, check out this blog [https://solace.com/blog/api-management-event-management/](https://solace.com/blog/api-management-event-management/)\n\n*(Emmelyn) I can inspect HTTP calls in a browser and mock up the API and run it in Postman and get an InVision conceptual app to consume the API, for example.*\n \nYou can kind of do this at [cloud.solace.com](https://cloud.solace.com)… Again its more how do you send/receive messages… with no app context, but its a start and the most useful I have ever found.\n\n*(Emmelyn) I can use Stoplight to lint or APIMatic to create starter SDKs to “try it”*\n\nSee previous comment and try it out and give me feedback!\n\nDavid, Eric: Many of the traditional testing tools do not natively support event- driven protocols and are built for standard HTTP request/response found in REST based services. In order to help support the testing of SSE a client SDK is provided to help build automated clients to test both functional and non-functional aspects of SSE services.\n\n## Question 4: How do you measure event-driven APIs?\n\nFran: You don’t have “calls” because you don’t ask for anything. You just show your interest in certain types of events and wait for them to happen. That’s a subscriber/consumer. If you’re building a publisher/producer then you’ll send events to the broker when certain events occur. The consumers interested in your type of event will receive them.\n\nJonathan: I think effectiveness is a direct correlation between consumption. An event that is consumed 0 times was actually worth 0… an event consumed 100 times is valuable. Yes, you do this via dashboards. Today, nobody deals with BOTH events and synchronous apis in one platform.\n\nDavid, Eric: The enhanced user experience in the client can be tracked by NPS of the service.\n\nTraditional monitoring tools are optimized for request-response scenario, asynchronous scenarios bring in additional complexity where by a single request could result in N number of responses been relayed to the client. Adoption of OpenTracing can help to see the spans of distributed transactions.\n\n## Value Proposition of Event-Driven Architecture\n\n**Business leaders only care about event-driven architecture as much as the end result produces the business-driving experience that specifically this type of architecture can produce. What would you explain to this type of audience?**\n\nFran’s take\n\n* Real-time experiences are built with event-driven architectures. You can’t build something real-time with REST APIs or any of the aforementioned styles.\n\n* Solace has an interesting concept called “event mesh” and [Jonathan](http://twitter.com/Jonathan) Schabowsky can explain better and point to existing documentation.\n\n* And then you have the cool thing about event-driven microservices, which allows you to build products faster. It allows you to spend less time worrying about the systems and more about your business logic.\n\nEric’s take\n\nAs a CEO myself, I do not invest in any feature of any technology until I can see proven track records and numbers. Well, EDA actually brings sizeable benefits in terms of topline, customer satisfaction, cost base, competitive differentiation and even HR attractiveness and retention:\n\n* Topline\n\n* Customer Satisfaction\n\n* Outsmart your Competitors with Machine Learning ML\n\n* IT Cost Base Reduction\n\n* HR\n\n**Topline** The main benefits of the EDA mindset is to optimize the time it takes between the occurrence of an event in the universe, and the reaction by the company to that event. Each industry has its own metrics for assessing such benefit. In capital markets, 1 millisecond is worth **[$8m](https://research.tabbgroup.com/report/v06-007-value-millisecond-finding-optimal-speed-trading-infrastructure)** (!)\n\nIn marketplace/ecommerce/retail/logistics business where players make as much money as they can reduce the time between an order is placed to them, and such order is shipped to the end user, each second count. I did a quick calculation of how much a second is worth for Amazon, by dividing revenue by the number of seconds in a year: **$50m** (!)\n\n**Customer Satisfaction** As already noted, reactive interfaces are not only the coolest but also the most natural for our human brain. Well, we can put a number on this: [100 ms is worth 1%](https://perspectives.mvdirona.com/2009/10/the-cost-of-latency/) additional revenue on any mobile or desktop app, from mobile banking to eCommerce.\n\nFor developers using your API, when you can provide your most important customer the ability to consume your API without limit, they are happy to pay a premium for it as it means they have more data to make decision upon, and it helps streamlining their data ingestion chain.\n\n**Outsmart your Competitors with ML** A major way for technology to bring value to customer interactions (chatbots), optimize processes and make best-possible decisions in an ever-changing world is Machine Learning. And Machine Learning thrives on data. In the past, data architectures were based on tables and data lakes. Well, for practitioners, data lakes actually became data swamps.\n\nWith some experience, the key is to master data ingestion so that data sources are consumed upstream, as close as possible to the source, and turned into value as soon as possible by Machine Learning. Machine Learning consumes streams of data conveyed by Kafka from third party streaming APIs, such as [Xignite Cloudstreaming](https://www.xignite.com/product/CloudStreaming), learn from them as they come and learns from its errors against what it had predicted.\n\nAnd the closer you are from data sources (acting as senses for the ML brain), the smarter your ML brain will be, faster than your competition. There is even a family of ML updating their model for each, called [Massive Online Analysis](https://moa.cms.waikato.ac.nz/) or Streaming Algorithms. EDA has even invaded ML.\n\n**IT Cost Base Reduction** With the 90%+ gains in efficiency that we have mentioned earlier, an API vendor servicing clients with events can not only make them happier, but also reduce its cloud bill on CPU and network by 90% on these use cases. As cloud bills have become so high and critical to become visible to executive desks, they should understand the impact.\n\n**HR** I believe we would agree that developers and DevOps like new and efficient [tools]. And events are fun while bringing efficiency. Working with events makes your organization more attractive to new developers, and help keeping them happy while working on cutting-edge technology. As developers cannot meet the demand while “software is eating the world” this [circumstance] alone could be a driver for considering and EDA and API and Microservices first approach in your organization.\n\n## Question: How and when should companies actively choose event-driven architecture?\n\n*For example, how is discovery performed? Which APIM catalogs can showcase event-driven APIs so that companies can decide to consume rather than build it themselves? What kind of guidance and best practices can we provide?*\n\nDavid and Eric advise\n\n**IoT** — Many companies are looking to leverage IoT in their offering such as car insurance (pay as you drive), healthcare (health monitoring).\n\nA vast variety of low-price devices (sensors, thermostats, robots, etc.) with internet connectivity is flooding the market. Their value does not lie in the hardware but in the services that are/will be attached to it. The infrastructure that support these services must have a real-time processing capability to provide real value back to the consumer.\n\n**MQTT** is becoming the de-facto standard to exchange data with IoT devices because it is simple and efficient on low memory devices. It is also based on a Publish/Subscribe model that will force the companies to adopt an EDA in order to process all the generated events.\n\n**Cloud** — Adaption of cloud-based services in Enterprise adds more integration patterns (Cloud-to-cloud, Cloud-to-ground, Ground-to-Cloud, ..) thus more complexity. The different systems needs to exchange data to keep a coherent state across the applications. Using a point-to-point integration strategy can quickly become a trap because of the exponential complexity and tight coupling between the different systems.\n\nEDA enables a loose coupling between the components/apps in order regain agility, increases innovation pace and reduces time-to-market for new features/services.\n> # In general, I’m studying API Design Patterns and how various kinds of APIs expedite R&D adoption. What business results are accelerated from these kinds of patterns?\n> Thanks for suggesting topics and connecting with feedback. You can also reach me via Twitter @lifewingmate DM or via the AsyncAPI community via our [Github](https://github.com/asyncapi) or [Slack channel](http://asyncapi.slack.com).\n\nDisclaimer: The professional opinions of those interviewed do not necessarily reflect the organizations they represent. These interviewees volunteered their time and contributions to support the AsyncAPI initiative and community.\n",
    "toc": [
      {
        "content": "An API Strategist Explores Event-Driven APIs",
        "slug": "an-api-strategist-explores-event-driven-apis",
        "lvl": 1,
        "i": 0,
        "seen": 0
      },
      {
        "content": "For the greater API Community",
        "slug": "for-the-greater-api-community",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Question 1: What do you think is the most important value proposition of event-driven architecture?",
        "slug": "question-1-what-do-you-think-is-the-most-important-value-proposition-of-event-driven-architecture",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Question 2: What is the consumption experience of event-driven APIs? How much does it differ from RESTful APIs?",
        "slug": "question-2-what-is-the-consumption-experience-of-event-driven-apis-how-much-does-it-differ-from-restful-apis",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Question 3: Today, how can I test drive event-driven APIs out in the wild?",
        "slug": "question-3-today-how-can-i-test-drive-event-driven-apis-out-in-the-wild",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Question 4: How do you measure event-driven APIs?",
        "slug": "question-4-how-do-you-measure-event-driven-apis",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Value Proposition of Event-Driven Architecture",
        "slug": "value-proposition-of-event-driven-architecture",
        "lvl": 2,
        "i": 6,
        "seen": 0
      },
      {
        "content": "Question: How and when should companies actively choose event-driven architecture?",
        "slug": "question-how-and-when-should-companies-actively-choose-event-driven-architecture",
        "lvl": 2,
        "i": 7,
        "seen": 0
      },
      {
        "content": "In general, I’m studying API Design Patterns and how various kinds of APIs expedite R&D adoption. What business results are accelerated from these kinds of patterns?",
        "slug": "in-general-im-studying-api-design-patterns-and-how-various-kinds-of-apis-expedite-rd-adoption-what-business-results-are-accelerated-from-these-kinds-of-patterns",
        "lvl": 1,
        "i": 8,
        "seen": 0
      }
    ],
    "slug": "/blog/an-api-strategist-explores-event-driven-apis",
    "filePath": "pages/blog/an-api-strategist-explores-event-driven-apis.md"
  },
  {
    "meta": {
      "title": "AsyncAPI and CloudEvents",
      "date": "2019-05-11T15:56:52.000Z",
      "type": "Engineering",
      "tags": [
        "CloudEvents",
        "Specification",
        "Serverless"
      ],
      "cover": "/img/posts/asyncapi-cloudevents.webp",
      "authors": [
        {
          "name": "Fran Méndez",
          "photo": "/img/avatars/fmvilas.webp",
          "link": "https://twitter.com/fmvilas",
          "byline": "AsyncAPI founder"
        }
      ],
      "excerpt": "There is the belief by many people that AsyncAPI and CloudEvents are competing for the same thing. This can't be less true, and I'd like to explain you why. Read on!",
      "readingTime": 5
    },
    "content": "\nI've been receiving the same question for a long time now: Should I use CloudEvents or AsyncAPI? — And my response has always been the same: it depends!\n\nThere is the belief by many people that AsyncAPI and CloudEvents are competing for the same thing. This can't be less true, and I'd like to explain you why. Read on!\n\n# What is CloudEvents?\n\nFrom [cloudevents.io](https://cloudevents.io):\n\n> Enter CloudEvents, a specification for **describing event data in a common way**. CloudEvents seeks to ease event declaration and delivery across services, platforms and beyond!\n\nThe purpose of CloudEvents is to establish a common format for event data description. And it makes a lot of sense when you realize they are part of the [CNCF’s Serverless Working Group](https://github.com/cncf/wg-serverless).\n\nIf you are doing serverless or FaaS (Function as a Service), then CloudEvents is your best friend because the event is the only information you will have in your function during runtime. No topics or channels, no servers, no subscribers. Just the event and some extra information you may need to make your function work.\n\n**CloudEvents is focused on the event** and defines an envelope for your application's data. See an example from their repo:\n\n```json\n{\n    \"specversion\" : \"0.2\",\n    \"type\" : \"com.github.pull.create\",\n    \"source\" : \"https://github.com/cloudevents/spec/pull/123\",\n    \"id\" : \"A234-1234-1234\",\n    \"time\" : \"2018-04-05T17:31:00Z\",\n    \"comexampleextension1\" : \"value\",\n    \"comexampleextension2\" : {\n        \"othervalue\": 5\n    },\n    \"contenttype\" : \"text/xml\",\n    \"data\" : \"<much wow=\\\"xml\\\"/>\"\n}\n```\n\nHere your event is actually `<much wow=\\\"xml\\\"/>` and the rest is meta information about your event. This envelope is what CloudEvents defines with the purpose of making event declaration reusable across services and platforms.\n\n# What is AsyncAPI?\n\nFrom the [AsyncAPI repo](https://github.com/asyncapi/asyncapi):\n\n> Create machine-readable definitions of your event-driven APIs.\n\nThe purpose of AsyncAPI is to provide a way for you to define how your event-driven applications (or APIs) communicate with the rest of the world. **AsyncAPI is focused on the application and the channels it uses to communicate**. Similar to what [OpenAPI](https://github.com/OAI/OpenAPI-Specification) and [RAML](https://raml.org/) do for REST APIs. Unlike CloudEvents —who focuses on the message— AsyncAPI does not impose how your event must look like but, instead, allows you to strictly define its shape. See an example:\n\n```yaml\nasyncapi: 2.0.0-rc1\nid: urn:com.asyncapi.examples.user\ninfo:\n  title: User service\n  version: 1.6.3\nchannels:\n  user/signedup:\n    publish:\n      message:\n        payload:\n          type: object\n          properties:\n            fullName:\n              type: string\n            email:\n              type: string\n              format: email\n```\n\nLooking at the example above, one can rapidly say this is the AsyncAPI definition of a User service, which its API version is 1.6.3 and it publishes to the `user/signedup` channel an event that is an object containing two properties: `fullName` and `email`.\n\nWe can define the event payload but its structure is totally free and user-defined. And that's what makes AsyncAPI so powerful! Since our event payload can be anything, it can also be a CloudEvents event.\n\n# AsyncAPI + CloudEvents\n\nLet's see an example of the two combined:\n\n```yaml\nasyncapi: 2.0.0-rc1\nid: urn:com.asyncapi.examples.user\ninfo:\n  title: User service\n  version: 1.6.3\nchannels:\n  user/signedup:\n    publish:\n      message:\n        payload:\n          type: object\n          properties:\n            specversion:\n              type: string\n              enum: ['0.2']\n            type:\n              type: string\n              example: com.github.pull.create\n            source:\n              type: string\n              format: uri\n              example: urn:com.asyncapi.examples.user\n            id:\n              type: string\n              example: 'A234-1234-1234'\n            time:\n              type: string\n              format: date-time\n              example: 2018-04-05T17:31:00Z\n            contenttype:\n              type: string\n              example: 'application/json'\n            data:\n              type: object\n              properties:\n                fullName:\n                  type: string\n                email:\n                  type: string\n                  format: email\n```\n\nLooking at the example above, one can say this is the AsyncAPI definition of a User service, which its API version is 1.6.3 and it publishes to the `user/signedup` channel a CloudEvents event whose data is a JSON object containing two properties: `fullName` and `email`.\n\n## Leveraging AsyncAPI Custom Schema Formats\n\nThere's only one concern with the approach above: every single CloudEvents definition is going to be exactly the same from line 11 to 33 — except for the examples that were added in this blog for clarity.\n\nThe default format for defining events (messages) in AsyncAPI 2.0 is JSON Schema. Thankfully, AsyncAPI provides a way to define events in your own custom format —like Avro and Protobuf — or a hypothetical CloudEvents one in this case. See example:\n\n<CodeBlock highlightedLines={[10]}>\n{`asyncapi: 2.0.0-rc1\nid: urn:com.asyncapi.examples.user\ninfo:\n  title: User service\n  version: 1.6.3\nchannels:\n  user/signedup:\n    publish:\n      message:\n        schemaFormat: 'application/cloudevents+json; version=0.2; charset=utf-8'\n        payload:\n          type: object\n          properties:\n            fullName:\n              type: string\n            email:\n              type: string\n              format: email`}\n</CodeBlock>\n\nThis results in a much shorter and nicer way of defining the usage of CloudEvents inside an AsyncAPI document.\n\n## Ok, it's possible but, does it makes sense?\n\nIt really depends on your use case but it makes sense in scenarios where some kind of FaaS is involved. Consider the following example:\n\n![](/img/diagrams/asyncapi-cloudevents.webp)\n\nReading the diagram from the bottom up, we see an overly simplified diagram of a sign up process. The `user/signedup` event flows from the REST API to the monitoring service and the FaaS API through the broker. The event could have the CloudEvents format so that both, the FaaS API and the monitoring service, understand it. Obviously, one may argue that the Faas API could be wrapping the event data in CloudEvents format and leave the rest of the events untouched, in plain JSON. Fair.\n\nSo, does it really makes sense? It certainly does in some situations. Do you have to use AsyncAPI and CloudEvents together? As always that's up to you. **You have the tools. Choose them wisely.**\n\n# Conclusion\n\nWe've learned how AsyncAPI differs from CloudEvents. Before I finish these lines, I'd like to make something clear again: AsyncAPI focuses on the application and how it is connected; and CloudEvents focuses on the message. Both things are compatible and complementary. Evaluate what are your needs and decide which one suits them better. There's no one-size-fits-all solution.\n\nI hope you learned something new, if so, please consider donating to the [AsyncAPI Initiative](https://opencollective.com/asyncapi).\n\nUntil next time! 👋",
    "toc": [
      {
        "content": "What is CloudEvents?",
        "slug": "what-is-cloudevents",
        "lvl": 1,
        "i": 0,
        "seen": 0
      },
      {
        "content": "What is AsyncAPI?",
        "slug": "what-is-asyncapi",
        "lvl": 1,
        "i": 1,
        "seen": 0
      },
      {
        "content": "AsyncAPI + CloudEvents",
        "slug": "asyncapi--cloudevents",
        "lvl": 1,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Leveraging AsyncAPI Custom Schema Formats",
        "slug": "leveraging-asyncapi-custom-schema-formats",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Ok, it's possible but, does it makes sense?",
        "slug": "ok-its-possible-but-does-it-makes-sense",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Conclusion",
        "slug": "conclusion",
        "lvl": 1,
        "i": 5,
        "seen": 0
      }
    ],
    "slug": "/blog/asyncapi-cloud-events",
    "filePath": "pages/blog/asyncapi-cloud-events.md"
  },
  {
    "meta": {
      "title": "Status update (week 17, 2019)",
      "date": "2019-04-25T12:56:52.000Z",
      "type": "Communication",
      "tags": [
        "Status Update"
      ],
      "cover": "/img/posts/status-update-week-17-2019.webp",
      "authors": [
        {
          "name": "Fran Méndez",
          "photo": "/img/avatars/fmvilas.webp",
          "link": "https://twitter.com/fmvilas",
          "byline": "AsyncAPI founder"
        }
      ],
      "excerpt": "Alas güenas tardis! This week we've made significant progress on the documentation and the parser. The goal is to make AsyncAPI 2.0.0 easy and quick to learn at the same time we provide you the necessary tools to start playing with it.",
      "readingTime": 3
    },
    "content": "\nAlas güenas tardis! This week we've made significant progress on the documentation and the parser. The goal is to make AsyncAPI 2.0.0 easy and quick to learn at the same time we provide you the necessary tools to start playing with it. Check out the progress so far:\n\n## The parser\n\n1. [Compile for all platforms](https://github.com/asyncapi/parser/pull/32): One of the hardest things to solve, before we continue moving forward, was the compilation process. We had to make sure we can compile the Go parser to C shared objects for Linux, Mac, and Windows. To make thing easier, we moved the compilation process to Travis CI, so now we don't have to configure our computers for cross-compilation.\n2. [JSON Schema dereferencing](https://github.com/asyncapi/parser/pull/33): When we decided to choose Go as our main language for the parser development we knew there were less libraries than in the Node.js universe. One of the missing pieces was a JSON Schema dereferencer, i.e., a library that takes a JSON Schema document and replaces all the appearances of `$ref` with the value they point to. [Rubén](https://twitter.com/xinoman12) came up with an initial solution and he's now working on polishing it, extracting the code to a separate library so the Go community can benefit from it, and adding support for circular references.\n\n## The documentation\n\n1. [New Getting Started guide](https://www.asyncapi.com/docs/getting-started/): This week we just launched our new getting started guide for AsyncAPI 2.0.0. The guide targets new users of AsyncAPI and event-driven architectures. Also, if you're coming from OpenAPI (Swagger), don't miss the comparative chart.\n2. [New blog](https://www.asyncapi.com/blog/): Enough with Medium. There's no point on hosting the blog on a service that puts very low limits on how much you can read for free. We'll keep posting there as a distribution channel but the full articles will live in our self-hosted blog, powered by [Hugo](https://gohugo.io).\n\n## Talks\nJoin us tomorrow for [API days Madrid](http://apidaysmad.apiaddicts.org/schedule/#session-2) if you're in the city. I'll be talking all things AsyncAPI, past, present, and future. And also having some beers and tapas 🍻. Let's connect!\n\n## Donate\nAnd last but not least, we’re running a sponsorship campaign. We’ve got different tiers so that everybody can show their love! ❤️\n\n![](/img/posts/donation.webp)\n\n[Donate here](https://opencollective.com/asyncapi). Help Open Source projects.\n\n---\n\n> “Victorious warriors win first and then go to war, while defeated warriors go to war first and then seek to win.”\n> — Sun Tzu\n\nSee you next week, folks! 👋",
    "toc": [
      {
        "content": "The parser",
        "slug": "the-parser",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "The documentation",
        "slug": "the-documentation",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Talks",
        "slug": "talks",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Donate",
        "slug": "donate",
        "lvl": 2,
        "i": 3,
        "seen": 0
      }
    ],
    "slug": "/blog/status-update-week-17-2019",
    "filePath": "pages/blog/status-update-week-17-2019.md"
  },
  {
    "meta": {
      "title": "Getting started with event-driven architectures",
      "date": "2019-04-19T15:56:52.000Z",
      "type": "Engineering",
      "tags": [
        "Getting Started",
        "EDA"
      ],
      "cover": "/img/posts/getting-started-with-event-driven-architectures.webp",
      "authors": [
        {
          "name": "Fran Méndez",
          "photo": "/img/avatars/fmvilas.webp",
          "link": "https://twitter.com/fmvilas",
          "byline": "AsyncAPI founder"
        }
      ],
      "readingTime": 4,
      "excerpt": "All developers, architects, and product managers are used to REST APIs and the synchronous paradigm of communication. You make a request and wait for the response. This is exactly how the web works. Y"
    },
    "content": "\nAll developers, architects, and product managers are used to REST APIs and the synchronous paradigm of communication. You make a request and wait for the response. This is exactly how the web works. You enter a URL (e.g., google.com) in the address bar of your favorite browser and it sends a request to the server. Following, the server sends the response with the content of the website. **The web is the greatest implementation of a REST API.**\n\nHowever, there are certain situations when you don't really need a response from the server. At least no other than the confirmation the request has been received. This is also called _\"fire and forget\"_, and it's really useful when you just want to communicate or inform that \"something happened.\" It is, you're not requesting or asking for anything, thus you don't need a response.  Examples of this are:\n\n* A user just signed up.\n* You have a new follower.\n* Your fridge is getting empty.\n\nAlong with the event, you may also want to send _extra information_. For instance:\n\n* A user just signed up: here's the user information (e.g., name, email, age, etc.)\n* You have a new follower: here are the details of the follower (e.g., username, name, picture, etc.)\n* Your fridge is getting empty: here's the percentage of \"emptiness\" (e.g., 23%)\n\nThis extra information is often referred to as _event payload_ or _message payload_.\n\n## Core concepts\n\n![](/img/diagrams/simple-event-driven.webp)\n\nIn most cases, Event-Driven Architectures (EDAs) are broker-centric, like in the diagram above. In it you can find some new concepts, so let's go through them now.\n\n### Message broker\n\nA message broker (or _\"broker\"_) is a piece of infrastructure in charge of receiving messages and delivering them to those who have shown interest. They often store messages until they are delivered, what makes EDAs very resilient to failures. Examples of brokers are [RabbitMQ](https://rabbitmq.com), [Apache Kafka](http://kafka.apache.org/), [Solace](http://solace.com), etc.\n\n### Publisher/Subscriber\n\nA publisher (a.k.a. _producer_) is an application that sends messages to the _broker_.\n\nA subscriber (a.k.a. _consumer_) is an application that connects to the _broker_, manifests interest in certain type of messages, and leaves the connection open so the _broker_ can push messages to them.\n\n### Message\n\nA message is a piece of information that's sent by the publishers to the broker, and received by all the interested subscribers. The content of the message can be anything but they are frequently catalogued as _events_ and _commands_. As we saw above, _events_ communicate a fact that occurred. Instead, _commands_ are very much like _requests_ in REST APIs: they tell the subscribers \"do this\".\n\n**Technically speaking, _events_ and _commands_ are the same. The only difference is in their semantics.**\n\n### Channels\n\nOne detail that might pass unnoticed from the diagram above is the existence of _channels_. All the _brokers_ support communication through multiple channels. The industry doesn't have a common term though so you may find them as _topics_, _routing keys_, _event types_, and probably other ones I'm missing.\n\nThey're usually assigned a name or identifier (e.g., `user_signed_up`) and it's often a good practice to send a single type of message through them. Think about TV or radio channels: the BBC only broadcasts its information through an assigned channel. If the broadcasters (publishers) didn't respect that rule you (the subscriber) would only see and hear interferences.\n\n## Why \"event-driven\" and not \"message-driven\"?\n\nYou will find both used interchangeably, although they are not exactly the same. You will even find _\"message-based\"_ and _\"event-based\"_. In practice, chances are they all refer to the same thing.\n\nTheoretically, _\"message-driven\"_ is the most generic term, meaning you may use events and commands, while _event-driven_ means that it's purely about events. However, that's not always the case, as Martin Fowler explains in his talk _\"the many meanings of event-driven architecture\"_:\n\n<YouTube id=\"STKCRSUsyP0\" />\n\n## Conclusion\n\nWe've seen what an event-driven architecture is, how it works, and what are their components. AsyncAPI is all about defining and documenting each of these components.\n\nCheck out our [getting started guide](/docs/getting-started/) to learn more.",
    "toc": [
      {
        "content": "Core concepts",
        "slug": "core-concepts",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Message broker",
        "slug": "message-broker",
        "lvl": 3,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Publisher/Subscriber",
        "slug": "publishersubscriber",
        "lvl": 3,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Message",
        "slug": "message",
        "lvl": 3,
        "i": 3,
        "seen": 0
      },
      {
        "content": "Channels",
        "slug": "channels",
        "lvl": 3,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Why \"event-driven\" and not \"message-driven\"?",
        "slug": "why-event-driven-and-not-message-driven",
        "lvl": 2,
        "i": 5,
        "seen": 0
      },
      {
        "content": "Conclusion",
        "slug": "conclusion",
        "lvl": 2,
        "i": 6,
        "seen": 0
      }
    ],
    "slug": "/blog/getting-started-with-event-driven-architectures",
    "filePath": "pages/blog/getting-started-with-event-driven-architectures.md"
  },
  {
    "meta": {
      "title": "Status update (week 15, 2019)",
      "date": "2019-04-11T12:56:52.000Z",
      "type": "Communication",
      "tags": [
        "Status Update"
      ],
      "cover": "/img/posts/status-update-week-15-2019.webp",
      "authors": [
        {
          "name": "Fran Méndez",
          "photo": "/img/avatars/fmvilas.webp",
          "link": "https://twitter.com/fmvilas",
          "byline": "AsyncAPI founder"
        }
      ],
      "readingTime": 2,
      "excerpt": "Kaixo lagunak! This week we continued working on the parser as it’s a top priority for us. We made significant progress and plan to release a simple but functional version soon.\nBuilding the parser\n\nW"
    },
    "content": "\nKaixo lagunak! This week we continued working on the parser as it’s a top priority for us. We made significant progress and plan to release a simple but functional version soon.\n\n## Building the parser\n\n![](/img/diagrams/parser-architecture.webp)\n\n1. [We’ve added support for AsyncAPI 1.x/OpenAPI schemas](https://github.com/asyncapi/parser/pull/31). This is the first step before we dive into Avro and Protobuf support.\n2. [Updated the Node.js to automatically test itself on Linux, Mac, and Windows](https://github.com/asyncapi/parser-nodejs). We’re still struggling to debug some failures on Windows so we encourage people who work on this operating system to join and help us test.\n\n## Talks\nI’ll be speaking about AsyncAPI and event-driven architectures in a few conferences. Let’s connect!\n\n* API Days Madrid (April 26): http://apidaysmad.apiaddicts.org/schedule/#session-2\n* Gartner AADI (May 20–21): https://www.gartner.com/en/conferences/emea/applications-uk\n* KubeCon Europe (Barcelona, May 22–23). Not speaking but let’s meet there! https://events.linuxfoundation.org/events/kubecon-cloudnativecon-europe-2019/\n* REST Fest Europe (Wrocław, May 31): http://2019.restfest.org/eu/schedule\n* API Days Finland (Helsinki, June 4–5): https://www.apidays.fi/\n\n## Donate\nAnd last but not least, we’re running a sponsorship campaign. We’ve got different tiers so that everybody can show their love! ❤️\n\n![](/img/posts/donation.webp)\n\n[Donate here](https://opencollective.com/asyncapi). Help Open Source projects.\n\n---\n\n> “People who think they know everything are a great annoyance to those of us who do.”\n> — Isaac Asimov\n\n😄\n\nSee you next week, folks! 👋",
    "toc": [
      {
        "content": "Building the parser",
        "slug": "building-the-parser",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Talks",
        "slug": "talks",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Donate",
        "slug": "donate",
        "lvl": 2,
        "i": 2,
        "seen": 0
      }
    ],
    "slug": "/blog/status-update-week-15-2019",
    "filePath": "pages/blog/status-update-week-15-2019.md"
  },
  {
    "meta": {
      "title": "Replicating the Success of REST in Event-Driven Architecture",
      "date": "2019-04-04T12:56:52.000Z",
      "type": "Engineering",
      "tags": [
        "REST APIs",
        "EDA"
      ],
      "cover": "/img/posts/replicating-success-of-rest.webp",
      "authors": [
        {
          "name": "Jonathan Schabowsky",
          "photo": "/img/avatars/jschabowsky.webp",
          "link": "https://twitter.com/jschabowsky",
          "byline": "Sr. Architect at Solace"
        },
        {
          "name": "Fran Méndez",
          "photo": "/img/avatars/fmvilas.webp",
          "link": "https://twitter.com/fmvilas",
          "byline": "AsyncAPI founder"
        }
      ],
      "excerpt": "Jonathan explained in his last blog post how the loose coupling of applications associated with event-driven architecture and publish/subscribe messaging is both a strength and a weakness.",
      "readingTime": 8
    },
    "content": "\n_This post is a collaboration between <a href=\"https://solace.com/blog/author/franmendez/\" target=\"_blank\">Fran Méndez</a> of AsyncAPI and Solace’s <a href=\"https://solace.com/blog/author/jonathan-schabowsky/\" target=\"_blank\">Jonathan Schabowsky</a>. It was originally published at <a href=\"https://solace.com/blog/rest-event-driven-architecture/\" target=\"_blank\">Solace’s blog</a>._\n\nJonathan explained in his <a href=\"https://solace.com/blog/downside-event-driven-architecture/\" target=\"_blank\">last blog post</a> how the loose coupling of applications associated with event-driven architecture and publish/subscribe messaging is both a strength and a weakness. As part of that, he touched on the fact that request/reply interactions using RESTful APIs are still the dominant application integration paradigm, even in hybrid cloud, machine learning and IoT use cases that benefit from event-driven interactions. There’s still tons of use cases for which RESTful request/reply interactions are perfect, but it’s important to be able to mix and match the right exchange pattern (Command, Query and Event) for the job especially where event-driven would be best suited.\n\nIn many cases, exploring why one thing has established or maintained popularity can help you understand why something else isn’t quite as hot, even though it seems like it should be. With this post I’ll investigate why the use of RESTful APIs is still so prevalent, and see if the reasons for its persistent popularity might act as a blueprint for making event-driven popular and mainstream. So, how did REST come to be the most popular way to connect applications? And why does everyone think it’s so easy?\n\n## How did REST get to be so hot?\nREST’s popularity arose out of the need for data exchange and interactions between the web browser and backend services. In that context it became a de facto standard because it integrated so well with JavaScript and was so much easier than SOAP (a decent protocol that became bloated and complicated over time). From there, developers started using REST to connect internal enterprise applications, IoT devices and even microservices. It might not have been the best fit for all those use cases, but it got the job done.\n\nAs <a href=\"https://twitter.com/MattMcLartyBC\" target=\"_blank\">Matt McLarty</a> mentions in his blog post <a href=\"https://www.infoq.com/articles/overcoming-restlessness?utm_source=sumome&utm_medium=twitter&utm_campaign=sumome_share\" target=\"_blank\">Overcoming RESTlessness</a>, a complete examination about why REST started to be used in places that it’s not ideal for “would ignore the power that comes from REST’s universality.” He’s referring to the fact that REST has become universal because developers “get it” and it’s surrounded by a thriving ecosystem of complementary technology and tools. Without this ecosystem that REST inherited from the web world, that universal adoption simply would not have happened.\n\n## The Building Blocks of REST’s Success\nIf you look closely at this ecosystem (foreshadowing) you can see that it’s composed of some foundational components upon which the open source and vendor community have built what I’ll call “enablement tooling.” Here’s what I mean:\n\n## Foundational Components\n* **Web servers** were the workhorse of the web for years before REST came into existence. They were much simpler than the application servers of the time and optimized to deal with large numbers of lightweight request/reply communications interactions like serving up a web page that somebody requests.\n* **Development frameworks** like Spring, JAX-RS, Restlet and Node.js reflect the fact that people invested time and energy to make the developer experience easy, i.e. keeping them from having to write boilerplate connection code so they could focus on the hard part of developing and refining business logic.\n* **Security frameworks** like OAUTH for authentication and authorization, and TLS for encryption, established the means by which interactions and information can be made secure.\n\n## Enablement Tooling\n* **API Management**: Companies like Apigee and MuleSoft built platforms that provide an API portal so developers can describe and discover APIs in design-time, API gateways to ensure security, management and API mediation, and finally usage analytics which inform which APIs are most and least used. These API management solutions are used increasingly for sophisticated API creation and design, and to act as API marketplaces.\n* **Runtime API Discovery**: As APIs and applications have become increasingly dynamic and distributed due to continuous delivery, containerization, cloud-bursting, discovery tooling such as Netflix Eureka and Istio/Envoy (service mesh) have been created to reduce the complexity of API clients and enable them to connect to services anywhere.\n* **Specification for API Description**: OpenAPI was created as a machine-readable metadata specification in order to document, design and consume APIs. This is incredibly valuable for use by testing tools, clients and document generation.\n* **Code Generation Tools**: Swagger and its associated code generation tooling lets developers easily take an OpenAPI definition and generate either client or server code, drastically reducing the amount of work it takes development teams to use APIs.\n\nWithout the foundational components, not only would the enablement tooling not have been possible, there wouldn’t have been any need or demand for it. This ecosystem of tools has facilitated REST’s ascension to its position as the de facto standard for application interactions today. While I lament the fact that event-driven hasn’t achieved this same level of adoption and devotion, I understand why, and know that without similar tooling it never will.\n\n## How Event-Driven is Following in REST’s Footsteps\nThere is no reason why the event-driven world can’t learn from the RESTful API world by leveraging and developing similar foundational components and enablement tools. In fact, some very exciting initiatives are underway and picking up steam in the industry and within Solace:\n\n## Foundational Components\n* **Event Brokers**: This one is easy as many simple (RabbitMQ, ActiveMQ) and advanced event brokers (Solace PubSub+, Kafka) exist today. Many of them are battle-tested and used widely in organizations that are event-driven.\n* **Development Frameworks**: Spring Cloud Stream makes writing event-driven microservices easy, and Paho for MQTT makes it easy to create event-driven IoT sensors in many programming languages.\n* **Security**: Frameworks like OAuth enable authentication and authorization in the event-driven world along with TLS for encryption for confidentiality/integrity.\n\n## Enablement Tooling\n* **Event Management**: While <a href=\"https://solace.com/what-is-an-event-broker/\" target=\"_blank\">advanced event brokers</a> perform many functions similar to those of an API Gateway, no vendor offers a platform that does everything for events that API management platforms do for RESTful API interactions. There are no “event portals” for developers to use, for example, in order to design, document and discover events.\n* **Runtime Event Discovery**: In the Eventing world, the ability to deliver events to consumers is even more complicated than with APIs because of the combination of 1-many event distribution, guaranteed and in-order quality of services along with event producers and consumers being just as dynamic and distributed as what is found with APIs. This has challenged infrastructure and operations teams for years all while client applications should not be burdened with these complexities. The <a target=\"_blank\" href=\"https://solace.com/what-is-an-event-mesh/\">event mesh</a> is an emerging architectural concept that provides similar functionality to the <a target=\"_blank\" href=\"https://www.nginx.com/blog/what-is-a-service-mesh/\">service mesh</a> but is targeted towards asynchronous interaction patterns. This removes the complexities previously described by enabling producers and consumers to exchange events regardless of where they are physically deployed all while maintaining event delivery qualities of service.\n* **API Description Specification**: [AsyncAPI](https://www.asyncapi.com/) is on a mission to standardize event-driven API interactions and support the wide variety of messaging systems available. This is a corollary to <a target=\"_blank\" href=\"https://swagger.io/docs/specification/about/\">OpenAPI</a> — a universal language for all the different messaging protocols and event schema formats. The purpose of AsyncAPI is to enable architects and developers to specify the event payload definition, channel name, application/transport headers and protocol– thus fully specifying the application’s event-driven interface. This was previously not available but, thanks to Fran Méndez and the AsyncAPI Initiative, event-driven applications will receive the same love as RESTful APIs.\n* **Code Generation Tools**: AsyncAPI is also working in this direction. For instance, the ability to take an AsyncAPI definition and generate event-driven applications is underway for Spring Cloud Stream. This will drastically reduce the effort to create new applications!\n\n## Conclusion\nEDA’s popularity has started to drastically increase as many companies are realizing they MUST react in real-time to their customers, decouple their systems and transform into event-driven organizations. However, for event-driven interactions to achieve the same level of adoption as REST, the build-out of tooling for eventing must continue. Now is the time to transform and support all the patterns modern applications need for interaction, i.e. commands, queries… and events!\n\nSolace is committed to helping organizations realize the advantages of being event-driven. We’re active on all these fronts by continuing to advance the state of the art with our PubSub+ event broker and <a target=\"_blank\" href=\"https://solace.com/blog/event-mesh/\">event mesh</a>, enthusiastically supporting <a target=\"_blank\" href=\"https://solace.com/blog/unlock-potential-spring-cloud-stream/\">Spring Cloud Streams</a>, and actively contributing expertise and financial support to [AsyncAPI](https://www.asyncapi.com/). Stay tuned for more information around how event management and API management are similar, how it is a key capability that organizations need, and what Solace is doing about it!",
    "toc": [
      {
        "content": "How did REST get to be so hot?",
        "slug": "how-did-rest-get-to-be-so-hot",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "The Building Blocks of REST’s Success",
        "slug": "the-building-blocks-of-rests-success",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Foundational Components",
        "slug": "foundational-components",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Enablement Tooling",
        "slug": "enablement-tooling",
        "lvl": 2,
        "i": 3,
        "seen": 0
      },
      {
        "content": "How Event-Driven is Following in REST’s Footsteps",
        "slug": "how-event-driven-is-following-in-rests-footsteps",
        "lvl": 2,
        "i": 4,
        "seen": 0
      },
      {
        "content": "Foundational Components",
        "slug": "foundational-components",
        "lvl": 2,
        "i": 5,
        "seen": 1
      },
      {
        "content": "Enablement Tooling",
        "slug": "enablement-tooling",
        "lvl": 2,
        "i": 6,
        "seen": 1
      },
      {
        "content": "Conclusion",
        "slug": "conclusion",
        "lvl": 2,
        "i": 7,
        "seen": 0
      }
    ],
    "slug": "/blog/replicating-success-rest-event-driven-architecture",
    "filePath": "pages/blog/replicating-success-rest-event-driven-architecture.md"
  },
  {
    "meta": {
      "title": "Status update (week 14, 2019)",
      "date": "2019-04-04T12:56:52.000Z",
      "type": "Communication",
      "tags": [
        "Status Update"
      ],
      "cover": "/img/posts/status-update-week-14-2019.webp",
      "authors": [
        {
          "name": "Fran Méndez",
          "photo": "/img/avatars/fmvilas.webp",
          "link": "https://twitter.com/fmvilas",
          "byline": "AsyncAPI founder"
        }
      ],
      "readingTime": 2,
      "excerpt": "Hallo meine Freunde! This week we’ve done great progress on tooling and documentation. It will be our main focus for the next month. In the meantime, check out what we did last week. Read on!\nImprovem"
    },
    "content": "\nHallo meine Freunde! This week we’ve done great progress on tooling and documentation. It will be our main focus for the next month. In the meantime, check out what we did last week. Read on!\n\n## Improvements on documentation\n1. Check out version 2.0.0-rc1 of the specification in our website: https://www.asyncapi.com/docs/specifications/2.0.0-rc1/.\n2. Added a “Hello world” article to our getting started guide: https://github.com/asyncapi/asyncapi.github.io/pull/3.\n3. Added a “Servers” article to our getting started guide, explaining how the “servers” section of AsyncAPI works: https://github.com/asyncapi/asyncapi.github.io/pull/4.\n\n## Improvements on tooling\n1. We managed to compile [our Go parser](https://github.com/asyncapi/parser) to Linux, Mac, and Windows C shared objects. This sets the base for an automated building process.\n2. As a result of the previous point, we managed to create a Node.js wrapper for the Go parser, making use of the C shared objects.\n\n## AsyncAPI SIG meeting\nWe had our bi-weekly SIG meeting this week where we talked about future plans and how to improve onboarding. And it’s now uploaded to [our Youtube channel](https://www.youtube.com/channel/UCIz9zGwDLbrYQcDKVXdOstQ).\n\n<YouTube id=\"GMFAAyEEqus\" />\n\n## Donate\nAnd last but not least, we’re running a sponsorship campaign. We’ve got different tiers so that everybody can show their love! ❤️\n\n![](/img/posts/donation.webp)\n\n[Donate here](https://opencollective.com/asyncapi). Help Open Source projects.\n\n---\n\n> “Great things in business are never done by one person. They’re done by a team of people.”\n> — Steve Jobs\n\nSee you next week, folks! 👋",
    "toc": [
      {
        "content": "Improvements on documentation",
        "slug": "improvements-on-documentation",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Improvements on tooling",
        "slug": "improvements-on-tooling",
        "lvl": 2,
        "i": 1,
        "seen": 0
      },
      {
        "content": "AsyncAPI SIG meeting",
        "slug": "asyncapi-sig-meeting",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Donate",
        "slug": "donate",
        "lvl": 2,
        "i": 3,
        "seen": 0
      }
    ],
    "slug": "/blog/status-update-week-14-2019",
    "filePath": "pages/blog/status-update-week-14-2019.md"
  },
  {
    "meta": {
      "title": "Organizing your AsyncAPI documents",
      "date": "2019-03-01T12:56:52.000Z",
      "type": "Engineering",
      "tags": [
        "Specification"
      ],
      "cover": "/img/posts/organizing-asyncapi-documents.webp",
      "authors": [
        {
          "name": "Fran Méndez",
          "photo": "/img/avatars/fmvilas.webp",
          "link": "https://twitter.com/fmvilas",
          "byline": "AsyncAPI founder"
        }
      ],
      "readingTime": 5,
      "excerpt": "A recurring question that I get very often is: “how do I organize my AsyncAPI documents?”. Also, the related one: “I have two services, a publisher and a consumer, should I define both in the same Asy"
    },
    "content": "\nA recurring question that I get very often is: “how do I organize my AsyncAPI documents?”. Also, the related one: “I have two services, a publisher and a consumer, should I define both in the same AsyncAPI document?”.\n\nLet’s break down some best practices and tips to avoid ending up in a hell of unmanageable documents.\n\n## Organizing Microservices\n> I’m using the term microservices here because it’s the most common type of distributed architecture that you can find nowadays.\n\nThe best practice for organizing AsyncAPI files in your microservices architecture is to have a file per microservice. This way, you end up with multiple independent files that define your application.\n\n<figure>\n  <img src=\"/img/posts/organizing-asyncapi-documents-1.webp\" title=\"One publisher and one subscriber, both sharing the UserSignUp message.\"/>\n  <figcaption className=\"text-center text-gray-400 text-sm\">One publisher and one subscriber, both sharing the UserSignUp message.</figcaption>\n</figure>\n\nMicroservices are meant to do a single thing and to do it well and, very importantly, they must be independently deployable. However, if you have a publisher and multiple consumers, you quickly end up having something like the following:\n\n<figure>\n  <img src=\"/img/posts/organizing-asyncapi-documents-2.webp\" title=\"One publisher and various subscribers. All of them sharing the UserSignUp message.\"/>\n  <figcaption className=\"text-center text-gray-400 text-sm\">One publisher and various subscribers. All of them sharing the UserSignUp message.</figcaption>\n</figure>\n\nIt’s clear there’s a dependency between all of them: the _UserSignedUp_ message. If at some point to want to change it, you’ll have to go through all of the files and change it. It’s a tedious task we want to avoid, so we can make use of the _$ref_ capability of AsyncAPI to simplify things:\n\n<figure>\n  <img src=\"/img/posts/organizing-asyncapi-documents-3.webp\" title=\"The value of $ref should be “common/messages.json#UserSignedUp”.\"/>\n  <figcaption className=\"text-center text-gray-400 text-sm\">The value of $ref should be “common/messages.json#UserSignedUp”.</figcaption>\n</figure>\n\nNow, if you have to add something to the _UserSignedUp_ message, it’s just a matter of changing one file. Depending on your setup, you may have to restart your services to get the new definition. However, as simple and straightforward as it may seem, you must take care not to introduce breaking changes in the message definition. Otherwise, you’ll have inconsistent states while some services got the new message definition and some didn’t yet. Here comes the importance of versioning your messages, but that makes for another blog post alone.\n\n### Common mistakes\n\nSince microservices tend to be small in scope, most probably their AsyncAPI document will not be very extensive too. And I found out this is one of the reasons people tend to re-use the same file for many services. They think the file is very small and because the publisher and the subscriber share the same message, why not putting everything there? It’s tempting at first, but the reason why you should avoid doing this is that you lose context and semantics, and it causes problems:\n\n1. If a single document contains publish and subscribe for the same channel (topic), how do you know which one is defining what your application does?\n2. Since your document may contain many channels, how do you know if your application is publishing or subscribing to each channel or just a subset of them? That itself causes more problems, for instance, when you want to generate the documentation for a single service but you have a single file defining your whole architecture and thus a single documentation page describing all the services without any clue which one is doing what.\n\n**An AsyncAPI file is meant to define the behavior of a single application**. You can obviously break the rules and use it to define the whole architecture but expect all sorts of problems to appear because you’re using a hammer to saw a piece of wood. The same way you don’t use a single OpenAPI (Swagger) file to define many of your REST APIs, you shouldn’t use a single AsyncAPI document to define many of your message-driven APIs.\n\n## Organizing Client-Server\nSay, for instance, you have a WebSockets API and front-end application using it. The paradigm is very similar to the one we’re used to with HTTP APIs, with the subtle difference that the communication is [full duplex](https://en.wikipedia.org/wiki/Duplex_%28telecommunications%29#Full_duplex), i.e., the client can send and receive messages over the same channel, at any time.\n\nThis case is not very different from the microservices one. If you think about it, we can look at it as a small distributed architecture, where you only have two services: the client and the server. So the recommended best practice is to follow the same approach and have one document for each of the applications — one for the server and another for the client or front-end.\n\n## Summary\nI want to reinforce the point that an AsyncAPI file is meant to define **the behavior of a single application**. Keep this always in mind, and everything will make sense to you.\n\nHappy coding! ✌️\n\n---\n\nAsyncAPI is an open source project running on donations so **please [consider donating](https://opencollective.com/asyncapi)** 🙌\n",
    "toc": [
      {
        "content": "Organizing Microservices",
        "slug": "organizing-microservices",
        "lvl": 2,
        "i": 0,
        "seen": 0
      },
      {
        "content": "Common mistakes",
        "slug": "common-mistakes",
        "lvl": 3,
        "i": 1,
        "seen": 0
      },
      {
        "content": "Organizing Client-Server",
        "slug": "organizing-client-server",
        "lvl": 2,
        "i": 2,
        "seen": 0
      },
      {
        "content": "Summary",
        "slug": "summary",
        "lvl": 2,
        "i": 3,
        "seen": 0
      }
    ],
    "slug": "/blog/organizing-asyncapi-documents",
    "filePath": "pages/blog/organizing-asyncapi-documents.md"
  }
]